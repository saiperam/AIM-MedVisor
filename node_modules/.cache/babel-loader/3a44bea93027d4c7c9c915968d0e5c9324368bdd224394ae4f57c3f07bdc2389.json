{"ast":null,"code":"// src/index.ts\nimport { raf } from \"@zag-js/dom-query\";\nvar refCountMap = /* @__PURE__ */new WeakMap();\nvar observerStack = [];\nfunction ariaHiddenImpl(targets) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    rootEl\n  } = options;\n  const exclude = targets.filter(Boolean);\n  if (exclude.length === 0) return;\n  const doc = exclude[0].ownerDocument || document;\n  const win = doc.defaultView ?? window;\n  const visibleNodes = new Set(exclude);\n  const hiddenNodes = /* @__PURE__ */new Set();\n  const root = rootEl ?? doc.body;\n  let walk = root2 => {\n    for (let element of root2.querySelectorAll(\"[data-live-announcer], [data-zag-top-layer]\")) {\n      visibleNodes.add(element);\n    }\n    let acceptNode = node => {\n      if (visibleNodes.has(node) || hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute(\"role\") !== \"row\") {\n        return NodeFilter.FILTER_REJECT;\n      }\n      for (let target of visibleNodes) {\n        if (node.contains(target)) {\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n      return NodeFilter.FILTER_ACCEPT;\n    };\n    let walker = doc.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT, {\n      acceptNode\n    });\n    let acceptRoot = acceptNode(root2);\n    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {\n      hide(root2);\n    }\n    if (acceptRoot !== NodeFilter.FILTER_REJECT) {\n      let node = walker.nextNode();\n      while (node != null) {\n        hide(node);\n        node = walker.nextNode();\n      }\n    }\n  };\n  let hide = node => {\n    let refCount = refCountMap.get(node) ?? 0;\n    if (node.getAttribute(\"aria-hidden\") === \"true\" && refCount === 0) {\n      return;\n    }\n    if (refCount === 0) {\n      node.setAttribute(\"aria-hidden\", \"true\");\n    }\n    hiddenNodes.add(node);\n    refCountMap.set(node, refCount + 1);\n  };\n  if (observerStack.length) {\n    observerStack[observerStack.length - 1].disconnect();\n  }\n  walk(root);\n  const observer = new win.MutationObserver(changes => {\n    for (let change of changes) {\n      if (change.type !== \"childList\" || change.addedNodes.length === 0) {\n        continue;\n      }\n      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {\n        for (let node of change.removedNodes) {\n          if (node instanceof win.Element) {\n            visibleNodes.delete(node);\n            hiddenNodes.delete(node);\n          }\n        }\n        for (let node of change.addedNodes) {\n          if ((node instanceof win.HTMLElement || node instanceof win.SVGElement) && (node.dataset.liveAnnouncer === \"true\" || node.dataset.zagTopLayer === \"true\")) {\n            visibleNodes.add(node);\n          } else if (node instanceof win.Element) {\n            walk(node);\n          }\n        }\n      }\n    }\n  });\n  observer.observe(root, {\n    childList: true,\n    subtree: true\n  });\n  let observerWrapper = {\n    observe() {\n      observer.observe(root, {\n        childList: true,\n        subtree: true\n      });\n    },\n    disconnect() {\n      observer.disconnect();\n    }\n  };\n  observerStack.push(observerWrapper);\n  return () => {\n    observer.disconnect();\n    for (let node of hiddenNodes) {\n      let count = refCountMap.get(node);\n      if (count === 1) {\n        node.removeAttribute(\"aria-hidden\");\n        refCountMap.delete(node);\n      } else {\n        refCountMap.set(node, count - 1);\n      }\n    }\n    if (observerWrapper === observerStack[observerStack.length - 1]) {\n      observerStack.pop();\n      if (observerStack.length) {\n        observerStack[observerStack.length - 1].observe();\n      }\n    } else {\n      observerStack.splice(observerStack.indexOf(observerWrapper), 1);\n    }\n  };\n}\nfunction ariaHidden(targetsOrFn) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    defer\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups = [];\n  cleanups.push(func(() => {\n    const targets = typeof targetsOrFn === \"function\" ? targetsOrFn() : targetsOrFn;\n    cleanups.push(ariaHiddenImpl(targets, options));\n  }));\n  return () => {\n    cleanups.forEach(fn => fn?.());\n  };\n}\nexport { ariaHidden };","map":{"version":3,"names":["raf","refCountMap","WeakMap","observerStack","ariaHiddenImpl","targets","options","arguments","length","undefined","rootEl","exclude","filter","Boolean","doc","ownerDocument","document","win","defaultView","window","visibleNodes","Set","hiddenNodes","root","body","walk","root2","element","querySelectorAll","add","acceptNode","node","has","parentElement","getAttribute","NodeFilter","FILTER_REJECT","target","contains","FILTER_SKIP","FILTER_ACCEPT","walker","createTreeWalker","SHOW_ELEMENT","acceptRoot","hide","nextNode","refCount","get","setAttribute","set","disconnect","observer","MutationObserver","changes","change","type","addedNodes","some","removedNodes","Element","delete","HTMLElement","SVGElement","dataset","liveAnnouncer","zagTopLayer","observe","childList","subtree","observerWrapper","push","count","removeAttribute","pop","splice","indexOf","ariaHidden","targetsOrFn","defer","func","v","cleanups","forEach","fn"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/aria-hidden/src/index.ts"],"sourcesContent":["// Credits: https://github.com/adobe/react-spectrum/blob/main/packages/@react-aria/overlays/src/ariaHideOutside.ts\nimport { raf } from \"@zag-js/dom-query\"\n\nconst refCountMap = new WeakMap<Element, number>()\nconst observerStack: any[] = []\n\nexport interface AriaHiddenOptions {\n  rootEl?: HTMLElement\n  defer?: boolean\n}\n\ntype MaybeElement = HTMLElement | null\ntype Targets = Array<MaybeElement>\ntype TargetsOrFn = Targets | (() => Targets)\n\nfunction ariaHiddenImpl(targets: Targets, options: AriaHiddenOptions = {}) {\n  const { rootEl } = options\n\n  const exclude = targets.filter(Boolean) as HTMLElement[]\n  if (exclude.length === 0) return\n\n  const doc = exclude[0].ownerDocument || document\n  const win = doc.defaultView ?? window\n\n  const visibleNodes = new Set<Element>(exclude)\n  const hiddenNodes = new Set<Element>()\n\n  const root = rootEl ?? doc.body\n\n  let walk = (root: Element) => {\n    // Keep live announcer and top layer elements (e.g. toasts) visible.\n    for (let element of root.querySelectorAll(\"[data-live-announcer], [data-zag-top-layer]\")) {\n      visibleNodes.add(element)\n    }\n\n    let acceptNode = (node: Element) => {\n      // Skip this node and its children if it is one of the target nodes, or a live announcer.\n      // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is\n      // made for elements with role=\"row\" since VoiceOver on iOS has issues hiding elements with role=\"row\".\n      // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).\n      if (\n        visibleNodes.has(node) ||\n        (hiddenNodes.has(node.parentElement!) && node.parentElement!.getAttribute(\"role\") !== \"row\")\n      ) {\n        return NodeFilter.FILTER_REJECT\n      }\n\n      // Skip this node but continue to children if one of the targets is inside the node.\n      for (let target of visibleNodes) {\n        if (node.contains(target)) {\n          return NodeFilter.FILTER_SKIP\n        }\n      }\n\n      return NodeFilter.FILTER_ACCEPT\n    }\n\n    let walker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, { acceptNode })\n\n    // TreeWalker does not include the root.\n    let acceptRoot = acceptNode(root)\n    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {\n      hide(root)\n    }\n\n    if (acceptRoot !== NodeFilter.FILTER_REJECT) {\n      let node = walker.nextNode() as Element\n      while (node != null) {\n        hide(node)\n        node = walker.nextNode() as Element\n      }\n    }\n  }\n\n  let hide = (node: Element) => {\n    let refCount = refCountMap.get(node) ?? 0\n\n    // If already aria-hidden, and the ref count is zero, then this element\n    // was already hidden and there's nothing for us to do.\n    if (node.getAttribute(\"aria-hidden\") === \"true\" && refCount === 0) {\n      return\n    }\n\n    if (refCount === 0) {\n      node.setAttribute(\"aria-hidden\", \"true\")\n    }\n\n    hiddenNodes.add(node)\n    refCountMap.set(node, refCount + 1)\n  }\n\n  if (observerStack.length) {\n    observerStack[observerStack.length - 1].disconnect()\n  }\n\n  walk(root)\n\n  const observer = new win.MutationObserver((changes) => {\n    for (let change of changes) {\n      if (change.type !== \"childList\" || change.addedNodes.length === 0) {\n        continue\n      }\n\n      // If the parent element of the added nodes is not within one of the targets,\n      // and not already inside a hidden node, hide all of the new children.\n      if (![...visibleNodes, ...hiddenNodes].some((node) => node.contains(change.target))) {\n        for (let node of change.removedNodes) {\n          if (node instanceof win.Element) {\n            visibleNodes.delete(node)\n            hiddenNodes.delete(node)\n          }\n        }\n\n        for (let node of change.addedNodes) {\n          if (\n            (node instanceof win.HTMLElement || node instanceof win.SVGElement) &&\n            (node.dataset.liveAnnouncer === \"true\" || node.dataset.zagTopLayer === \"true\")\n          ) {\n            visibleNodes.add(node)\n          } else if (node instanceof win.Element) {\n            walk(node)\n          }\n        }\n      }\n    }\n  })\n\n  observer.observe(root, { childList: true, subtree: true })\n\n  let observerWrapper = {\n    observe() {\n      observer.observe(root, { childList: true, subtree: true })\n    },\n    disconnect() {\n      observer.disconnect()\n    },\n  }\n\n  observerStack.push(observerWrapper)\n\n  return () => {\n    observer.disconnect()\n\n    for (let node of hiddenNodes) {\n      let count = refCountMap.get(node)\n      if (count === 1) {\n        node.removeAttribute(\"aria-hidden\")\n        refCountMap.delete(node)\n      } else {\n        refCountMap.set(node, count! - 1)\n      }\n    }\n\n    // Remove this observer from the stack, and start the previous one.\n    if (observerWrapper === observerStack[observerStack.length - 1]) {\n      observerStack.pop()\n      if (observerStack.length) {\n        observerStack[observerStack.length - 1].observe()\n      }\n    } else {\n      observerStack.splice(observerStack.indexOf(observerWrapper), 1)\n    }\n  }\n}\n\nexport function ariaHidden(targetsOrFn: TargetsOrFn, options: AriaHiddenOptions = {}) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const targets = typeof targetsOrFn === \"function\" ? targetsOrFn() : targetsOrFn\n      cleanups.push(ariaHiddenImpl(targets, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}