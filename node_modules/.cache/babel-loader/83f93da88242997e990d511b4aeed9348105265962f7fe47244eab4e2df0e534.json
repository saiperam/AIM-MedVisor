{"ast":null,"code":"// src/add-dom-event.ts\nvar addDomEvent = (target, eventName, handler, options) => {\n  const node = typeof target === \"function\" ? target() : target;\n  node?.addEventListener(eventName, handler, options);\n  return () => {\n    node?.removeEventListener(eventName, handler, options);\n  };\n};\n\n// src/assertion.ts\nimport { isMac } from \"@zag-js/dom-query\";\nfunction isKeyboardClick(e) {\n  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;\n}\nfunction isPrintableKey(e) {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;\n}\nfunction isVirtualPointerEvent(e) {\n  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\";\n}\nfunction isVirtualClick(e) {\n  if (e.mozInputSource === 0 && e.isTrusted) return true;\n  return e.detail === 0 && !e.pointerType;\n}\nvar isLeftClick = e => e.button === 0;\nvar isContextMenuEvent = e => {\n  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;\n};\nvar isModifierKey = e => e.ctrlKey || e.altKey || e.metaKey;\n\n// src/click-link.ts\nimport { isFirefox } from \"@zag-js/dom-query\";\n\n// src/queue-before-event.ts\nfunction queueBeforeEvent(element, type, cb) {\n  const createTimer = callback => {\n    const timerId = requestAnimationFrame(callback);\n    return () => cancelAnimationFrame(timerId);\n  };\n  const cancelTimer = createTimer(() => {\n    element.removeEventListener(type, callSync, true);\n    cb();\n  });\n  const callSync = () => {\n    cancelTimer();\n    cb();\n  };\n  element.addEventListener(type, callSync, {\n    once: true,\n    capture: true\n  });\n  return cancelTimer;\n}\n\n// src/click-link.ts\nfunction isLinkElement(element) {\n  return element?.matches(\"a[href]\") ?? false;\n}\nfunction clickIfLink(element) {\n  if (!isLinkElement(element)) return;\n  const click = () => element.click();\n  if (isFirefox()) {\n    queueBeforeEvent(element, \"keyup\", click);\n  } else {\n    queueMicrotask(click);\n  }\n}\n\n// src/fire-event.ts\nfunction fireCustomEvent(el, type, init) {\n  if (!el) return;\n  const win = el.ownerDocument.defaultView || window;\n  const event = new win.CustomEvent(type, init);\n  return el.dispatchEvent(event);\n}\nfunction fireBlurEvent(el, init) {\n  const win = el.ownerDocument.defaultView || window;\n  const event = new win.FocusEvent(\"blur\", init);\n  const allowed = el.dispatchEvent(event);\n  const bubbleInit = {\n    ...init,\n    bubbles: true\n  };\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit));\n  return allowed;\n}\n\n// src/get-event-key.ts\nvar keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\"\n};\nvar rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\"\n};\nfunction getEventKey(event) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    dir = \"ltr\",\n    orientation = \"horizontal\"\n  } = options;\n  let {\n    key\n  } = event;\n  key = keyMap[key] ?? key;\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\";\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key];\n  }\n  return key;\n}\n\n// src/get-event-point.ts\nfunction pointFromTouch(e) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"client\";\n  const point = e.touches[0] || e.changedTouches[0];\n  return {\n    x: point[`${type}X`],\n    y: point[`${type}Y`]\n  };\n}\nfunction pointFromMouse(point) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"client\";\n  return {\n    x: point[`${type}X`],\n    y: point[`${type}Y`]\n  };\n}\nvar isTouchEvent = event => \"touches\" in event && event.touches.length > 0;\nfunction getEventPoint(event) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"client\";\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);\n}\n\n// src/get-event-step.ts\nvar PAGE_KEYS = /* @__PURE__ */new Set([\"PageUp\", \"PageDown\"]);\nvar ARROW_KEYS = /* @__PURE__ */new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"]);\nfunction getEventStep(event) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1;\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key);\n    const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.has(event.key);\n    return isSkipKey ? 10 : 1;\n  }\n}\n\n// src/get-native-event.ts\nfunction getNativeEvent(event) {\n  return event.nativeEvent ?? event;\n}\n\n// src/get-point-value.ts\nfunction clamp(value) {\n  return Math.max(0, Math.min(1, value));\n}\nfunction getRelativePoint(point, element) {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = element.getBoundingClientRect();\n  const offset = {\n    x: point.x - left,\n    y: point.y - top\n  };\n  const percent = {\n    x: clamp(offset.x / width),\n    y: clamp(offset.y / height)\n  };\n  function getPercentValue() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      dir = \"ltr\",\n      orientation = \"horizontal\",\n      inverted\n    } = options;\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted;\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted;\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x;\n    }\n    return invertY ? 1 - percent.y : percent.y;\n  }\n  return {\n    offset,\n    percent,\n    getPercentValue\n  };\n}\n\n// src/request-pointer-lock.ts\nfunction requestPointerLock(doc, fn) {\n  const body = doc.body;\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc;\n  const isLocked = () => !!doc.pointerLockElement;\n  function onPointerChange() {\n    fn?.(isLocked());\n  }\n  function onPointerError(event) {\n    if (isLocked()) fn?.(false);\n    console.error(\"PointerLock error occured:\", event);\n    doc.exitPointerLock();\n  }\n  if (!supported) return;\n  try {\n    body.requestPointerLock();\n  } catch {}\n  const cleanup = [addDomEvent(doc, \"pointerlockchange\", onPointerChange, false), addDomEvent(doc, \"pointerlockerror\", onPointerError, false)];\n  return () => {\n    cleanup.forEach(cleanup2 => cleanup2());\n    doc.exitPointerLock();\n  };\n}\n\n// src/track-focus-visible.ts\nimport { getWindow, isMac as isMac2 } from \"@zag-js/dom-query\";\n\n// src/pipe.ts\nvar pipe = function () {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return arg => fns.reduce((acc, fn) => fn(acc), arg);\n};\nvar noop = () => void 0;\n\n// src/track-focus-visible.ts\nvar isValidKey = e => {\n  return !(e.metaKey || !isMac2() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n};\nfunction trackFocusVisible(node, options) {\n  if (!node) return;\n  const {\n    onFocus,\n    onBlur\n  } = options;\n  const win = getWindow(node);\n  let focused = false;\n  const handleFocus = e => {\n    let isFocusVisible = false;\n    try {\n      isFocusVisible = node.matches(\":focus-visible\");\n    } catch {\n      isFocusVisible = true;\n    }\n    if (!isFocusVisible) return;\n    focused = true;\n    onFocus?.(e);\n  };\n  const handleBlur = e => {\n    if (!focused) return;\n    focused = false;\n    onBlur?.(e);\n  };\n  const handleKeydown = e => {\n    if (!node.matches(\":focus\") || !isValidKey(e)) return;\n    focused = true;\n    const evt = new win.FocusEvent(\"focus\");\n    onFocus?.(evt);\n  };\n  return pipe(addDomEvent(node, \"focusin\", handleFocus), addDomEvent(node, \"focusout\", handleBlur), addDomEvent(node, \"keydown\", handleKeydown, true));\n}\n\n// src/track-pointer-move.ts\nimport { disableTextSelection } from \"@zag-js/text-selection\";\nfunction trackPointerMove(doc, handlers) {\n  const {\n    onPointerMove,\n    onPointerUp\n  } = handlers;\n  const history = [];\n  const handleMove = event => {\n    const point = getEventPoint(event);\n    history.push({\n      ...point,\n      timestamp: performance.now()\n    });\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5;\n    if (distance < moveBuffer) return;\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp();\n      return;\n    }\n    onPointerMove({\n      point,\n      event,\n      velocity: getVelocity(history, 0.1)\n    });\n  };\n  const cleanups = [addDomEvent(doc, \"pointermove\", handleMove, false), addDomEvent(doc, \"pointerup\", onPointerUp, false), addDomEvent(doc, \"pointercancel\", onPointerUp, false), addDomEvent(doc, \"contextmenu\", onPointerUp, false), disableTextSelection({\n    doc\n  })];\n  return () => {\n    cleanups.forEach(cleanup => cleanup());\n    history.length = 0;\n  };\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction ms(seconds) {\n  return seconds * 1e3;\n}\nfunction sec(milliseconds) {\n  return milliseconds / 1e3;\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) return {\n    x: 0,\n    y: 0\n  };\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) return {\n    x: 0,\n    y: 0\n  };\n  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp);\n  if (time === 0) return {\n    x: 0,\n    y: 0\n  };\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0;\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0;\n  return {\n    x: Math.abs(currentVelocity.x),\n    y: Math.abs(currentVelocity.y)\n  };\n}\n\n// src/track-press.ts\nimport { contains, getDocument, getEventTarget, getWindow as getWindow2 } from \"@zag-js/dom-query\";\nfunction trackPress(options) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey: isValidKey2 = e => e.key === \"Enter\"\n  } = options;\n  if (!pointerNode) return noop;\n  const win = getWindow2(pointerNode);\n  const doc = getDocument(pointerNode);\n  let removeStartListeners = noop;\n  let removeEndListeners = noop;\n  let removeAccessibleListeners = noop;\n  const getInfo = event => ({\n    point: getEventPoint(event),\n    event\n  });\n  function startPress(event) {\n    onPressStart?.(getInfo(event));\n  }\n  function cancelPress(event) {\n    onPressEnd?.(getInfo(event));\n  }\n  const startPointerPress = startEvent => {\n    removeEndListeners();\n    const endPointerPress = endEvent => {\n      const target = getEventTarget(endEvent);\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent));\n      } else {\n        onPressEnd?.(getInfo(endEvent));\n      }\n    };\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, {\n      passive: !onPress\n    });\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, {\n      passive: !onPressEnd\n    });\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);\n    if (doc.activeElement === keyboardNode && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault();\n    }\n    startPress(startEvent);\n  };\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, {\n    passive: !onPressStart\n  });\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress);\n  removeStartListeners = pipe(removePointerListener, removeFocusListener);\n  function startAccessiblePress() {\n    const handleKeydown = keydownEvent => {\n      if (!isValidKey2(keydownEvent)) return;\n      const handleKeyup = keyupEvent => {\n        if (!isValidKey2(keyupEvent)) return;\n        const evt2 = new win.PointerEvent(\"pointerup\");\n        const info = getInfo(evt2);\n        onPress?.(info);\n        onPressEnd?.(info);\n      };\n      removeEndListeners();\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup);\n      const evt = new win.PointerEvent(\"pointerdown\");\n      startPress(evt);\n    };\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\");\n      cancelPress(evt);\n    };\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown);\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur);\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);\n  }\n  return function () {\n    removeStartListeners();\n    removeEndListeners();\n    removeAccessibleListeners();\n  };\n}\n\n// src/track-visual-viewport.ts\nfunction trackVisualViewport(doc, fn) {\n  const win = doc?.defaultView || window;\n  const onResize = () => {\n    fn?.(getViewportSize(win));\n  };\n  onResize();\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize);\n}\nfunction getViewportSize(win) {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight\n  };\n}\nexport { addDomEvent, clickIfLink, fireBlurEvent, fireCustomEvent, getEventKey, getEventPoint, getEventStep, getNativeEvent, getRelativePoint, isContextMenuEvent, isKeyboardClick, isLeftClick, isModifierKey, isPrintableKey, isVirtualClick, isVirtualPointerEvent, queueBeforeEvent, requestPointerLock, trackFocusVisible, trackPointerMove, trackPress, trackVisualViewport };","map":{"version":3,"names":["addDomEvent","target","eventName","handler","options","node","addEventListener","removeEventListener","isMac","isKeyboardClick","e","detail","clientX","clientY","isPrintableKey","key","length","ctrlKey","metaKey","isVirtualPointerEvent","width","height","pressure","pointerType","isVirtualClick","mozInputSource","isTrusted","isLeftClick","button","isContextMenuEvent","isModifierKey","altKey","isFirefox","queueBeforeEvent","element","type","cb","createTimer","callback","timerId","requestAnimationFrame","cancelAnimationFrame","cancelTimer","callSync","once","capture","isLinkElement","matches","clickIfLink","click","queueMicrotask","fireCustomEvent","el","init","win","ownerDocument","defaultView","window","event","CustomEvent","dispatchEvent","fireBlurEvent","FocusEvent","allowed","bubbleInit","bubbles","keyMap","Up","Down","Esc","Left","Right","rtlKeyMap","ArrowLeft","ArrowRight","getEventKey","arguments","undefined","dir","orientation","isRtl","pointFromTouch","point","touches","changedTouches","x","y","pointFromMouse","isTouchEvent","getEventPoint","PAGE_KEYS","Set","ARROW_KEYS","getEventStep","isPageKey","has","isSkipKey","shiftKey","getNativeEvent","nativeEvent","clamp","value","Math","max","min","getRelativePoint","left","top","getBoundingClientRect","offset","percent","getPercentValue","inverted","invertX","invertY","requestPointerLock","doc","fn","body","supported","isLocked","pointerLockElement","onPointerChange","onPointerError","console","error","exitPointerLock","cleanup","forEach","cleanup2","getWindow","isMac2","pipe","_len","fns","Array","_key","arg","reduce","acc","noop","isValidKey","trackFocusVisible","onFocus","onBlur","focused","handleFocus","isFocusVisible","handleBlur","handleKeydown","evt","disableTextSelection","trackPointerMove","handlers","onPointerMove","onPointerUp","history","handleMove","push","timestamp","performance","now","distance","sqrt","moveBuffer","velocity","getVelocity","cleanups","lastDevicePoint","ms","seconds","sec","milliseconds","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity","abs","contains","getDocument","getEventTarget","getWindow2","trackPress","pointerNode","keyboardNode","onPress","onPressStart","onPressEnd","isValidKey2","removeStartListeners","removeEndListeners","removeAccessibleListeners","getInfo","startPress","cancelPress","startPointerPress","startEvent","endPointerPress","endEvent","removePointerUpListener","passive","removePointerCancelListener","activeElement","preventDefault","removePointerListener","removeFocusListener","startAccessiblePress","keydownEvent","handleKeyup","keyupEvent","evt2","PointerEvent","info","removeKeydownListener","removeBlurListener","trackVisualViewport","onResize","getViewportSize","visualViewport","innerWidth","innerHeight"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/add-dom-event.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/assertion.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/click-link.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/queue-before-event.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/fire-event.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/get-event-key.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/get-event-point.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/get-event-step.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/get-native-event.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/get-point-value.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/request-pointer-lock.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/track-focus-visible.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/pipe.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/track-pointer-move.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/track-press.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/dom-event/src/track-visual-viewport.ts"],"sourcesContent":["interface EventMap extends DocumentEventMap, WindowEventMap, HTMLElementEventMap {}\n\ntype Node = Document | HTMLElement | EventTarget | null\n\ntype Target = (() => Node) | Node\n\nexport const addDomEvent = <K extends keyof EventMap>(\n  target: Target,\n  eventName: K,\n  handler: (event: EventMap[K]) => void,\n  options?: boolean | AddEventListenerOptions,\n) => {\n  const node = typeof target === \"function\" ? target() : target\n  node?.addEventListener(eventName, handler as any, options)\n  return () => {\n    node?.removeEventListener(eventName, handler as any, options)\n  }\n}\n","import { isMac } from \"@zag-js/dom-query\"\n\nexport function isKeyboardClick(e: Pick<MouseEvent, \"detail\" | \"clientX\" | \"clientY\">) {\n  return e.detail === 0 || (e.clientX === 0 && e.clientY === 0)\n}\n\nexport function isPrintableKey(e: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">): boolean {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey\n}\n\nexport function isVirtualPointerEvent(e: PointerEvent) {\n  return (\n    (e.width === 0 && e.height === 0) ||\n    (e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\")\n  )\n}\n\nexport function isVirtualClick(e: MouseEvent | PointerEvent): boolean {\n  if ((e as any).mozInputSource === 0 && e.isTrusted) return true\n  return e.detail === 0 && !(e as PointerEvent).pointerType\n}\n\nexport const isLeftClick = (e: Pick<MouseEvent, \"button\">) => e.button === 0\n\nexport const isContextMenuEvent = (e: Pick<MouseEvent, \"button\" | \"ctrlKey\" | \"metaKey\">) => {\n  return e.button === 2 || (isMac() && e.ctrlKey && e.button === 0)\n}\n\nexport const isModifierKey = (e: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"altKey\">) =>\n  e.ctrlKey || e.altKey || e.metaKey\n","import { isFirefox } from \"@zag-js/dom-query\"\nimport { queueBeforeEvent } from \"./queue-before-event\"\n\nfunction isLinkElement(element: HTMLElement | null | undefined) {\n  return element?.matches(\"a[href]\") ?? false\n}\n\nexport function clickIfLink(element: HTMLElement | null | undefined) {\n  if (!isLinkElement(element)) return\n  const click = () => element!.click()\n  if (isFirefox()) {\n    queueBeforeEvent(element!, \"keyup\", click)\n  } else {\n    queueMicrotask(click)\n  }\n}\n","export function queueBeforeEvent(element: EventTarget, type: string, cb: () => void) {\n  const createTimer = (callback: () => void) => {\n    const timerId = requestAnimationFrame(callback)\n    return () => cancelAnimationFrame(timerId)\n  }\n\n  const cancelTimer = createTimer(() => {\n    element.removeEventListener(type, callSync, true)\n    cb()\n  })\n  const callSync = () => {\n    cancelTimer()\n    cb()\n  }\n\n  element.addEventListener(type, callSync, { once: true, capture: true })\n  return cancelTimer\n}\n","export function fireCustomEvent(el: HTMLElement | null, type: string, init?: CustomEventInit) {\n  if (!el) return\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.CustomEvent(type, init)\n  return el.dispatchEvent(event)\n}\n\nexport function fireBlurEvent(el: HTMLElement, init?: FocusEventInit) {\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.FocusEvent(\"blur\", init)\n  const allowed = el.dispatchEvent(event)\n  const bubbleInit = { ...init, bubbles: true }\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit))\n  return allowed\n}\n","import type { EventKeyOptions } from \"./types\"\n\nconst keyMap: Record<string, string> = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\",\n}\n\nconst rtlKeyMap: Record<string, string> = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\",\n}\n\n/**\n * Determine the event key based on text direction.\n */\nexport function getEventKey(event: Pick<KeyboardEvent, \"key\">, options: EventKeyOptions = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options\n\n  let { key } = event\n  key = keyMap[key] ?? key // normalize key\n\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\"\n\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key]\n  }\n\n  return key\n}\n","type PointType = \"page\" | \"client\"\n\nfunction pointFromTouch(e: TouchEvent, type: PointType = \"client\") {\n  const point = e.touches[0] || e.changedTouches[0]\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\nfunction pointFromMouse(point: MouseEvent | PointerEvent, type: PointType = \"client\") {\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\ntype AnyPointerEvent = MouseEvent | TouchEvent | PointerEvent\n\nconst isTouchEvent = (event: AnyPointerEvent): event is TouchEvent => \"touches\" in event && event.touches.length > 0\n\nexport function getEventPoint(event: any, type: PointType = \"client\") {\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type)\n}\n","const PAGE_KEYS = new Set([\"PageUp\", \"PageDown\"])\nconst ARROW_KEYS = new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"])\n\n/**\n * Determine the step factor for keyboard events\n */\nexport function getEventStep(event: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"key\" | \"shiftKey\">) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key)\n    const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.has(event.key))\n    return isSkipKey ? 10 : 1\n  }\n}\n","import type { JSX } from \"@zag-js/types\"\n\ntype NativeEvent<E> =\n  JSX.ChangeEvent<any> extends E ? InputEvent : E extends JSX.SyntheticEvent<any, infer T> ? T : never\n\nexport function getNativeEvent<E>(event: E): NativeEvent<E> {\n  return (event as any).nativeEvent ?? event\n}\n","function clamp(value: number) {\n  return Math.max(0, Math.min(1, value))\n}\n\nexport type Point = {\n  x: number\n  y: number\n}\n\ntype PercentValueOptions = {\n  inverted?: boolean | { x?: boolean; y?: boolean }\n  dir?: \"ltr\" | \"rtl\"\n  orientation?: \"vertical\" | \"horizontal\"\n}\n\nexport function getRelativePoint(point: Point, element: HTMLElement) {\n  const { left, top, width, height } = element.getBoundingClientRect()\n\n  const offset = { x: point.x - left, y: point.y - top }\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) }\n\n  function getPercentValue(options: PercentValueOptions = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options\n\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted\n\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x\n    }\n\n    return invertY ? 1 - percent.y : percent.y\n  }\n\n  return { offset, percent, getPercentValue }\n}\n","import { addDomEvent } from \"./add-dom-event\"\n\nexport function requestPointerLock(doc: Document, fn?: (locked: boolean) => void) {\n  const body = doc.body\n\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc\n  const isLocked = () => !!doc.pointerLockElement\n\n  function onPointerChange() {\n    fn?.(isLocked())\n  }\n\n  function onPointerError(event: Event) {\n    if (isLocked()) fn?.(false)\n    console.error(\"PointerLock error occured:\", event)\n    doc.exitPointerLock()\n  }\n\n  if (!supported) return\n\n  try {\n    body.requestPointerLock()\n  } catch {}\n\n  // prettier-ignore\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ]\n\n  return () => {\n    cleanup.forEach((cleanup) => cleanup())\n    doc.exitPointerLock()\n  }\n}\n","import { getWindow, isMac } from \"@zag-js/dom-query\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { pipe } from \"./pipe\"\n\nexport interface TrackFocusOptions {\n  /**\n   * Callback to be called when the element receives focus and is focus-visible.\n   */\n  onFocus?(e: FocusEvent): void\n  /**\n   * Callback to be called when the element loses focus.\n   */\n  onBlur?(e: FocusEvent): void\n}\n\nconst isValidKey = (e: KeyboardEvent) => {\n  return !(\n    e.metaKey ||\n    (!isMac() && e.altKey) ||\n    e.ctrlKey ||\n    e.key === \"Control\" ||\n    e.key === \"Shift\" ||\n    e.key === \"Meta\"\n  )\n}\n\nexport function trackFocusVisible(node: Element | null, options: TrackFocusOptions) {\n  if (!node) return\n  const { onFocus, onBlur } = options\n\n  const win = getWindow(node)\n\n  let focused = false\n\n  const handleFocus = (e: FocusEvent) => {\n    let isFocusVisible = false\n\n    try {\n      isFocusVisible = node.matches(\":focus-visible\")\n    } catch {\n      isFocusVisible = true\n    }\n\n    if (!isFocusVisible) return\n\n    focused = true\n    onFocus?.(e)\n  }\n\n  const handleBlur = (e: FocusEvent) => {\n    if (!focused) return\n    focused = false\n    onBlur?.(e)\n  }\n\n  const handleKeydown = (e: KeyboardEvent) => {\n    if (!node.matches(\":focus\") || !isValidKey(e)) return\n    focused = true\n    const evt = new win.FocusEvent(\"focus\")\n    onFocus?.(evt)\n  }\n\n  return pipe(\n    addDomEvent(node, \"focusin\", handleFocus),\n    addDomEvent(node, \"focusout\", handleBlur),\n    addDomEvent(node, \"keydown\", handleKeydown, true),\n  )\n}\n","export const pipe =\n  <T>(...fns: Array<(arg: T) => T>) =>\n  (arg: T) =>\n    fns.reduce((acc, fn) => fn(acc), arg)\n\nexport const noop = () => void 0\n","import { disableTextSelection } from \"@zag-js/text-selection\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface TimestampedPoint extends Point {\n  /**\n   * The time when the point was recorded.\n   */\n  timestamp: number\n}\n\nexport interface PointerMoveDetails {\n  /**\n   * The current position of the pointer.\n   */\n  point: Point\n  /**\n   * The event that triggered the move.\n   */\n  event: PointerEvent\n  /**\n   * The velocity of the pointer on the x and y axis.\n   */\n  velocity: Point\n}\n\nexport interface PointerMoveHandlers {\n  /**\n   * Called when the pointer is released.\n   */\n  onPointerUp: VoidFunction\n  /**\n   * Called when the pointer moves.\n   */\n  onPointerMove: (details: PointerMoveDetails) => void\n}\n\nexport function trackPointerMove(doc: Document, handlers: PointerMoveHandlers) {\n  const { onPointerMove, onPointerUp } = handlers\n\n  const history: TimestampedPoint[] = []\n\n  const handleMove = (event: PointerEvent) => {\n    const point = getEventPoint(event)\n    history.push({ ...point, timestamp: performance.now() })\n\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2)\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5\n\n    if (distance < moveBuffer) return\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp()\n      return\n    }\n\n    onPointerMove({ point, event, velocity: getVelocity(history, 0.1) })\n  }\n\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", onPointerUp, false),\n    addDomEvent(doc, \"pointercancel\", onPointerUp, false),\n    addDomEvent(doc, \"contextmenu\", onPointerUp, false),\n    disableTextSelection({ doc }),\n  ]\n\n  return () => {\n    cleanups.forEach((cleanup) => cleanup())\n    history.length = 0\n  }\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n  return history[history.length - 1]\n}\n\nfunction ms(seconds: number): number {\n  return seconds * 1000\n}\n\nfunction sec(milliseconds: number): number {\n  return milliseconds / 1000\n}\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) return { x: 0, y: 0 }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = lastDevicePoint(history)\n\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) return { x: 0, y: 0 }\n\n  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp)\n  if (time === 0) return { x: 0, y: 0 }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0\n\n  return {\n    x: Math.abs(currentVelocity.x),\n    y: Math.abs(currentVelocity.y),\n  }\n}\n","import { contains, getDocument, getEventTarget, getWindow } from \"@zag-js/dom-query\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\nimport { noop, pipe } from \"./pipe\"\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface TapDetails {\n  /**\n   * The current position of the pointer.\n   */\n  point: Point\n  /**\n   * The event that triggered the move.\n   */\n  event: PointerEvent\n}\n\nexport interface TrackPressOptions {\n  /**\n   * The element that will be used to track the pointer events.\n   */\n  pointerNode: Element | null\n  /**\n   * The element that will be used to track the keyboard focus events.\n   */\n  keyboardNode?: Element | null\n  /**\n   * A function that determines if the key is valid for the press event.\n   */\n  isValidKey?(event: KeyboardEvent): boolean\n  /**\n   * A function that will be called when the pointer is pressed.\n   */\n  onPress?(details: TapDetails): void\n  /**\n   * A function that will be called when the pointer is pressed down.\n   */\n  onPressStart?(details: TapDetails): void\n  /**\n   * A function that will be called when the pointer is pressed up or cancelled.\n   */\n  onPressEnd?(details: TapDetails): void\n}\n\nexport function trackPress(options: TrackPressOptions) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey = (e) => e.key === \"Enter\",\n  } = options\n\n  if (!pointerNode) return noop\n\n  const win = getWindow(pointerNode)\n  const doc = getDocument(pointerNode)\n\n  let removeStartListeners: VoidFunction = noop\n  let removeEndListeners: VoidFunction = noop\n  let removeAccessibleListeners: VoidFunction = noop\n\n  const getInfo = (event: PointerEvent): TapDetails => ({\n    point: getEventPoint(event),\n    event,\n  })\n\n  function startPress(event: PointerEvent) {\n    onPressStart?.(getInfo(event))\n  }\n\n  function cancelPress(event: PointerEvent) {\n    onPressEnd?.(getInfo(event))\n  }\n\n  const startPointerPress = (startEvent: PointerEvent) => {\n    removeEndListeners()\n\n    const endPointerPress = (endEvent: PointerEvent) => {\n      const target = getEventTarget<Element>(endEvent)\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent))\n      } else {\n        onPressEnd?.(getInfo(endEvent))\n      }\n    }\n\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, { passive: !onPress })\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, { passive: !onPressEnd })\n\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener)\n\n    if (doc.activeElement === keyboardNode && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault()\n    }\n\n    startPress(startEvent)\n  }\n\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, { passive: !onPressStart })\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress)\n\n  removeStartListeners = pipe(removePointerListener, removeFocusListener)\n\n  function startAccessiblePress() {\n    const handleKeydown = (keydownEvent: KeyboardEvent) => {\n      if (!isValidKey(keydownEvent)) return\n\n      const handleKeyup = (keyupEvent: KeyboardEvent) => {\n        if (!isValidKey(keyupEvent)) return\n        const evt = new win.PointerEvent(\"pointerup\")\n        const info = getInfo(evt)\n        onPress?.(info)\n        onPressEnd?.(info)\n      }\n\n      removeEndListeners()\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup)\n\n      const evt = new win.PointerEvent(\"pointerdown\")\n      startPress(evt)\n    }\n\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\")\n      cancelPress(evt)\n    }\n\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown)\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur)\n\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener)\n  }\n\n  return function () {\n    removeStartListeners()\n    removeEndListeners()\n    removeAccessibleListeners()\n  }\n}\n","import { addDomEvent } from \"./add-dom-event\"\n\nexport interface ViewportSize {\n  width: number\n  height: number\n}\n\nexport function trackVisualViewport(doc: Document, fn: (data: ViewportSize) => void) {\n  const win = doc?.defaultView || window\n\n  const onResize = () => {\n    fn?.(getViewportSize(win))\n  }\n\n  onResize()\n\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize)\n}\n\nfunction getViewportSize(win: Window): ViewportSize {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}