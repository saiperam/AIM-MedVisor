{"ast":null,"code":"// src/color-picker.anatomy.ts\nimport { createAnatomy } from \"@zag-js/anatomy\";\nvar anatomy = createAnatomy(\"color-picker\", [\"root\", \"label\", \"control\", \"trigger\", \"positioner\", \"content\", \"area\", \"areaThumb\", \"valueText\", \"areaBackground\", \"channelSlider\", \"channelSliderLabel\", \"channelSliderTrack\", \"channelSliderThumb\", \"channelSliderValueText\", \"channelInput\", \"transparencyGrid\", \"swatchGroup\", \"swatchTrigger\", \"swatchIndicator\", \"swatch\", \"eyeDropperTrigger\", \"formatTrigger\", \"formatSelect\"]);\nvar parts = anatomy.build();\n\n// src/color-picker.connect.ts\nimport { getColorAreaGradient, normalizeColor } from \"@zag-js/color-utils\";\nimport { getEventKey, getEventPoint, getEventStep, isLeftClick, isModifierKey } from \"@zag-js/dom-event\";\nimport { dataAttr, query, visuallyHiddenStyle } from \"@zag-js/dom-query\";\nimport { getPlacementStyles } from \"@zag-js/popper\";\n\n// src/color-picker.dom.ts\nimport { getRelativePoint } from \"@zag-js/dom-event\";\nimport { createScope, queryAll } from \"@zag-js/dom-query\";\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `color-picker:${ctx.id}`,\n  getLabelId: ctx => ctx.ids?.label ?? `color-picker:${ctx.id}:label`,\n  getHiddenInputId: ctx => ctx.ids?.hiddenInput ?? `color-picker:${ctx.id}:hidden-input`,\n  getControlId: ctx => ctx.ids?.control ?? `color-picker:${ctx.id}:control`,\n  getTriggerId: ctx => ctx.ids?.trigger ?? `color-picker:${ctx.id}:trigger`,\n  getContentId: ctx => ctx.ids?.content ?? `color-picker:${ctx.id}:content`,\n  getPositionerId: ctx => ctx.ids?.positioner ?? `color-picker:${ctx.id}:positioner`,\n  getFormatSelectId: ctx => ctx.ids?.formatSelect ?? `color-picker:${ctx.id}:format-select`,\n  getAreaId: ctx => ctx.ids?.area ?? `color-picker:${ctx.id}:area`,\n  getAreaGradientId: ctx => ctx.ids?.areaGradient ?? `color-picker:${ctx.id}:area-gradient`,\n  getAreaThumbId: ctx => ctx.ids?.areaThumb ?? `color-picker:${ctx.id}:area-thumb`,\n  getChannelSliderTrackId: (ctx, channel) => ctx.ids?.channelSliderTrack?.(channel) ?? `color-picker:${ctx.id}:slider-track:${channel}`,\n  getChannelSliderThumbId: (ctx, channel) => ctx.ids?.channelSliderThumb?.(channel) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`,\n  getContentEl: ctx => dom.getById(ctx, dom.getContentId(ctx)),\n  getAreaThumbEl: ctx => dom.getById(ctx, dom.getAreaThumbId(ctx)),\n  getChannelSliderThumbEl: (ctx, channel) => dom.getById(ctx, dom.getChannelSliderThumbId(ctx, channel)),\n  getChannelInputEl: (ctx, channel) => {\n    const selector = `input[data-channel=\"${channel}\"]`;\n    return [...queryAll(dom.getContentEl(ctx), selector), ...queryAll(dom.getControlEl(ctx), selector)];\n  },\n  getFormatSelectEl: ctx => dom.getById(ctx, dom.getFormatSelectId(ctx)),\n  getHiddenInputEl: ctx => dom.getById(ctx, dom.getHiddenInputId(ctx)),\n  getAreaEl: ctx => dom.getById(ctx, dom.getAreaId(ctx)),\n  getAreaValueFromPoint(ctx, point) {\n    const areaEl = dom.getAreaEl(ctx);\n    if (!areaEl) return;\n    const {\n      percent\n    } = getRelativePoint(point, areaEl);\n    return percent;\n  },\n  getControlEl: ctx => dom.getById(ctx, dom.getControlId(ctx)),\n  getTriggerEl: ctx => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getPositionerEl: ctx => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getChannelSliderTrackEl: (ctx, channel) => {\n    return dom.getById(ctx, dom.getChannelSliderTrackId(ctx, channel));\n  },\n  getChannelSliderValueFromPoint(ctx, point, channel) {\n    const trackEl = dom.getChannelSliderTrackEl(ctx, channel);\n    if (!trackEl) return;\n    const {\n      percent\n    } = getRelativePoint(point, trackEl);\n    return percent;\n  },\n  getChannelInputEls: ctx => {\n    return [...queryAll(dom.getContentEl(ctx), \"input[data-channel]\"), ...queryAll(dom.getControlEl(ctx), \"input[data-channel]\")];\n  }\n});\n\n// src/utils/get-channel-display-color.ts\nimport { parseColor } from \"@zag-js/color-utils\";\nfunction getChannelDisplayColor(color, channel) {\n  switch (channel) {\n    case \"hue\":\n      return parseColor(`hsl(${color.getChannelValue(\"hue\")}, 100%, 50%)`);\n    case \"lightness\":\n    case \"brightness\":\n    case \"saturation\":\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.withChannelValue(\"alpha\", 1);\n    case \"alpha\":\n      {\n        return color;\n      }\n    default:\n      throw new Error(\"Unknown color channel: \" + channel);\n  }\n}\n\n// src/utils/get-channel-input-value.ts\nimport { parseColor as parseColor2 } from \"@zag-js/color-utils\";\nfunction getChannelValue(color, channel) {\n  if (channel == null) return \"\";\n  if (channel === \"hex\") {\n    return color.toString(\"hex\");\n  }\n  if (channel === \"css\") {\n    return color.toString(\"css\");\n  }\n  if (channel in color) {\n    return color.getChannelValue(channel).toString();\n  }\n  const isHSL = color.getFormat() === \"hsla\";\n  switch (channel) {\n    case \"hue\":\n      return isHSL ? color.toFormat(\"hsla\").getChannelValue(\"hue\").toString() : color.toFormat(\"hsba\").getChannelValue(\"hue\").toString();\n    case \"saturation\":\n      return isHSL ? color.toFormat(\"hsla\").getChannelValue(\"saturation\").toString() : color.toFormat(\"hsba\").getChannelValue(\"saturation\").toString();\n    case \"lightness\":\n      return color.toFormat(\"hsla\").getChannelValue(\"lightness\").toString();\n    case \"brightness\":\n      return color.toFormat(\"hsba\").getChannelValue(\"brightness\").toString();\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.toFormat(\"rgba\").getChannelValue(channel).toString();\n    default:\n      return color.getChannelValue(channel).toString();\n  }\n}\nfunction getChannelRange(color, channel) {\n  switch (channel) {\n    case \"hex\":\n      const minColor = parseColor2(\"#000000\");\n      const maxColor = parseColor2(\"#FFFFFF\");\n      return {\n        minValue: minColor.toHexInt(),\n        maxValue: maxColor.toHexInt(),\n        pageSize: 10,\n        step: 1\n      };\n    case \"css\":\n      return void 0;\n    case \"hue\":\n    case \"saturation\":\n    case \"lightness\":\n      return color.toFormat(\"hsla\").getChannelRange(channel);\n    case \"brightness\":\n      return color.toFormat(\"hsba\").getChannelRange(channel);\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.toFormat(\"rgba\").getChannelRange(channel);\n    default:\n      return color.getChannelRange(channel);\n  }\n}\n\n// src/utils/get-slider-background.ts\nfunction getSliderBackgroundDirection(orientation, dir) {\n  if (orientation === \"vertical\") {\n    return \"top\";\n  } else if (dir === \"ltr\") {\n    return \"right\";\n  } else {\n    return \"left\";\n  }\n}\nvar getSliderBackground = props => {\n  const {\n    channel,\n    value,\n    dir\n  } = props;\n  const bgDirection = getSliderBackgroundDirection(props.orientation, dir);\n  const {\n    minValue,\n    maxValue\n  } = value.getChannelRange(channel);\n  switch (channel) {\n    case \"hue\":\n      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;\n    case \"lightness\":\n      {\n        let start = value.withChannelValue(channel, minValue).toString(\"css\");\n        let middle = value.withChannelValue(channel, (maxValue - minValue) / 2).toString(\"css\");\n        let end = value.withChannelValue(channel, maxValue).toString(\"css\");\n        return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;\n      }\n    case \"saturation\":\n    case \"brightness\":\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n    case \"alpha\":\n      {\n        let start = value.withChannelValue(channel, minValue).toString(\"css\");\n        let end = value.withChannelValue(channel, maxValue).toString(\"css\");\n        return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;\n      }\n    default:\n      throw new Error(\"Unknown color channel: \" + channel);\n  }\n};\n\n// src/color-picker.connect.ts\nfunction connect(state, send, normalize) {\n  const value = state.context.value;\n  const areaValue = state.context.areaValue;\n  const valueAsString = state.context.valueAsString;\n  const disabled = state.context.isDisabled;\n  const interactive = state.context.isInteractive;\n  const dragging = state.hasTag(\"dragging\");\n  const open = state.hasTag(\"open\");\n  const focused = state.hasTag(\"focused\");\n  const getAreaChannels = props => {\n    const channels = areaValue.getChannels();\n    return {\n      xChannel: props.xChannel ?? channels[1],\n      yChannel: props.yChannel ?? channels[2]\n    };\n  };\n  const currentPlacement = state.context.currentPlacement;\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: currentPlacement\n  });\n  function getSwatchTriggerState(props) {\n    const color = normalizeColor(props.value).toFormat(state.context.format);\n    return {\n      value: color,\n      valueAsString: color.toString(\"hex\"),\n      checked: color.isEqual(value),\n      disabled: props.disabled || !interactive\n    };\n  }\n  return {\n    dragging,\n    open,\n    valueAsString,\n    value,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: normalizeColor(value2),\n        src: \"set-color\"\n      });\n    },\n    getChannelValue(channel) {\n      return getChannelValue(value, channel);\n    },\n    getChannelValueText(channel, locale) {\n      return value.formatChannelValue(channel, locale);\n    },\n    setChannelValue(channel, channelValue) {\n      const color = value.withChannelValue(channel, channelValue);\n      send({\n        type: \"VALUE.SET\",\n        value: color,\n        src: \"set-channel\"\n      });\n    },\n    format: state.context.format,\n    setFormat(format) {\n      const formatValue = value.toFormat(format);\n      send({\n        type: \"VALUE.SET\",\n        value: formatValue,\n        src: \"set-format\"\n      });\n    },\n    alpha: value.getChannelValue(\"alpha\"),\n    setAlpha(alphaValue) {\n      const color = value.withChannelValue(\"alpha\", alphaValue);\n      send({\n        type: \"VALUE.SET\",\n        value: color,\n        src: \"set-alpha\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        style: {\n          \"--value\": value.toString(\"css\")\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        id: dom.getLabelId(state.context),\n        htmlFor: dom.getHiddenInputId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-focus\": dataAttr(focused),\n        onClick(event) {\n          event.preventDefault();\n          const inputEl = query(dom.getControlEl(state.context), \"[data-channel=hex]\");\n          inputEl?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        id: dom.getControlId(state.context),\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: dom.getTriggerId(state.context),\n        dir: state.context.dir,\n        disabled,\n        \"aria-label\": `select color. current color is ${valueAsString}`,\n        \"aria-controls\": dom.getContentId(state.context),\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-placement\": currentPlacement,\n        \"aria-expanded\": dataAttr(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused),\n        type: \"button\",\n        onClick() {\n          if (!interactive) return;\n          send({\n            type: \"TRIGGER.CLICK\"\n          });\n        },\n        onBlur() {\n          if (!interactive) return;\n          send({\n            type: \"TRIGGER.BLUR\"\n          });\n        },\n        style: {\n          position: \"relative\"\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        id: dom.getPositionerId(state.context),\n        dir: state.context.dir,\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: dom.getContentId(state.context),\n        dir: state.context.dir,\n        \"data-placement\": currentPlacement,\n        \"data-state\": open ? \"open\" : \"closed\",\n        hidden: !open\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getAreaProps(props = {}) {\n      const {\n        xChannel,\n        yChannel\n      } = getAreaChannels(props);\n      const {\n        areaStyles\n      } = getColorAreaGradient(areaValue, {\n        xChannel,\n        yChannel,\n        dir: state.context.dir\n      });\n      return normalize.element({\n        ...parts.area.attrs,\n        id: dom.getAreaId(state.context),\n        role: \"group\",\n        onPointerDown(event) {\n          if (!interactive) return;\n          if (!isLeftClick(event)) return;\n          if (isModifierKey(event)) return;\n          const point = getEventPoint(event);\n          const channel = {\n            xChannel,\n            yChannel\n          };\n          send({\n            type: \"AREA.POINTER_DOWN\",\n            point,\n            channel,\n            id: \"area\"\n          });\n          event.preventDefault();\n        },\n        style: {\n          position: \"relative\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          ...areaStyles\n        }\n      });\n    },\n    getAreaBackgroundProps(props = {}) {\n      const {\n        xChannel,\n        yChannel\n      } = getAreaChannels(props);\n      const {\n        areaGradientStyles\n      } = getColorAreaGradient(areaValue, {\n        xChannel,\n        yChannel,\n        dir: state.context.dir\n      });\n      return normalize.element({\n        ...parts.areaBackground.attrs,\n        id: dom.getAreaGradientId(state.context),\n        style: {\n          position: \"relative\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          ...areaGradientStyles\n        }\n      });\n    },\n    getAreaThumbProps(props = {}) {\n      const {\n        xChannel,\n        yChannel\n      } = getAreaChannels(props);\n      const channel = {\n        xChannel,\n        yChannel\n      };\n      const xPercent = areaValue.getChannelValuePercent(xChannel);\n      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);\n      const xValue = areaValue.getChannelValue(xChannel);\n      const yValue = areaValue.getChannelValue(yChannel);\n      return normalize.element({\n        ...parts.areaThumb.attrs,\n        id: dom.getAreaThumbId(state.context),\n        dir: state.context.dir,\n        tabIndex: disabled ? void 0 : 0,\n        \"data-disabled\": dataAttr(disabled),\n        role: \"slider\",\n        \"aria-valuemin\": 0,\n        \"aria-valuemax\": 100,\n        \"aria-valuenow\": xValue,\n        \"aria-label\": `${xChannel} and ${yChannel}`,\n        \"aria-roledescription\": \"2d slider\",\n        \"aria-valuetext\": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,\n        style: {\n          position: \"absolute\",\n          left: `${xPercent * 100}%`,\n          top: `${yPercent * 100}%`,\n          transform: \"translate(-50%, -50%)\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          background: areaValue.withChannelValue(\"alpha\", 1).toString(\"css\")\n        },\n        onFocus() {\n          if (!interactive) return;\n          send({\n            type: \"AREA.FOCUS\",\n            id: \"area\",\n            channel\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const step = getEventStep(event);\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"AREA.ARROW_UP\",\n                channel,\n                step\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"AREA.ARROW_DOWN\",\n                channel,\n                step\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"AREA.ARROW_LEFT\",\n                channel,\n                step\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"AREA.ARROW_RIGHT\",\n                channel,\n                step\n              });\n            },\n            PageUp() {\n              send({\n                type: \"AREA.PAGE_UP\",\n                channel,\n                step\n              });\n            },\n            PageDown() {\n              send({\n                type: \"AREA.PAGE_DOWN\",\n                channel,\n                step\n              });\n            },\n            Escape(event2) {\n              event2.stopPropagation();\n            }\n          };\n          const exec = keyMap[getEventKey(event, state.context)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getTransparencyGridProps(props = {}) {\n      const {\n        size = \"12px\"\n      } = props;\n      return normalize.element({\n        ...parts.transparencyGrid.attrs,\n        style: {\n          \"--size\": size,\n          width: \"100%\",\n          height: \"100%\",\n          position: \"absolute\",\n          backgroundColor: \"#fff\",\n          backgroundImage: \"conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)\",\n          backgroundSize: \"var(--size) var(--size)\",\n          inset: \"0px\",\n          zIndex: \"auto\",\n          pointerEvents: \"none\"\n        }\n      });\n    },\n    getChannelSliderProps(props) {\n      const {\n        orientation = \"horizontal\",\n        channel,\n        format\n      } = props;\n      return normalize.element({\n        ...parts.channelSlider.attrs,\n        \"data-channel\": channel,\n        \"data-orientation\": orientation,\n        role: \"presentation\",\n        onPointerDown(event) {\n          if (!interactive) return;\n          if (!isLeftClick(event)) return;\n          if (isModifierKey(event)) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"CHANNEL_SLIDER.POINTER_DOWN\",\n            channel,\n            format,\n            point,\n            id: channel,\n            orientation\n          });\n          event.preventDefault();\n        },\n        style: {\n          position: \"relative\",\n          touchAction: \"none\"\n        }\n      });\n    },\n    getChannelSliderTrackProps(props) {\n      const {\n        orientation = \"horizontal\",\n        channel,\n        format\n      } = props;\n      const normalizedValue = format ? value.toFormat(format) : areaValue;\n      return normalize.element({\n        ...parts.channelSliderTrack.attrs,\n        id: dom.getChannelSliderTrackId(state.context, channel),\n        role: \"group\",\n        \"data-channel\": channel,\n        \"data-orientation\": orientation,\n        style: {\n          position: \"relative\",\n          forcedColorAdjust: \"none\",\n          backgroundImage: getSliderBackground({\n            orientation,\n            channel,\n            dir: state.context.dir,\n            value: normalizedValue\n          })\n        }\n      });\n    },\n    getChannelSliderLabelProps(props) {\n      const {\n        channel\n      } = props;\n      return normalize.element({\n        ...parts.channelSliderLabel.attrs,\n        \"data-channel\": channel,\n        onClick(event) {\n          if (!interactive) return;\n          event.preventDefault();\n          const thumbId = dom.getChannelSliderThumbId(state.context, channel);\n          dom.getById(state.context, thumbId)?.focus({\n            preventScroll: true\n          });\n        },\n        style: {\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\"\n        }\n      });\n    },\n    getChannelSliderValueTextProps(props) {\n      return normalize.element({\n        ...parts.channelSliderValueText.attrs,\n        \"data-channel\": props.channel\n      });\n    },\n    getChannelSliderThumbProps(props) {\n      const {\n        orientation = \"horizontal\",\n        channel,\n        format\n      } = props;\n      const normalizedValue = format ? value.toFormat(format) : areaValue;\n      const channelRange = normalizedValue.getChannelRange(channel);\n      const channelValue = normalizedValue.getChannelValue(channel);\n      const offset = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue);\n      const placementStyles = orientation === \"horizontal\" ? {\n        left: `${offset * 100}%`,\n        top: \"50%\"\n      } : {\n        top: `${offset * 100}%`,\n        left: \"50%\"\n      };\n      return normalize.element({\n        ...parts.channelSliderThumb.attrs,\n        id: dom.getChannelSliderThumbId(state.context, channel),\n        role: \"slider\",\n        \"aria-label\": channel,\n        tabIndex: disabled ? void 0 : 0,\n        \"data-channel\": channel,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": orientation,\n        \"aria-disabled\": dataAttr(disabled),\n        \"aria-orientation\": orientation,\n        \"aria-valuemax\": channelRange.maxValue,\n        \"aria-valuemin\": channelRange.minValue,\n        \"aria-valuenow\": channelValue,\n        \"aria-valuetext\": `${channel} ${channelValue}`,\n        style: {\n          forcedColorAdjust: \"none\",\n          position: \"absolute\",\n          background: getChannelDisplayColor(areaValue, channel).toString(\"css\"),\n          ...placementStyles\n        },\n        onFocus() {\n          if (!interactive) return;\n          send({\n            type: \"CHANNEL_SLIDER.FOCUS\",\n            channel\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const step = getEventStep(event) * channelRange.step;\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"CHANNEL_SLIDER.ARROW_UP\",\n                channel,\n                step\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"CHANNEL_SLIDER.ARROW_DOWN\",\n                channel,\n                step\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"CHANNEL_SLIDER.ARROW_LEFT\",\n                channel,\n                step\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"CHANNEL_SLIDER.ARROW_RIGHT\",\n                channel,\n                step\n              });\n            },\n            PageUp() {\n              send({\n                type: \"CHANNEL_SLIDER.PAGE_UP\",\n                channel\n              });\n            },\n            PageDown() {\n              send({\n                type: \"CHANNEL_SLIDER.PAGE_DOWN\",\n                channel\n              });\n            },\n            Home() {\n              send({\n                type: \"CHANNEL_SLIDER.HOME\",\n                channel\n              });\n            },\n            End() {\n              send({\n                type: \"CHANNEL_SLIDER.END\",\n                channel\n              });\n            },\n            Escape(event2) {\n              event2.stopPropagation();\n            }\n          };\n          const exec = keyMap[getEventKey(event, state.context)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getChannelInputProps(props) {\n      const {\n        channel\n      } = props;\n      const isTextField = channel === \"hex\" || channel === \"css\";\n      const channelRange = getChannelRange(value, channel);\n      return normalize.input({\n        ...parts.channelInput.attrs,\n        dir: state.context.dir,\n        type: isTextField ? \"text\" : \"number\",\n        \"data-channel\": channel,\n        \"aria-label\": channel,\n        spellCheck: false,\n        autoComplete: \"off\",\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        readOnly: state.context.readOnly,\n        defaultValue: getChannelValue(value, channel),\n        min: channelRange?.minValue,\n        max: channelRange?.maxValue,\n        step: channelRange?.step,\n        onBeforeInput(event) {\n          if (isTextField || !interactive) return;\n          const value2 = event.currentTarget.value;\n          if (value2.match(/[^0-9.]/g)) {\n            event.preventDefault();\n          }\n        },\n        onFocus(event) {\n          if (!interactive) return;\n          send({\n            type: \"CHANNEL_INPUT.FOCUS\",\n            channel\n          });\n          event.target.select();\n        },\n        onBlur(event) {\n          if (!interactive) return;\n          const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;\n          send({\n            type: \"CHANNEL_INPUT.BLUR\",\n            channel,\n            value: value2,\n            isTextField\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          if (event.key === \"Enter\") {\n            const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;\n            send({\n              type: \"CHANNEL_INPUT.CHANGE\",\n              channel,\n              value: value2,\n              isTextField\n            });\n            event.preventDefault();\n          }\n        },\n        style: {\n          appearance: \"none\",\n          WebkitAppearance: \"none\",\n          MozAppearance: \"textfield\"\n        }\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        type: \"text\",\n        disabled,\n        name: state.context.name,\n        readOnly: state.context.readOnly,\n        required: state.context.required,\n        id: dom.getHiddenInputId(state.context),\n        style: visuallyHiddenStyle,\n        defaultValue: valueAsString\n      });\n    },\n    getEyeDropperTriggerProps() {\n      return normalize.button({\n        ...parts.eyeDropperTrigger.attrs,\n        type: \"button\",\n        dir: state.context.dir,\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        \"aria-label\": \"Pick a color from the screen\",\n        onClick() {\n          if (!interactive) return;\n          send(\"EYEDROPPER.CLICK\");\n        }\n      });\n    },\n    getSwatchGroupProps() {\n      return normalize.element({\n        ...parts.swatchGroup.attrs,\n        role: \"group\"\n      });\n    },\n    getSwatchTriggerState,\n    getSwatchTriggerProps(props) {\n      const swatchState = getSwatchTriggerState(props);\n      return normalize.button({\n        ...parts.swatchTrigger.attrs,\n        disabled: swatchState.disabled,\n        dir: state.context.dir,\n        type: \"button\",\n        \"aria-label\": `select ${swatchState.valueAsString} as the color`,\n        \"data-state\": swatchState.checked ? \"checked\" : \"unchecked\",\n        \"data-value\": swatchState.valueAsString,\n        \"data-disabled\": dataAttr(swatchState.disabled),\n        onClick() {\n          if (swatchState.disabled) return;\n          send({\n            type: \"SWATCH_TRIGGER.CLICK\",\n            value: swatchState.value\n          });\n        },\n        style: {\n          position: \"relative\"\n        }\n      });\n    },\n    getSwatchIndicatorProps(props) {\n      const swatchState = getSwatchTriggerState(props);\n      return normalize.element({\n        ...parts.swatchIndicator.attrs,\n        dir: state.context.dir,\n        hidden: !swatchState.checked\n      });\n    },\n    getSwatchProps(props) {\n      const {\n        respectAlpha = true\n      } = props;\n      const swatchState = getSwatchTriggerState(props);\n      return normalize.element({\n        ...parts.swatch.attrs,\n        dir: state.context.dir,\n        \"data-state\": swatchState.checked ? \"checked\" : \"unchecked\",\n        \"data-value\": swatchState.valueAsString,\n        style: {\n          position: \"relative\",\n          background: swatchState.value.toString(respectAlpha ? \"css\" : \"hex\")\n        }\n      });\n    },\n    getFormatTriggerProps() {\n      return normalize.button({\n        ...parts.formatTrigger.attrs,\n        dir: state.context.dir,\n        type: \"button\",\n        \"aria-label\": `change color format to ${getNextFormat(state.context.format)}`,\n        onClick(event) {\n          if (event.currentTarget.disabled) return;\n          const nextFormat = getNextFormat(state.context.format);\n          send({\n            type: \"FORMAT.SET\",\n            format: nextFormat,\n            src: \"format-trigger\"\n          });\n        }\n      });\n    },\n    getFormatSelectProps() {\n      return normalize.select({\n        ...parts.formatSelect.attrs,\n        \"aria-label\": \"change color format\",\n        dir: state.context.dir,\n        defaultValue: state.context.format,\n        disabled,\n        onChange(event) {\n          const format = assertFormat(event.currentTarget.value);\n          send({\n            type: \"FORMAT.SET\",\n            format,\n            src: \"format-select\"\n          });\n        }\n      });\n    }\n  };\n}\nvar formats = [\"hsba\", \"hsla\", \"rgba\"];\nvar formatRegex = new RegExp(`^(${formats.join(\"|\")})$`);\nfunction getNextFormat(format) {\n  const index = formats.indexOf(format);\n  return formats[index + 1] ?? formats[0];\n}\nfunction assertFormat(format) {\n  if (formatRegex.test(format)) return format;\n  throw new Error(`Unsupported color format: ${format}`);\n}\n\n// src/color-picker.machine.ts\nimport { parseColor as parseColor4 } from \"@zag-js/color-utils\";\nimport { createMachine, guards } from \"@zag-js/core\";\nimport { trackDismissableElement } from \"@zag-js/dismissable\";\nimport { trackPointerMove } from \"@zag-js/dom-event\";\nimport { getInitialFocus, raf } from \"@zag-js/dom-query\";\nimport { dispatchInputValueEvent, trackFormControl } from \"@zag-js/form-utils\";\nimport { getPlacement } from \"@zag-js/popper\";\nimport { disableTextSelection } from \"@zag-js/text-selection\";\nimport { compact, tryCatch } from \"@zag-js/utils\";\n\n// src/color-picker.parse.ts\nimport { parseColor as parseColor3 } from \"@zag-js/color-utils\";\nvar parse = colorString => {\n  return parseColor3(colorString);\n};\n\n// src/color-picker.machine.ts\nvar {\n  and\n} = guards;\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"color-picker\",\n    initial: ctx.open ? \"open\" : \"idle\",\n    context: {\n      dir: \"ltr\",\n      value: parse(\"#000000\"),\n      format: \"rgba\",\n      disabled: false,\n      closeOnSelect: false,\n      ...ctx,\n      activeId: null,\n      activeChannel: null,\n      activeOrientation: null,\n      fieldsetDisabled: false,\n      restoreFocus: true,\n      positioning: {\n        ...ctx.positioning,\n        placement: \"bottom\"\n      }\n    },\n    computed: {\n      isRtl: ctx2 => ctx2.dir === \"rtl\",\n      isDisabled: ctx2 => !!ctx2.disabled || ctx2.fieldsetDisabled,\n      isInteractive: ctx2 => !(ctx2.isDisabled || ctx2.readOnly),\n      valueAsString: ctx2 => ctx2.value.toString(ctx2.format),\n      areaValue: ctx2 => {\n        const format = ctx2.format.startsWith(\"hsl\") ? \"hsla\" : \"hsba\";\n        return ctx2.value.toFormat(format);\n      }\n    },\n    activities: [\"trackFormControl\"],\n    watch: {\n      value: [\"syncInputElements\"],\n      format: [\"syncFormatSelectElement\"],\n      open: [\"toggleVisibility\"]\n    },\n    on: {\n      \"VALUE.SET\": {\n        actions: [\"setValue\"]\n      },\n      \"FORMAT.SET\": {\n        actions: [\"setFormat\"]\n      },\n      \"CHANNEL_INPUT.CHANGE\": {\n        actions: [\"setChannelColorFromInput\"]\n      },\n      \"EYEDROPPER.CLICK\": {\n        actions: [\"openEyeDropper\"]\n      }\n    },\n    states: {\n      idle: {\n        tags: [\"closed\"],\n        on: {\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"setInitialFocus\"]\n          },\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          \"CHANNEL_INPUT.FOCUS\": {\n            target: \"focused\",\n            actions: [\"setActiveChannel\"]\n          }\n        }\n      },\n      focused: {\n        tags: [\"closed\", \"focused\"],\n        on: {\n          \"CONTROLLED.OPEN\": {\n            target: \"open\",\n            actions: [\"setInitialFocus\"]\n          },\n          OPEN: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          }, {\n            target: \"open\",\n            actions: [\"invokeOnOpen\", \"setInitialFocus\"]\n          }],\n          \"CHANNEL_INPUT.FOCUS\": {\n            actions: [\"setActiveChannel\"]\n          },\n          \"CHANNEL_INPUT.BLUR\": {\n            target: \"idle\",\n            actions: [\"setChannelColorFromInput\"]\n          },\n          \"TRIGGER.BLUR\": {\n            target: \"idle\"\n          }\n        }\n      },\n      open: {\n        tags: [\"open\"],\n        activities: [\"trackPositioning\", \"trackDismissableElement\"],\n        on: {\n          \"CONTROLLED.CLOSE\": [{\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"setReturnFocus\"]\n          }, {\n            target: \"idle\"\n          }],\n          \"TRIGGER.CLICK\": [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"AREA.POINTER_DOWN\": {\n            target: \"open:dragging\",\n            actions: [\"setActiveChannel\", \"setAreaColorFromPoint\", \"focusAreaThumb\"]\n          },\n          \"AREA.FOCUS\": {\n            actions: [\"setActiveChannel\"]\n          },\n          \"CHANNEL_SLIDER.POINTER_DOWN\": {\n            target: \"open:dragging\",\n            actions: [\"setActiveChannel\", \"setChannelColorFromPoint\", \"focusChannelThumb\"]\n          },\n          \"CHANNEL_SLIDER.FOCUS\": {\n            actions: [\"setActiveChannel\"]\n          },\n          \"AREA.ARROW_LEFT\": {\n            actions: [\"decrementAreaXChannel\"]\n          },\n          \"AREA.ARROW_RIGHT\": {\n            actions: [\"incrementAreaXChannel\"]\n          },\n          \"AREA.ARROW_UP\": {\n            actions: [\"incrementAreaYChannel\"]\n          },\n          \"AREA.ARROW_DOWN\": {\n            actions: [\"decrementAreaYChannel\"]\n          },\n          \"AREA.PAGE_UP\": {\n            actions: [\"incrementAreaXChannel\"]\n          },\n          \"AREA.PAGE_DOWN\": {\n            actions: [\"decrementAreaXChannel\"]\n          },\n          \"CHANNEL_SLIDER.ARROW_LEFT\": {\n            actions: [\"decrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.ARROW_RIGHT\": {\n            actions: [\"incrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.ARROW_UP\": {\n            actions: [\"incrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.ARROW_DOWN\": {\n            actions: [\"decrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.PAGE_UP\": {\n            actions: [\"incrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.PAGE_DOWN\": {\n            actions: [\"decrementChannel\"]\n          },\n          \"CHANNEL_SLIDER.HOME\": {\n            actions: [\"setChannelToMin\"]\n          },\n          \"CHANNEL_SLIDER.END\": {\n            actions: [\"setChannelToMax\"]\n          },\n          \"CHANNEL_INPUT.BLUR\": {\n            actions: [\"setChannelColorFromInput\"]\n          },\n          INTERACT_OUTSIDE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"setReturnFocus\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          \"SWATCH_TRIGGER.CLICK\": [{\n            guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n            actions: [\"setValue\", \"invokeOnClose\"]\n          }, {\n            guard: \"closeOnSelect\",\n            target: \"focused\",\n            actions: [\"setValue\", \"invokeOnClose\", \"setReturnFocus\"]\n          }, {\n            actions: [\"setValue\"]\n          }]\n        }\n      },\n      \"open:dragging\": {\n        tags: [\"open\"],\n        exit: [\"clearActiveChannel\"],\n        activities: [\"trackPointerMove\", \"disableTextSelection\", \"trackPositioning\", \"trackDismissableElement\"],\n        on: {\n          \"CONTROLLED.CLOSE\": [{\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"setReturnFocus\"]\n          }, {\n            target: \"idle\"\n          }],\n          \"AREA.POINTER_MOVE\": {\n            actions: [\"setAreaColorFromPoint\", \"focusAreaThumb\"]\n          },\n          \"AREA.POINTER_UP\": {\n            target: \"open\",\n            actions: [\"invokeOnChangeEnd\"]\n          },\n          \"CHANNEL_SLIDER.POINTER_MOVE\": {\n            actions: [\"setChannelColorFromPoint\", \"focusChannelThumb\"]\n          },\n          \"CHANNEL_SLIDER.POINTER_UP\": {\n            target: \"open\",\n            actions: [\"invokeOnChangeEnd\"]\n          },\n          INTERACT_OUTSIDE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            guard: \"shouldRestoreFocus\",\n            target: \"focused\",\n            actions: [\"invokeOnClose\", \"setReturnFocus\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }],\n          CLOSE: [{\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          }, {\n            target: \"idle\",\n            actions: [\"invokeOnClose\"]\n          }]\n        }\n      }\n    }\n  }, {\n    guards: {\n      closeOnSelect: ctx2 => !!ctx2.closeOnSelect,\n      isOpenControlled: ctx2 => !!ctx2[\"open.controlled\"],\n      shouldRestoreFocus: ctx2 => !!ctx2.restoreFocus\n    },\n    activities: {\n      trackPositioning(ctx2) {\n        ctx2.currentPlacement = ctx2.positioning.placement;\n        const anchorEl = dom.getTriggerEl(ctx2);\n        const getPositionerEl = () => dom.getPositionerEl(ctx2);\n        return getPlacement(anchorEl, getPositionerEl, {\n          ...ctx2.positioning,\n          defer: true,\n          onComplete(data) {\n            ctx2.currentPlacement = data.placement;\n          }\n        });\n      },\n      trackDismissableElement(ctx2, _evt, {\n        send\n      }) {\n        const getContentEl = () => dom.getContentEl(ctx2);\n        return trackDismissableElement(getContentEl, {\n          exclude: dom.getTriggerEl(ctx2),\n          defer: true,\n          onInteractOutside(event) {\n            ctx2.onInteractOutside?.(event);\n            if (event.defaultPrevented) return;\n            ctx2.restoreFocus = !(event.detail.focusable || event.detail.contextmenu);\n          },\n          onPointerDownOutside: ctx2.onPointerDownOutside,\n          onFocusOutside: ctx2.onFocusOutside,\n          onDismiss() {\n            send({\n              type: \"INTERACT_OUTSIDE\"\n            });\n          }\n        });\n      },\n      trackFormControl(ctx2, _evt, {\n        send,\n        initialContext\n      }) {\n        const inputEl = dom.getHiddenInputEl(ctx2);\n        return trackFormControl(inputEl, {\n          onFieldsetDisabledChange(disabled) {\n            ctx2.fieldsetDisabled = disabled;\n          },\n          onFormReset() {\n            send({\n              type: \"VALUE.SET\",\n              value: initialContext.value,\n              src: \"form.reset\"\n            });\n          }\n        });\n      },\n      trackPointerMove(ctx2, evt, {\n        send\n      }) {\n        return trackPointerMove(dom.getDoc(ctx2), {\n          onPointerMove({\n            point\n          }) {\n            const type = ctx2.activeId === \"area\" ? \"AREA.POINTER_MOVE\" : \"CHANNEL_SLIDER.POINTER_MOVE\";\n            send({\n              type,\n              point,\n              format: evt.format\n            });\n          },\n          onPointerUp() {\n            const type = ctx2.activeId === \"area\" ? \"AREA.POINTER_UP\" : \"CHANNEL_SLIDER.POINTER_UP\";\n            send({\n              type\n            });\n          }\n        });\n      },\n      disableTextSelection(ctx2) {\n        return disableTextSelection({\n          doc: dom.getDoc(ctx2),\n          target: dom.getContentEl(ctx2)\n        });\n      }\n    },\n    actions: {\n      openEyeDropper(ctx2) {\n        const isSupported = \"EyeDropper\" in dom.getWin(ctx2);\n        if (!isSupported) return;\n        const win = dom.getWin(ctx2);\n        const picker = new win.EyeDropper();\n        picker.open().then(({\n          sRGBHex\n        }) => {\n          const format = ctx2.value.getFormat();\n          const color = parseColor4(sRGBHex).toFormat(format);\n          set.value(ctx2, color);\n          ctx2.onValueChangeEnd?.({\n            value: ctx2.value,\n            valueAsString: ctx2.valueAsString\n          });\n        }).catch(() => void 0);\n      },\n      setActiveChannel(ctx2, evt) {\n        ctx2.activeId = evt.id;\n        if (evt.channel) ctx2.activeChannel = evt.channel;\n        if (evt.orientation) ctx2.activeOrientation = evt.orientation;\n      },\n      clearActiveChannel(ctx2) {\n        ctx2.activeChannel = null;\n        ctx2.activeId = null;\n        ctx2.activeOrientation = null;\n      },\n      setAreaColorFromPoint(ctx2, evt) {\n        const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;\n        const {\n          xChannel,\n          yChannel\n        } = evt.channel || ctx2.activeChannel;\n        const percent = dom.getAreaValueFromPoint(ctx2, evt.point);\n        if (!percent) return;\n        const xValue = normalizedValue.getChannelPercentValue(xChannel, percent.x);\n        const yValue = normalizedValue.getChannelPercentValue(yChannel, 1 - percent.y);\n        const color = normalizedValue.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);\n        set.value(ctx2, color);\n      },\n      setChannelColorFromPoint(ctx2, evt) {\n        const channel = evt.channel || ctx2.activeId;\n        const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;\n        const percent = dom.getChannelSliderValueFromPoint(ctx2, evt.point, channel);\n        if (!percent) return;\n        const orientation = ctx2.activeOrientation || \"horizontal\";\n        const channelPercent = orientation === \"horizontal\" ? percent.x : percent.y;\n        const value = normalizedValue.getChannelPercentValue(channel, channelPercent);\n        const color = normalizedValue.withChannelValue(channel, value);\n        set.value(ctx2, color);\n      },\n      setValue(ctx2, evt) {\n        set.value(ctx2, evt.value);\n      },\n      setFormat(ctx2, evt) {\n        set.format(ctx2, evt.format);\n      },\n      syncInputElements(ctx2) {\n        sync.inputs(ctx2);\n      },\n      invokeOnChangeEnd(ctx2) {\n        invoke.changeEnd(ctx2);\n      },\n      setChannelColorFromInput(ctx2, evt) {\n        const {\n          channel,\n          isTextField,\n          value\n        } = evt;\n        const currentAlpha = ctx2.value.getChannelValue(\"alpha\");\n        let color;\n        if (channel === \"alpha\") {\n          let valueAsNumber = parseFloat(value);\n          valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;\n          color = ctx2.value.withChannelValue(\"alpha\", valueAsNumber);\n        } else if (isTextField) {\n          color = tryCatch(() => parse(value).withChannelValue(\"alpha\", currentAlpha), () => ctx2.value);\n        } else {\n          const current = ctx2.value.toFormat(ctx2.format);\n          const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;\n          color = current.withChannelValue(channel, valueAsNumber);\n        }\n        sync.inputs(ctx2, color);\n        set.value(ctx2, color);\n      },\n      incrementChannel(ctx2, evt) {\n        const color = ctx2.value.incrementChannel(evt.channel, evt.step);\n        set.value(ctx2, color);\n      },\n      decrementChannel(ctx2, evt) {\n        const color = ctx2.value.decrementChannel(evt.channel, evt.step);\n        set.value(ctx2, color);\n      },\n      incrementAreaXChannel(ctx2, evt) {\n        const {\n          xChannel\n        } = evt.channel;\n        const color = ctx2.areaValue.incrementChannel(xChannel, evt.step);\n        set.value(ctx2, color);\n      },\n      decrementAreaXChannel(ctx2, evt) {\n        const {\n          xChannel\n        } = evt.channel;\n        const color = ctx2.areaValue.decrementChannel(xChannel, evt.step);\n        set.value(ctx2, color);\n      },\n      incrementAreaYChannel(ctx2, evt) {\n        const {\n          yChannel\n        } = evt.channel;\n        const color = ctx2.areaValue.incrementChannel(yChannel, evt.step);\n        set.value(ctx2, color);\n      },\n      decrementAreaYChannel(ctx2, evt) {\n        const {\n          yChannel\n        } = evt.channel;\n        const color = ctx2.areaValue.decrementChannel(yChannel, evt.step);\n        set.value(ctx2, color);\n      },\n      setChannelToMax(ctx2, evt) {\n        const range = ctx2.value.getChannelRange(evt.channel);\n        const color = ctx2.value.withChannelValue(evt.channel, range.maxValue);\n        set.value(ctx2, color);\n      },\n      setChannelToMin(ctx2, evt) {\n        const range = ctx2.value.getChannelRange(evt.channel);\n        const color = ctx2.value.withChannelValue(evt.channel, range.minValue);\n        set.value(ctx2, color);\n      },\n      focusAreaThumb(ctx2) {\n        raf(() => {\n          dom.getAreaThumbEl(ctx2)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusChannelThumb(ctx2, evt) {\n        raf(() => {\n          dom.getChannelSliderThumbEl(ctx2, evt.channel)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      setInitialFocus(ctx2) {\n        raf(() => {\n          const element = getInitialFocus({\n            root: dom.getContentEl(ctx2),\n            getInitialEl: ctx2.initialFocusEl\n          });\n          element?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      setReturnFocus(ctx2) {\n        raf(() => {\n          dom.getTriggerEl(ctx2)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      syncFormatSelectElement(ctx2) {\n        sync.formatSelect(ctx2);\n      },\n      invokeOnOpen(ctx2) {\n        ctx2.onOpenChange?.({\n          open: true\n        });\n      },\n      invokeOnClose(ctx2) {\n        ctx2.onOpenChange?.({\n          open: false\n        });\n      },\n      toggleVisibility(ctx2, evt, {\n        send\n      }) {\n        send({\n          type: ctx2.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: evt\n        });\n      }\n    },\n    compareFns: {\n      value: (a, b) => a.isEqual(b)\n    }\n  });\n}\nvar sync = {\n  // sync channel inputs\n  inputs(ctx, color) {\n    const channelInputs = dom.getChannelInputEls(ctx);\n    raf(() => {\n      channelInputs.forEach(inputEl => {\n        const channel = inputEl.dataset.channel;\n        dom.setValue(inputEl, getChannelValue(color || ctx.value, channel));\n      });\n    });\n  },\n  // sync format select\n  formatSelect(ctx) {\n    const selectEl = dom.getFormatSelectEl(ctx);\n    raf(() => {\n      dom.setValue(selectEl, ctx.format);\n    });\n  }\n};\nvar invoke = {\n  changeEnd(ctx) {\n    const value = ctx.value.toFormat(ctx.format);\n    ctx.onValueChangeEnd?.({\n      value,\n      valueAsString: ctx.valueAsString\n    });\n  },\n  change(ctx) {\n    const value = ctx.value.toFormat(ctx.format);\n    ctx.onValueChange?.({\n      value,\n      valueAsString: ctx.valueAsString\n    });\n    dispatchInputValueEvent(dom.getHiddenInputEl(ctx), {\n      value: ctx.valueAsString\n    });\n  },\n  formatChange(ctx) {\n    ctx.onFormatChange?.({\n      format: ctx.format\n    });\n  }\n};\nvar set = {\n  value(ctx, color) {\n    if (!color || ctx.value.isEqual(color)) return;\n    ctx.value = color;\n    invoke.change(ctx);\n  },\n  format(ctx, format) {\n    if (ctx.format === format) return;\n    ctx.format = format;\n    invoke.formatChange(ctx);\n  }\n};\nexport { anatomy, connect, machine, parse };","map":{"version":3,"names":["createAnatomy","anatomy","parts","build","getColorAreaGradient","normalizeColor","getEventKey","getEventPoint","getEventStep","isLeftClick","isModifierKey","dataAttr","query","visuallyHiddenStyle","getPlacementStyles","getRelativePoint","createScope","queryAll","dom","getRootId","ctx","ids","root","id","getLabelId","label","getHiddenInputId","hiddenInput","getControlId","control","getTriggerId","trigger","getContentId","content","getPositionerId","positioner","getFormatSelectId","formatSelect","getAreaId","area","getAreaGradientId","areaGradient","getAreaThumbId","areaThumb","getChannelSliderTrackId","channel","channelSliderTrack","getChannelSliderThumbId","channelSliderThumb","getContentEl","getById","getAreaThumbEl","getChannelSliderThumbEl","getChannelInputEl","selector","getControlEl","getFormatSelectEl","getHiddenInputEl","getAreaEl","getAreaValueFromPoint","point","areaEl","percent","getTriggerEl","getPositionerEl","getChannelSliderTrackEl","getChannelSliderValueFromPoint","trackEl","getChannelInputEls","parseColor","getChannelDisplayColor","color","getChannelValue","withChannelValue","Error","parseColor2","toString","isHSL","getFormat","toFormat","getChannelRange","minColor","maxColor","minValue","toHexInt","maxValue","pageSize","step","getSliderBackgroundDirection","orientation","dir","getSliderBackground","props","value","bgDirection","start","middle","end","connect","state","send","normalize","context","areaValue","valueAsString","disabled","isDisabled","interactive","isInteractive","dragging","hasTag","open","focused","getAreaChannels","channels","getChannels","xChannel","yChannel","currentPlacement","popperStyles","positioning","placement","getSwatchTriggerState","format","checked","isEqual","setOpen","nextOpen","type","setValue","value2","src","getChannelValueText","locale","formatChannelValue","setChannelValue","channelValue","setFormat","formatValue","alpha","setAlpha","alphaValue","getRootProps","element","attrs","readOnly","style","getLabelProps","htmlFor","onClick","event","preventDefault","inputEl","focus","preventScroll","getControlProps","getTriggerProps","button","onBlur","position","getPositionerProps","floating","getContentProps","hidden","getValueTextProps","valueText","getAreaProps","areaStyles","role","onPointerDown","touchAction","forcedColorAdjust","getAreaBackgroundProps","areaGradientStyles","areaBackground","getAreaThumbProps","xPercent","getChannelValuePercent","yPercent","xValue","yValue","tabIndex","left","top","transform","background","onFocus","onKeyDown","defaultPrevented","keyMap","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Escape","event2","stopPropagation","exec","getTransparencyGridProps","size","transparencyGrid","width","height","backgroundColor","backgroundImage","backgroundSize","inset","zIndex","pointerEvents","getChannelSliderProps","channelSlider","getChannelSliderTrackProps","normalizedValue","getChannelSliderLabelProps","channelSliderLabel","thumbId","userSelect","WebkitUserSelect","getChannelSliderValueTextProps","channelSliderValueText","getChannelSliderThumbProps","channelRange","offset","placementStyles","Home","End","getChannelInputProps","isTextField","input","channelInput","spellCheck","autoComplete","defaultValue","min","max","onBeforeInput","currentTarget","match","target","select","valueAsNumber","key","appearance","WebkitAppearance","MozAppearance","getHiddenInputProps","name","required","getEyeDropperTriggerProps","eyeDropperTrigger","getSwatchGroupProps","swatchGroup","getSwatchTriggerProps","swatchState","swatchTrigger","getSwatchIndicatorProps","swatchIndicator","getSwatchProps","respectAlpha","swatch","getFormatTriggerProps","formatTrigger","getNextFormat","nextFormat","getFormatSelectProps","onChange","assertFormat","formats","formatRegex","RegExp","join","index","indexOf","test","parseColor4","createMachine","guards","trackDismissableElement","trackPointerMove","getInitialFocus","raf","dispatchInputValueEvent","trackFormControl","getPlacement","disableTextSelection","compact","tryCatch","parseColor3","parse","colorString","and","machine","userContext","initial","closeOnSelect","activeId","activeChannel","activeOrientation","fieldsetDisabled","restoreFocus","computed","isRtl","ctx2","startsWith","activities","watch","on","actions","states","idle","tags","OPEN","guard","INTERACT_OUTSIDE","CLOSE","exit","isOpenControlled","shouldRestoreFocus","trackPositioning","anchorEl","defer","onComplete","data","_evt","exclude","onInteractOutside","detail","focusable","contextmenu","onPointerDownOutside","onFocusOutside","onDismiss","initialContext","onFieldsetDisabledChange","onFormReset","evt","getDoc","onPointerMove","onPointerUp","doc","openEyeDropper","isSupported","getWin","win","picker","EyeDropper","then","sRGBHex","set","onValueChangeEnd","catch","setActiveChannel","clearActiveChannel","setAreaColorFromPoint","getChannelPercentValue","x","y","setChannelColorFromPoint","channelPercent","syncInputElements","sync","inputs","invokeOnChangeEnd","invoke","changeEnd","setChannelColorFromInput","currentAlpha","parseFloat","Number","isNaN","current","incrementChannel","decrementChannel","incrementAreaXChannel","decrementAreaXChannel","incrementAreaYChannel","decrementAreaYChannel","setChannelToMax","range","setChannelToMin","focusAreaThumb","focusChannelThumb","setInitialFocus","getInitialEl","initialFocusEl","setReturnFocus","syncFormatSelectElement","invokeOnOpen","onOpenChange","invokeOnClose","toggleVisibility","previousEvent","compareFns","a","b","channelInputs","forEach","dataset","selectEl","change","onValueChange","formatChange","onFormatChange"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/color-picker/src/color-picker.anatomy.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/color-picker/src/color-picker.connect.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/color-picker/src/color-picker.dom.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/color-picker/src/utils/get-channel-display-color.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/color-picker/src/utils/get-channel-input-value.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/color-picker/src/utils/get-slider-background.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/color-picker/src/color-picker.machine.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/color-picker/src/color-picker.parse.ts"],"sourcesContent":["import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"color-picker\", [\n  \"root\",\n  \"label\",\n  \"control\",\n  \"trigger\",\n  \"positioner\",\n  \"content\",\n  \"area\",\n  \"areaThumb\",\n  \"valueText\",\n  \"areaBackground\",\n  \"channelSlider\",\n  \"channelSliderLabel\",\n  \"channelSliderTrack\",\n  \"channelSliderThumb\",\n  \"channelSliderValueText\",\n  \"channelInput\",\n  \"transparencyGrid\",\n  \"swatchGroup\",\n  \"swatchTrigger\",\n  \"swatchIndicator\",\n  \"swatch\",\n  \"eyeDropperTrigger\",\n  \"formatTrigger\",\n  \"formatSelect\",\n])\n\nexport const parts = anatomy.build()\n","import { getColorAreaGradient, normalizeColor } from \"@zag-js/color-utils\"\nimport {\n  getEventKey,\n  getEventPoint,\n  getEventStep,\n  isLeftClick,\n  isModifierKey,\n  type EventKeyMap,\n} from \"@zag-js/dom-event\"\nimport { dataAttr, query, visuallyHiddenStyle } from \"@zag-js/dom-query\"\nimport { getPlacementStyles } from \"@zag-js/popper\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./color-picker.anatomy\"\nimport { dom } from \"./color-picker.dom\"\nimport type {\n  AreaProps,\n  ColorFormat,\n  MachineApi,\n  Send,\n  State,\n  SwatchTriggerProps,\n  SwatchTriggerState,\n} from \"./color-picker.types\"\nimport { getChannelDisplayColor } from \"./utils/get-channel-display-color\"\nimport { getChannelRange, getChannelValue } from \"./utils/get-channel-input-value\"\nimport { getSliderBackground } from \"./utils/get-slider-background\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T> {\n  const value = state.context.value\n  const areaValue = state.context.areaValue\n  const valueAsString = state.context.valueAsString\n\n  const disabled = state.context.isDisabled\n  const interactive = state.context.isInteractive\n\n  const dragging = state.hasTag(\"dragging\")\n  const open = state.hasTag(\"open\")\n  const focused = state.hasTag(\"focused\")\n\n  const getAreaChannels = (props: AreaProps) => {\n    const channels = areaValue.getChannels()\n    return {\n      xChannel: props.xChannel ?? channels[1],\n      yChannel: props.yChannel ?? channels[2],\n    }\n  }\n\n  const currentPlacement = state.context.currentPlacement\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: currentPlacement,\n  })\n\n  function getSwatchTriggerState(props: SwatchTriggerProps): SwatchTriggerState {\n    const color = normalizeColor(props.value).toFormat(state.context.format)\n    return {\n      value: color,\n      valueAsString: color.toString(\"hex\"),\n      checked: color.isEqual(value),\n      disabled: props.disabled || !interactive,\n    }\n  }\n\n  return {\n    dragging,\n    open,\n    valueAsString,\n    value,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return\n      send({ type: nextOpen ? \"OPEN\" : \"CLOSE\" })\n    },\n    setValue(value) {\n      send({ type: \"VALUE.SET\", value: normalizeColor(value), src: \"set-color\" })\n    },\n    getChannelValue(channel) {\n      return getChannelValue(value, channel)\n    },\n    getChannelValueText(channel, locale) {\n      return value.formatChannelValue(channel, locale)\n    },\n    setChannelValue(channel, channelValue) {\n      const color = value.withChannelValue(channel, channelValue)\n      send({ type: \"VALUE.SET\", value: color, src: \"set-channel\" })\n    },\n    format: state.context.format,\n    setFormat(format) {\n      const formatValue = value.toFormat(format)\n      send({ type: \"VALUE.SET\", value: formatValue, src: \"set-format\" })\n    },\n    alpha: value.getChannelValue(\"alpha\"),\n    setAlpha(alphaValue) {\n      const color = value.withChannelValue(\"alpha\", alphaValue)\n      send({ type: \"VALUE.SET\", value: color, src: \"set-alpha\" })\n    },\n\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        style: {\n          \"--value\": value.toString(\"css\"),\n        },\n      })\n    },\n\n    getLabelProps() {\n      return normalize.element({\n        ...parts.label.attrs,\n        dir: state.context.dir,\n        id: dom.getLabelId(state.context),\n        htmlFor: dom.getHiddenInputId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-focus\": dataAttr(focused),\n        onClick(event) {\n          event.preventDefault()\n          const inputEl = query(dom.getControlEl(state.context), \"[data-channel=hex]\")\n          inputEl?.focus({ preventScroll: true })\n        },\n      })\n    },\n\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        id: dom.getControlId(state.context),\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused),\n      })\n    },\n\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: dom.getTriggerId(state.context),\n        dir: state.context.dir,\n        disabled: disabled,\n        \"aria-label\": `select color. current color is ${valueAsString}`,\n        \"aria-controls\": dom.getContentId(state.context),\n        \"aria-labelledby\": dom.getLabelId(state.context),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(state.context.readOnly),\n        \"data-placement\": currentPlacement,\n        \"aria-expanded\": dataAttr(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused),\n        type: \"button\",\n        onClick() {\n          if (!interactive) return\n          send({ type: \"TRIGGER.CLICK\" })\n        },\n        onBlur() {\n          if (!interactive) return\n          send({ type: \"TRIGGER.BLUR\" })\n        },\n        style: {\n          position: \"relative\",\n        },\n      })\n    },\n\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        id: dom.getPositionerId(state.context),\n        dir: state.context.dir,\n        style: popperStyles.floating,\n      })\n    },\n\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: dom.getContentId(state.context),\n        dir: state.context.dir,\n        \"data-placement\": currentPlacement,\n        \"data-state\": open ? \"open\" : \"closed\",\n        hidden: !open,\n      })\n    },\n\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused),\n      })\n    },\n\n    getAreaProps(props = {}) {\n      const { xChannel, yChannel } = getAreaChannels(props)\n      const { areaStyles } = getColorAreaGradient(areaValue, {\n        xChannel,\n        yChannel,\n        dir: state.context.dir,\n      })\n\n      return normalize.element({\n        ...parts.area.attrs,\n        id: dom.getAreaId(state.context),\n        role: \"group\",\n        onPointerDown(event) {\n          if (!interactive) return\n          if (!isLeftClick(event)) return\n          if (isModifierKey(event)) return\n\n          const point = getEventPoint(event)\n          const channel = { xChannel, yChannel }\n\n          send({ type: \"AREA.POINTER_DOWN\", point, channel, id: \"area\" })\n          event.preventDefault()\n        },\n        style: {\n          position: \"relative\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          ...areaStyles,\n        },\n      })\n    },\n\n    getAreaBackgroundProps(props = {}) {\n      const { xChannel, yChannel } = getAreaChannels(props)\n      const { areaGradientStyles } = getColorAreaGradient(areaValue, {\n        xChannel,\n        yChannel,\n        dir: state.context.dir,\n      })\n\n      return normalize.element({\n        ...parts.areaBackground.attrs,\n        id: dom.getAreaGradientId(state.context),\n        style: {\n          position: \"relative\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          ...areaGradientStyles,\n        },\n      })\n    },\n\n    getAreaThumbProps(props = {}) {\n      const { xChannel, yChannel } = getAreaChannels(props)\n      const channel = { xChannel, yChannel }\n\n      const xPercent = areaValue.getChannelValuePercent(xChannel)\n      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel)\n\n      const xValue = areaValue.getChannelValue(xChannel)\n      const yValue = areaValue.getChannelValue(yChannel)\n\n      return normalize.element({\n        ...parts.areaThumb.attrs,\n        id: dom.getAreaThumbId(state.context),\n        dir: state.context.dir,\n        tabIndex: disabled ? undefined : 0,\n        \"data-disabled\": dataAttr(disabled),\n        role: \"slider\",\n        \"aria-valuemin\": 0,\n        \"aria-valuemax\": 100,\n        \"aria-valuenow\": xValue,\n        \"aria-label\": `${xChannel} and ${yChannel}`,\n        \"aria-roledescription\": \"2d slider\",\n        \"aria-valuetext\": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,\n        style: {\n          position: \"absolute\",\n          left: `${xPercent * 100}%`,\n          top: `${yPercent * 100}%`,\n          transform: \"translate(-50%, -50%)\",\n          touchAction: \"none\",\n          forcedColorAdjust: \"none\",\n          background: areaValue.withChannelValue(\"alpha\", 1).toString(\"css\"),\n        },\n        onFocus() {\n          if (!interactive) return\n          send({ type: \"AREA.FOCUS\", id: \"area\", channel })\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return\n          if (!interactive) return\n\n          const step = getEventStep(event)\n\n          const keyMap: EventKeyMap = {\n            ArrowUp() {\n              send({ type: \"AREA.ARROW_UP\", channel, step })\n            },\n            ArrowDown() {\n              send({ type: \"AREA.ARROW_DOWN\", channel, step })\n            },\n            ArrowLeft() {\n              send({ type: \"AREA.ARROW_LEFT\", channel, step })\n            },\n            ArrowRight() {\n              send({ type: \"AREA.ARROW_RIGHT\", channel, step })\n            },\n            PageUp() {\n              send({ type: \"AREA.PAGE_UP\", channel, step })\n            },\n            PageDown() {\n              send({ type: \"AREA.PAGE_DOWN\", channel, step })\n            },\n            Escape(event) {\n              event.stopPropagation()\n            },\n          }\n\n          const exec = keyMap[getEventKey(event, state.context)]\n\n          if (exec) {\n            exec(event)\n            event.preventDefault()\n          }\n        },\n      })\n    },\n\n    getTransparencyGridProps(props = {}) {\n      const { size = \"12px\" } = props\n      return normalize.element({\n        ...parts.transparencyGrid.attrs,\n        style: {\n          \"--size\": size,\n          width: \"100%\",\n          height: \"100%\",\n          position: \"absolute\",\n          backgroundColor: \"#fff\",\n          backgroundImage: \"conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)\",\n          backgroundSize: \"var(--size) var(--size)\",\n          inset: \"0px\",\n          zIndex: \"auto\",\n          pointerEvents: \"none\",\n        },\n      })\n    },\n\n    getChannelSliderProps(props) {\n      const { orientation = \"horizontal\", channel, format } = props\n      return normalize.element({\n        ...parts.channelSlider.attrs,\n        \"data-channel\": channel,\n        \"data-orientation\": orientation,\n        role: \"presentation\",\n        onPointerDown(event) {\n          if (!interactive) return\n          if (!isLeftClick(event)) return\n          if (isModifierKey(event)) return\n\n          const point = getEventPoint(event)\n          send({ type: \"CHANNEL_SLIDER.POINTER_DOWN\", channel, format, point, id: channel, orientation })\n\n          event.preventDefault()\n        },\n        style: {\n          position: \"relative\",\n          touchAction: \"none\",\n        },\n      })\n    },\n\n    getChannelSliderTrackProps(props) {\n      const { orientation = \"horizontal\", channel, format } = props\n      const normalizedValue = format ? value.toFormat(format) : areaValue\n\n      return normalize.element({\n        ...parts.channelSliderTrack.attrs,\n        id: dom.getChannelSliderTrackId(state.context, channel),\n        role: \"group\",\n        \"data-channel\": channel,\n        \"data-orientation\": orientation,\n        style: {\n          position: \"relative\",\n          forcedColorAdjust: \"none\",\n          backgroundImage: getSliderBackground({\n            orientation,\n            channel,\n            dir: state.context.dir,\n            value: normalizedValue,\n          }),\n        },\n      })\n    },\n\n    getChannelSliderLabelProps(props) {\n      const { channel } = props\n      return normalize.element({\n        ...parts.channelSliderLabel.attrs,\n        \"data-channel\": channel,\n        onClick(event) {\n          if (!interactive) return\n          event.preventDefault()\n          const thumbId = dom.getChannelSliderThumbId(state.context, channel)\n          dom.getById(state.context, thumbId)?.focus({ preventScroll: true })\n        },\n        style: {\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n        },\n      })\n    },\n\n    getChannelSliderValueTextProps(props) {\n      return normalize.element({\n        ...parts.channelSliderValueText.attrs,\n        \"data-channel\": props.channel,\n      })\n    },\n\n    getChannelSliderThumbProps(props) {\n      const { orientation = \"horizontal\", channel, format } = props\n\n      const normalizedValue = format ? value.toFormat(format) : areaValue\n      const channelRange = normalizedValue.getChannelRange(channel)\n      const channelValue = normalizedValue.getChannelValue(channel)\n\n      const offset = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue)\n\n      const placementStyles =\n        orientation === \"horizontal\"\n          ? { left: `${offset * 100}%`, top: \"50%\" }\n          : { top: `${offset * 100}%`, left: \"50%\" }\n\n      return normalize.element({\n        ...parts.channelSliderThumb.attrs,\n        id: dom.getChannelSliderThumbId(state.context, channel),\n        role: \"slider\",\n        \"aria-label\": channel,\n        tabIndex: disabled ? undefined : 0,\n        \"data-channel\": channel,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": orientation,\n        \"aria-disabled\": dataAttr(disabled),\n        \"aria-orientation\": orientation,\n        \"aria-valuemax\": channelRange.maxValue,\n        \"aria-valuemin\": channelRange.minValue,\n        \"aria-valuenow\": channelValue,\n        \"aria-valuetext\": `${channel} ${channelValue}`,\n        style: {\n          forcedColorAdjust: \"none\",\n          position: \"absolute\",\n          background: getChannelDisplayColor(areaValue, channel).toString(\"css\"),\n          ...placementStyles,\n        },\n        onFocus() {\n          if (!interactive) return\n          send({ type: \"CHANNEL_SLIDER.FOCUS\", channel })\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return\n          if (!interactive) return\n\n          const step = getEventStep(event) * channelRange.step\n\n          const keyMap: EventKeyMap = {\n            ArrowUp() {\n              send({ type: \"CHANNEL_SLIDER.ARROW_UP\", channel, step })\n            },\n            ArrowDown() {\n              send({ type: \"CHANNEL_SLIDER.ARROW_DOWN\", channel, step })\n            },\n            ArrowLeft() {\n              send({ type: \"CHANNEL_SLIDER.ARROW_LEFT\", channel, step })\n            },\n            ArrowRight() {\n              send({ type: \"CHANNEL_SLIDER.ARROW_RIGHT\", channel, step })\n            },\n            PageUp() {\n              send({ type: \"CHANNEL_SLIDER.PAGE_UP\", channel })\n            },\n            PageDown() {\n              send({ type: \"CHANNEL_SLIDER.PAGE_DOWN\", channel })\n            },\n            Home() {\n              send({ type: \"CHANNEL_SLIDER.HOME\", channel })\n            },\n            End() {\n              send({ type: \"CHANNEL_SLIDER.END\", channel })\n            },\n            Escape(event) {\n              event.stopPropagation()\n            },\n          }\n\n          const exec = keyMap[getEventKey(event, state.context)]\n\n          if (exec) {\n            exec(event)\n            event.preventDefault()\n          }\n        },\n      })\n    },\n\n    getChannelInputProps(props) {\n      const { channel } = props\n\n      const isTextField = channel === \"hex\" || channel === \"css\"\n      const channelRange = getChannelRange(value, channel)\n\n      return normalize.input({\n        ...parts.channelInput.attrs,\n        dir: state.context.dir,\n        type: isTextField ? \"text\" : \"number\",\n        \"data-channel\": channel,\n        \"aria-label\": channel,\n        spellCheck: false,\n        autoComplete: \"off\",\n        disabled: disabled,\n        \"data-disabled\": dataAttr(disabled),\n        readOnly: state.context.readOnly,\n        defaultValue: getChannelValue(value, channel),\n        min: channelRange?.minValue,\n        max: channelRange?.maxValue,\n        step: channelRange?.step,\n        onBeforeInput(event) {\n          if (isTextField || !interactive) return\n          const value = event.currentTarget.value\n          if (value.match(/[^0-9.]/g)) {\n            event.preventDefault()\n          }\n        },\n        onFocus(event) {\n          if (!interactive) return\n          send({ type: \"CHANNEL_INPUT.FOCUS\", channel })\n          event.target.select()\n        },\n        onBlur(event) {\n          if (!interactive) return\n          const value = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber\n          send({ type: \"CHANNEL_INPUT.BLUR\", channel, value, isTextField })\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return\n          if (!interactive) return\n          if (event.key === \"Enter\") {\n            const value = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber\n            send({ type: \"CHANNEL_INPUT.CHANGE\", channel, value, isTextField })\n            event.preventDefault()\n          }\n        },\n        style: {\n          appearance: \"none\",\n          WebkitAppearance: \"none\",\n          MozAppearance: \"textfield\",\n        },\n      })\n    },\n\n    getHiddenInputProps() {\n      return normalize.input({\n        type: \"text\",\n        disabled,\n        name: state.context.name,\n        readOnly: state.context.readOnly,\n        required: state.context.required,\n        id: dom.getHiddenInputId(state.context),\n        style: visuallyHiddenStyle,\n        defaultValue: valueAsString,\n      })\n    },\n\n    getEyeDropperTriggerProps() {\n      return normalize.button({\n        ...parts.eyeDropperTrigger.attrs,\n        type: \"button\",\n        dir: state.context.dir,\n        disabled: disabled,\n        \"data-disabled\": dataAttr(disabled),\n        \"aria-label\": \"Pick a color from the screen\",\n        onClick() {\n          if (!interactive) return\n          send(\"EYEDROPPER.CLICK\")\n        },\n      })\n    },\n\n    getSwatchGroupProps() {\n      return normalize.element({\n        ...parts.swatchGroup.attrs,\n        role: \"group\",\n      })\n    },\n\n    getSwatchTriggerState,\n\n    getSwatchTriggerProps(props) {\n      const swatchState = getSwatchTriggerState(props)\n      return normalize.button({\n        ...parts.swatchTrigger.attrs,\n        disabled: swatchState.disabled,\n        dir: state.context.dir,\n        type: \"button\",\n        \"aria-label\": `select ${swatchState.valueAsString} as the color`,\n        \"data-state\": swatchState.checked ? \"checked\" : \"unchecked\",\n        \"data-value\": swatchState.valueAsString,\n        \"data-disabled\": dataAttr(swatchState.disabled),\n        onClick() {\n          if (swatchState.disabled) return\n          send({ type: \"SWATCH_TRIGGER.CLICK\", value: swatchState.value })\n        },\n        style: {\n          position: \"relative\",\n        },\n      })\n    },\n\n    getSwatchIndicatorProps(props) {\n      const swatchState = getSwatchTriggerState(props)\n      return normalize.element({\n        ...parts.swatchIndicator.attrs,\n        dir: state.context.dir,\n        hidden: !swatchState.checked,\n      })\n    },\n\n    getSwatchProps(props) {\n      const { respectAlpha = true } = props\n      const swatchState = getSwatchTriggerState(props)\n      return normalize.element({\n        ...parts.swatch.attrs,\n        dir: state.context.dir,\n        \"data-state\": swatchState.checked ? \"checked\" : \"unchecked\",\n        \"data-value\": swatchState.valueAsString,\n        style: {\n          position: \"relative\",\n          background: swatchState.value.toString(respectAlpha ? \"css\" : \"hex\"),\n        },\n      })\n    },\n\n    getFormatTriggerProps() {\n      return normalize.button({\n        ...parts.formatTrigger.attrs,\n        dir: state.context.dir,\n        type: \"button\",\n        \"aria-label\": `change color format to ${getNextFormat(state.context.format)}`,\n        onClick(event) {\n          if (event.currentTarget.disabled) return\n          const nextFormat = getNextFormat(state.context.format)\n          send({ type: \"FORMAT.SET\", format: nextFormat, src: \"format-trigger\" })\n        },\n      })\n    },\n\n    getFormatSelectProps() {\n      return normalize.select({\n        ...parts.formatSelect.attrs,\n        \"aria-label\": \"change color format\",\n        dir: state.context.dir,\n        defaultValue: state.context.format,\n        disabled: disabled,\n        onChange(event) {\n          const format = assertFormat(event.currentTarget.value)\n          send({ type: \"FORMAT.SET\", format, src: \"format-select\" })\n        },\n      })\n    },\n  }\n}\n\nconst formats: ColorFormat[] = [\"hsba\", \"hsla\", \"rgba\"]\nconst formatRegex = new RegExp(`^(${formats.join(\"|\")})$`)\n\nfunction getNextFormat(format: ColorFormat) {\n  const index = formats.indexOf(format)\n  return formats[index + 1] ?? formats[0]\n}\n\nfunction assertFormat(format: string) {\n  if (formatRegex.test(format)) return format as ColorFormat\n  throw new Error(`Unsupported color format: ${format}`)\n}\n","import type { ColorChannel } from \"@zag-js/color-utils\"\nimport { getRelativePoint, type Point } from \"@zag-js/dom-event\"\nimport { createScope, queryAll } from \"@zag-js/dom-query\"\nimport type { MachineContext as Ctx } from \"./color-picker.types\"\n\nexport const dom = createScope({\n  getRootId: (ctx: Ctx) => ctx.ids?.root ?? `color-picker:${ctx.id}`,\n  getLabelId: (ctx: Ctx) => ctx.ids?.label ?? `color-picker:${ctx.id}:label`,\n  getHiddenInputId: (ctx: Ctx) => ctx.ids?.hiddenInput ?? `color-picker:${ctx.id}:hidden-input`,\n  getControlId: (ctx: Ctx) => ctx.ids?.control ?? `color-picker:${ctx.id}:control`,\n  getTriggerId: (ctx: Ctx) => ctx.ids?.trigger ?? `color-picker:${ctx.id}:trigger`,\n  getContentId: (ctx: Ctx) => ctx.ids?.content ?? `color-picker:${ctx.id}:content`,\n  getPositionerId: (ctx: Ctx) => ctx.ids?.positioner ?? `color-picker:${ctx.id}:positioner`,\n  getFormatSelectId: (ctx: Ctx) => ctx.ids?.formatSelect ?? `color-picker:${ctx.id}:format-select`,\n\n  getAreaId: (ctx: Ctx) => ctx.ids?.area ?? `color-picker:${ctx.id}:area`,\n  getAreaGradientId: (ctx: Ctx) => ctx.ids?.areaGradient ?? `color-picker:${ctx.id}:area-gradient`,\n  getAreaThumbId: (ctx: Ctx) => ctx.ids?.areaThumb ?? `color-picker:${ctx.id}:area-thumb`,\n\n  getChannelSliderTrackId: (ctx: Ctx, channel: ColorChannel) =>\n    ctx.ids?.channelSliderTrack?.(channel) ?? `color-picker:${ctx.id}:slider-track:${channel}`,\n  getChannelSliderThumbId: (ctx: Ctx, channel: ColorChannel) =>\n    ctx.ids?.channelSliderThumb?.(channel) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`,\n\n  getContentEl: (ctx: Ctx) => dom.getById(ctx, dom.getContentId(ctx)),\n  getAreaThumbEl: (ctx: Ctx) => dom.getById(ctx, dom.getAreaThumbId(ctx)),\n  getChannelSliderThumbEl: (ctx: Ctx, channel: ColorChannel) =>\n    dom.getById(ctx, dom.getChannelSliderThumbId(ctx, channel)),\n  getChannelInputEl: (ctx: Ctx, channel: string): HTMLInputElement[] => {\n    const selector = `input[data-channel=\"${channel}\"]`\n    return [\n      ...queryAll<HTMLInputElement>(dom.getContentEl(ctx), selector),\n      ...queryAll<HTMLInputElement>(dom.getControlEl(ctx), selector),\n    ]\n  },\n  getFormatSelectEl: (ctx: Ctx) => dom.getById<HTMLSelectElement>(ctx, dom.getFormatSelectId(ctx)),\n\n  getHiddenInputEl: (ctx: Ctx) => dom.getById<HTMLInputElement>(ctx, dom.getHiddenInputId(ctx)),\n  getAreaEl: (ctx: Ctx) => dom.getById(ctx, dom.getAreaId(ctx)),\n  getAreaValueFromPoint(ctx: Ctx, point: Point) {\n    const areaEl = dom.getAreaEl(ctx)\n    if (!areaEl) return\n    const { percent } = getRelativePoint(point, areaEl)\n    return percent\n  },\n\n  getControlEl: (ctx: Ctx) => dom.getById(ctx, dom.getControlId(ctx)),\n  getTriggerEl: (ctx: Ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getPositionerEl: (ctx: Ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getChannelSliderTrackEl: (ctx: Ctx, channel: ColorChannel) => {\n    return dom.getById(ctx, dom.getChannelSliderTrackId(ctx, channel))\n  },\n  getChannelSliderValueFromPoint(ctx: Ctx, point: Point, channel: ColorChannel) {\n    const trackEl = dom.getChannelSliderTrackEl(ctx, channel)\n    if (!trackEl) return\n    const { percent } = getRelativePoint(point, trackEl)\n    return percent\n  },\n  getChannelInputEls: (ctx: Ctx) => {\n    return [\n      ...queryAll<HTMLInputElement>(dom.getContentEl(ctx), \"input[data-channel]\"),\n      ...queryAll<HTMLInputElement>(dom.getControlEl(ctx), \"input[data-channel]\"),\n    ]\n  },\n})\n","import { parseColor, type Color, type ColorChannel } from \"@zag-js/color-utils\"\n\nexport function getChannelDisplayColor(color: Color, channel: ColorChannel) {\n  switch (channel) {\n    case \"hue\":\n      return parseColor(`hsl(${color.getChannelValue(\"hue\")}, 100%, 50%)`)\n    case \"lightness\":\n    case \"brightness\":\n    case \"saturation\":\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.withChannelValue(\"alpha\", 1)\n    case \"alpha\": {\n      return color\n    }\n    default:\n      throw new Error(\"Unknown color channel: \" + channel)\n  }\n}\n","import { parseColor, type Color, type ColorChannelRange } from \"@zag-js/color-utils\"\nimport type { ExtendedColorChannel } from \"../color-picker.types\"\n\nexport function getChannelValue(color: Color, channel: ExtendedColorChannel | null | undefined): string {\n  if (channel == null) return \"\"\n\n  if (channel === \"hex\") {\n    return color.toString(\"hex\")\n  }\n\n  if (channel === \"css\") {\n    return color.toString(\"css\")\n  }\n\n  if (channel in color) {\n    return color.getChannelValue(channel).toString()\n  }\n\n  const isHSL = color.getFormat() === \"hsla\"\n\n  switch (channel) {\n    case \"hue\":\n      return isHSL\n        ? color.toFormat(\"hsla\").getChannelValue(\"hue\").toString()\n        : color.toFormat(\"hsba\").getChannelValue(\"hue\").toString()\n\n    case \"saturation\":\n      return isHSL\n        ? color.toFormat(\"hsla\").getChannelValue(\"saturation\").toString()\n        : color.toFormat(\"hsba\").getChannelValue(\"saturation\").toString()\n\n    case \"lightness\":\n      return color.toFormat(\"hsla\").getChannelValue(\"lightness\").toString()\n\n    case \"brightness\":\n      return color.toFormat(\"hsba\").getChannelValue(\"brightness\").toString()\n\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.toFormat(\"rgba\").getChannelValue(channel).toString()\n\n    default:\n      return color.getChannelValue(channel).toString()\n  }\n}\n\nexport function getChannelRange(color: Color, channel: ExtendedColorChannel): ColorChannelRange | undefined {\n  switch (channel) {\n    case \"hex\":\n      const minColor = parseColor(\"#000000\")\n      const maxColor = parseColor(\"#FFFFFF\")\n      return {\n        minValue: minColor.toHexInt(),\n        maxValue: maxColor.toHexInt(),\n        pageSize: 10,\n        step: 1,\n      }\n\n    case \"css\":\n      return undefined\n\n    case \"hue\":\n    case \"saturation\":\n    case \"lightness\":\n      return color.toFormat(\"hsla\").getChannelRange(channel)\n\n    case \"brightness\":\n      return color.toFormat(\"hsba\").getChannelRange(channel)\n\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n      return color.toFormat(\"rgba\").getChannelRange(channel)\n\n    default:\n      return color.getChannelRange(channel)\n  }\n}\n","import type { ChannelProps, Color, MachineContext } from \"../color-picker.types\"\n\nfunction getSliderBackgroundDirection(orientation: \"vertical\" | \"horizontal\", dir: \"ltr\" | \"rtl\") {\n  if (orientation === \"vertical\") {\n    return \"top\"\n  } else if (dir === \"ltr\") {\n    return \"right\"\n  } else {\n    return \"left\"\n  }\n}\n\ninterface SliderBackgroundProps extends Required<ChannelProps> {\n  value: Color\n  dir: MachineContext[\"dir\"]\n}\n\nexport const getSliderBackground = (props: SliderBackgroundProps) => {\n  const { channel, value, dir } = props\n  const bgDirection = getSliderBackgroundDirection(props.orientation, dir!)\n  const { minValue, maxValue } = value.getChannelRange(channel)\n\n  switch (channel) {\n    case \"hue\":\n      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`\n    case \"lightness\": {\n      let start = value.withChannelValue(channel, minValue).toString(\"css\")\n      let middle = value.withChannelValue(channel, (maxValue - minValue) / 2).toString(\"css\")\n      let end = value.withChannelValue(channel, maxValue).toString(\"css\")\n      return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`\n    }\n    case \"saturation\":\n    case \"brightness\":\n    case \"red\":\n    case \"green\":\n    case \"blue\":\n    case \"alpha\": {\n      let start = value.withChannelValue(channel, minValue).toString(\"css\")\n      let end = value.withChannelValue(channel, maxValue).toString(\"css\")\n      return `linear-gradient(to ${bgDirection}, ${start}, ${end})`\n    }\n    default:\n      throw new Error(\"Unknown color channel: \" + channel)\n  }\n}\n","import { parseColor, type Color } from \"@zag-js/color-utils\"\nimport { createMachine, guards } from \"@zag-js/core\"\nimport { trackDismissableElement } from \"@zag-js/dismissable\"\nimport { trackPointerMove } from \"@zag-js/dom-event\"\nimport { getInitialFocus, raf } from \"@zag-js/dom-query\"\nimport { dispatchInputValueEvent, trackFormControl } from \"@zag-js/form-utils\"\nimport { getPlacement } from \"@zag-js/popper\"\nimport { disableTextSelection } from \"@zag-js/text-selection\"\nimport { compact, tryCatch } from \"@zag-js/utils\"\nimport { dom } from \"./color-picker.dom\"\nimport { parse } from \"./color-picker.parse\"\nimport type {\n  ColorFormat,\n  ColorType,\n  ExtendedColorChannel,\n  MachineContext,\n  MachineState,\n  UserDefinedContext,\n} from \"./color-picker.types\"\nimport { getChannelValue } from \"./utils/get-channel-input-value\"\n\nconst { and } = guards\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"color-picker\",\n      initial: ctx.open ? \"open\" : \"idle\",\n      context: {\n        dir: \"ltr\",\n        value: parse(\"#000000\"),\n        format: \"rgba\",\n        disabled: false,\n        closeOnSelect: false,\n        ...ctx,\n        activeId: null,\n        activeChannel: null,\n        activeOrientation: null,\n        fieldsetDisabled: false,\n        restoreFocus: true,\n        positioning: {\n          ...ctx.positioning,\n          placement: \"bottom\",\n        },\n      },\n\n      computed: {\n        isRtl: (ctx) => ctx.dir === \"rtl\",\n        isDisabled: (ctx) => !!ctx.disabled || ctx.fieldsetDisabled,\n        isInteractive: (ctx) => !(ctx.isDisabled || ctx.readOnly),\n        valueAsString: (ctx) => ctx.value.toString(ctx.format),\n        areaValue: (ctx) => {\n          const format = ctx.format.startsWith(\"hsl\") ? \"hsla\" : \"hsba\"\n          return ctx.value.toFormat(format)\n        },\n      },\n\n      activities: [\"trackFormControl\"],\n\n      watch: {\n        value: [\"syncInputElements\"],\n        format: [\"syncFormatSelectElement\"],\n        open: [\"toggleVisibility\"],\n      },\n\n      on: {\n        \"VALUE.SET\": {\n          actions: [\"setValue\"],\n        },\n        \"FORMAT.SET\": {\n          actions: [\"setFormat\"],\n        },\n        \"CHANNEL_INPUT.CHANGE\": {\n          actions: [\"setChannelColorFromInput\"],\n        },\n        \"EYEDROPPER.CLICK\": {\n          actions: [\"openEyeDropper\"],\n        },\n      },\n\n      states: {\n        idle: {\n          tags: [\"closed\"],\n          on: {\n            \"CONTROLLED.OPEN\": {\n              target: \"open\",\n              actions: [\"setInitialFocus\"],\n            },\n            OPEN: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnOpen\"],\n              },\n              {\n                target: \"open\",\n                actions: [\"invokeOnOpen\", \"setInitialFocus\"],\n              },\n            ],\n            \"TRIGGER.CLICK\": [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnOpen\"],\n              },\n              {\n                target: \"open\",\n                actions: [\"invokeOnOpen\", \"setInitialFocus\"],\n              },\n            ],\n            \"CHANNEL_INPUT.FOCUS\": {\n              target: \"focused\",\n              actions: [\"setActiveChannel\"],\n            },\n          },\n        },\n\n        focused: {\n          tags: [\"closed\", \"focused\"],\n          on: {\n            \"CONTROLLED.OPEN\": {\n              target: \"open\",\n              actions: [\"setInitialFocus\"],\n            },\n            OPEN: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnOpen\"],\n              },\n              {\n                target: \"open\",\n                actions: [\"invokeOnOpen\", \"setInitialFocus\"],\n              },\n            ],\n            \"TRIGGER.CLICK\": [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnOpen\"],\n              },\n              {\n                target: \"open\",\n                actions: [\"invokeOnOpen\", \"setInitialFocus\"],\n              },\n            ],\n            \"CHANNEL_INPUT.FOCUS\": {\n              actions: [\"setActiveChannel\"],\n            },\n            \"CHANNEL_INPUT.BLUR\": {\n              target: \"idle\",\n              actions: [\"setChannelColorFromInput\"],\n            },\n            \"TRIGGER.BLUR\": {\n              target: \"idle\",\n            },\n          },\n        },\n\n        open: {\n          tags: [\"open\"],\n          activities: [\"trackPositioning\", \"trackDismissableElement\"],\n          on: {\n            \"CONTROLLED.CLOSE\": [\n              {\n                guard: \"shouldRestoreFocus\",\n                target: \"focused\",\n                actions: [\"setReturnFocus\"],\n              },\n              {\n                target: \"idle\",\n              },\n            ],\n            \"TRIGGER.CLICK\": [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"],\n              },\n              {\n                target: \"idle\",\n                actions: [\"invokeOnClose\"],\n              },\n            ],\n            \"AREA.POINTER_DOWN\": {\n              target: \"open:dragging\",\n              actions: [\"setActiveChannel\", \"setAreaColorFromPoint\", \"focusAreaThumb\"],\n            },\n            \"AREA.FOCUS\": {\n              actions: [\"setActiveChannel\"],\n            },\n            \"CHANNEL_SLIDER.POINTER_DOWN\": {\n              target: \"open:dragging\",\n              actions: [\"setActiveChannel\", \"setChannelColorFromPoint\", \"focusChannelThumb\"],\n            },\n            \"CHANNEL_SLIDER.FOCUS\": {\n              actions: [\"setActiveChannel\"],\n            },\n            \"AREA.ARROW_LEFT\": {\n              actions: [\"decrementAreaXChannel\"],\n            },\n            \"AREA.ARROW_RIGHT\": {\n              actions: [\"incrementAreaXChannel\"],\n            },\n            \"AREA.ARROW_UP\": {\n              actions: [\"incrementAreaYChannel\"],\n            },\n            \"AREA.ARROW_DOWN\": {\n              actions: [\"decrementAreaYChannel\"],\n            },\n            \"AREA.PAGE_UP\": {\n              actions: [\"incrementAreaXChannel\"],\n            },\n            \"AREA.PAGE_DOWN\": {\n              actions: [\"decrementAreaXChannel\"],\n            },\n            \"CHANNEL_SLIDER.ARROW_LEFT\": {\n              actions: [\"decrementChannel\"],\n            },\n            \"CHANNEL_SLIDER.ARROW_RIGHT\": {\n              actions: [\"incrementChannel\"],\n            },\n            \"CHANNEL_SLIDER.ARROW_UP\": {\n              actions: [\"incrementChannel\"],\n            },\n            \"CHANNEL_SLIDER.ARROW_DOWN\": {\n              actions: [\"decrementChannel\"],\n            },\n            \"CHANNEL_SLIDER.PAGE_UP\": {\n              actions: [\"incrementChannel\"],\n            },\n            \"CHANNEL_SLIDER.PAGE_DOWN\": {\n              actions: [\"decrementChannel\"],\n            },\n            \"CHANNEL_SLIDER.HOME\": {\n              actions: [\"setChannelToMin\"],\n            },\n            \"CHANNEL_SLIDER.END\": {\n              actions: [\"setChannelToMax\"],\n            },\n            \"CHANNEL_INPUT.BLUR\": {\n              actions: [\"setChannelColorFromInput\"],\n            },\n            INTERACT_OUTSIDE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"],\n              },\n              {\n                guard: \"shouldRestoreFocus\",\n                target: \"focused\",\n                actions: [\"invokeOnClose\", \"setReturnFocus\"],\n              },\n              {\n                target: \"idle\",\n                actions: [\"invokeOnClose\"],\n              },\n            ],\n            CLOSE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"],\n              },\n              {\n                target: \"idle\",\n                actions: [\"invokeOnClose\"],\n              },\n            ],\n            \"SWATCH_TRIGGER.CLICK\": [\n              {\n                guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n                actions: [\"setValue\", \"invokeOnClose\"],\n              },\n              {\n                guard: \"closeOnSelect\",\n                target: \"focused\",\n                actions: [\"setValue\", \"invokeOnClose\", \"setReturnFocus\"],\n              },\n              {\n                actions: [\"setValue\"],\n              },\n            ],\n          },\n        },\n\n        \"open:dragging\": {\n          tags: [\"open\"],\n          exit: [\"clearActiveChannel\"],\n          activities: [\"trackPointerMove\", \"disableTextSelection\", \"trackPositioning\", \"trackDismissableElement\"],\n          on: {\n            \"CONTROLLED.CLOSE\": [\n              {\n                guard: \"shouldRestoreFocus\",\n                target: \"focused\",\n                actions: [\"setReturnFocus\"],\n              },\n              {\n                target: \"idle\",\n              },\n            ],\n            \"AREA.POINTER_MOVE\": {\n              actions: [\"setAreaColorFromPoint\", \"focusAreaThumb\"],\n            },\n            \"AREA.POINTER_UP\": {\n              target: \"open\",\n              actions: [\"invokeOnChangeEnd\"],\n            },\n            \"CHANNEL_SLIDER.POINTER_MOVE\": {\n              actions: [\"setChannelColorFromPoint\", \"focusChannelThumb\"],\n            },\n            \"CHANNEL_SLIDER.POINTER_UP\": {\n              target: \"open\",\n              actions: [\"invokeOnChangeEnd\"],\n            },\n            INTERACT_OUTSIDE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"],\n              },\n              {\n                guard: \"shouldRestoreFocus\",\n                target: \"focused\",\n                actions: [\"invokeOnClose\", \"setReturnFocus\"],\n              },\n              {\n                target: \"idle\",\n                actions: [\"invokeOnClose\"],\n              },\n            ],\n            CLOSE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"],\n              },\n              {\n                target: \"idle\",\n                actions: [\"invokeOnClose\"],\n              },\n            ],\n          },\n        },\n      },\n    },\n    {\n      guards: {\n        closeOnSelect: (ctx) => !!ctx.closeOnSelect,\n        isOpenControlled: (ctx) => !!ctx[\"open.controlled\"],\n        shouldRestoreFocus: (ctx) => !!ctx.restoreFocus,\n      },\n      activities: {\n        trackPositioning(ctx) {\n          ctx.currentPlacement = ctx.positioning.placement\n          const anchorEl = dom.getTriggerEl(ctx)\n          const getPositionerEl = () => dom.getPositionerEl(ctx)\n          return getPlacement(anchorEl, getPositionerEl, {\n            ...ctx.positioning,\n            defer: true,\n            onComplete(data) {\n              ctx.currentPlacement = data.placement\n            },\n          })\n        },\n        trackDismissableElement(ctx, _evt, { send }) {\n          const getContentEl = () => dom.getContentEl(ctx)\n          return trackDismissableElement(getContentEl, {\n            exclude: dom.getTriggerEl(ctx),\n            defer: true,\n            onInteractOutside(event) {\n              ctx.onInteractOutside?.(event)\n              if (event.defaultPrevented) return\n              ctx.restoreFocus = !(event.detail.focusable || event.detail.contextmenu)\n            },\n            onPointerDownOutside: ctx.onPointerDownOutside,\n            onFocusOutside: ctx.onFocusOutside,\n            onDismiss() {\n              send({ type: \"INTERACT_OUTSIDE\" })\n            },\n          })\n        },\n        trackFormControl(ctx, _evt, { send, initialContext }) {\n          const inputEl = dom.getHiddenInputEl(ctx)\n          return trackFormControl(inputEl, {\n            onFieldsetDisabledChange(disabled) {\n              ctx.fieldsetDisabled = disabled\n            },\n            onFormReset() {\n              send({ type: \"VALUE.SET\", value: initialContext.value, src: \"form.reset\" })\n            },\n          })\n        },\n        trackPointerMove(ctx, evt, { send }) {\n          return trackPointerMove(dom.getDoc(ctx), {\n            onPointerMove({ point }) {\n              const type = ctx.activeId === \"area\" ? \"AREA.POINTER_MOVE\" : \"CHANNEL_SLIDER.POINTER_MOVE\"\n              send({ type, point, format: evt.format })\n            },\n            onPointerUp() {\n              const type = ctx.activeId === \"area\" ? \"AREA.POINTER_UP\" : \"CHANNEL_SLIDER.POINTER_UP\"\n              send({ type })\n            },\n          })\n        },\n        disableTextSelection(ctx) {\n          return disableTextSelection({ doc: dom.getDoc(ctx), target: dom.getContentEl(ctx) })\n        },\n      },\n      actions: {\n        openEyeDropper(ctx) {\n          const isSupported = \"EyeDropper\" in dom.getWin(ctx)\n          if (!isSupported) return\n          const win = dom.getWin(ctx)\n          const picker = new win.EyeDropper()\n          picker\n            .open()\n            .then(({ sRGBHex }) => {\n              const format = ctx.value.getFormat()\n              const color = parseColor(sRGBHex).toFormat(format) as Color\n              set.value(ctx, color)\n              ctx.onValueChangeEnd?.({ value: ctx.value, valueAsString: ctx.valueAsString })\n            })\n            .catch(() => void 0)\n        },\n        setActiveChannel(ctx, evt) {\n          ctx.activeId = evt.id\n          if (evt.channel) ctx.activeChannel = evt.channel\n          if (evt.orientation) ctx.activeOrientation = evt.orientation\n        },\n        clearActiveChannel(ctx) {\n          ctx.activeChannel = null\n          ctx.activeId = null\n          ctx.activeOrientation = null\n        },\n        setAreaColorFromPoint(ctx, evt) {\n          const normalizedValue = evt.format ? ctx.value.toFormat(evt.format) : ctx.areaValue\n          const { xChannel, yChannel } = evt.channel || ctx.activeChannel\n\n          const percent = dom.getAreaValueFromPoint(ctx, evt.point)\n          if (!percent) return\n\n          const xValue = normalizedValue.getChannelPercentValue(xChannel, percent.x)\n          const yValue = normalizedValue.getChannelPercentValue(yChannel, 1 - percent.y)\n\n          const color = normalizedValue.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue)\n          set.value(ctx, color)\n        },\n        setChannelColorFromPoint(ctx, evt) {\n          const channel = evt.channel || ctx.activeId\n          const normalizedValue = evt.format ? ctx.value.toFormat(evt.format) : ctx.areaValue\n\n          const percent = dom.getChannelSliderValueFromPoint(ctx, evt.point, channel)\n          if (!percent) return\n\n          const orientation = ctx.activeOrientation || \"horizontal\"\n          const channelPercent = orientation === \"horizontal\" ? percent.x : percent.y\n\n          const value = normalizedValue.getChannelPercentValue(channel, channelPercent)\n          const color = normalizedValue.withChannelValue(channel, value)\n          set.value(ctx, color)\n        },\n        setValue(ctx, evt) {\n          set.value(ctx, evt.value)\n        },\n        setFormat(ctx, evt) {\n          set.format(ctx, evt.format)\n        },\n        syncInputElements(ctx) {\n          sync.inputs(ctx)\n        },\n        invokeOnChangeEnd(ctx) {\n          invoke.changeEnd(ctx)\n        },\n        setChannelColorFromInput(ctx, evt) {\n          const { channel, isTextField, value } = evt\n          const currentAlpha = ctx.value.getChannelValue(\"alpha\")\n\n          // handle other text channels\n          let color: Color\n\n          // handle alpha channel\n          if (channel === \"alpha\") {\n            //\n            let valueAsNumber = parseFloat(value)\n            valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber\n            color = ctx.value.withChannelValue(\"alpha\", valueAsNumber)\n            //\n          } else if (isTextField) {\n            //\n            color = tryCatch(\n              () => parse(value).withChannelValue(\"alpha\", currentAlpha),\n              () => ctx.value,\n            )\n            //\n          } else {\n            //\n            const current = ctx.value.toFormat(ctx.format)\n            const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value\n            color = current.withChannelValue(channel, valueAsNumber)\n            //\n          }\n\n          // sync channel input value immediately (in event user types native css color, we need to convert it to the current channel format)\n          sync.inputs(ctx, color)\n\n          // set new color\n          set.value(ctx, color)\n        },\n        incrementChannel(ctx, evt) {\n          const color = ctx.value.incrementChannel(evt.channel, evt.step)\n          set.value(ctx, color)\n        },\n        decrementChannel(ctx, evt) {\n          const color = ctx.value.decrementChannel(evt.channel, evt.step)\n          set.value(ctx, color)\n        },\n        incrementAreaXChannel(ctx, evt) {\n          const { xChannel } = evt.channel\n          const color = ctx.areaValue.incrementChannel(xChannel, evt.step)\n          set.value(ctx, color)\n        },\n        decrementAreaXChannel(ctx, evt) {\n          const { xChannel } = evt.channel\n          const color = ctx.areaValue.decrementChannel(xChannel, evt.step)\n          set.value(ctx, color)\n        },\n        incrementAreaYChannel(ctx, evt) {\n          const { yChannel } = evt.channel\n          const color = ctx.areaValue.incrementChannel(yChannel, evt.step)\n          set.value(ctx, color)\n        },\n        decrementAreaYChannel(ctx, evt) {\n          const { yChannel } = evt.channel\n          const color = ctx.areaValue.decrementChannel(yChannel, evt.step)\n          set.value(ctx, color)\n        },\n        setChannelToMax(ctx, evt) {\n          const range = ctx.value.getChannelRange(evt.channel)\n          const color = ctx.value.withChannelValue(evt.channel, range.maxValue)\n          set.value(ctx, color)\n        },\n        setChannelToMin(ctx, evt) {\n          const range = ctx.value.getChannelRange(evt.channel)\n          const color = ctx.value.withChannelValue(evt.channel, range.minValue)\n          set.value(ctx, color)\n        },\n        focusAreaThumb(ctx) {\n          raf(() => {\n            dom.getAreaThumbEl(ctx)?.focus({ preventScroll: true })\n          })\n        },\n        focusChannelThumb(ctx, evt) {\n          raf(() => {\n            dom.getChannelSliderThumbEl(ctx, evt.channel)?.focus({ preventScroll: true })\n          })\n        },\n        setInitialFocus(ctx) {\n          raf(() => {\n            const element = getInitialFocus({\n              root: dom.getContentEl(ctx),\n              getInitialEl: ctx.initialFocusEl,\n            })\n            element?.focus({ preventScroll: true })\n          })\n        },\n        setReturnFocus(ctx) {\n          raf(() => {\n            dom.getTriggerEl(ctx)?.focus({ preventScroll: true })\n          })\n        },\n        syncFormatSelectElement(ctx) {\n          sync.formatSelect(ctx)\n        },\n        invokeOnOpen(ctx) {\n          ctx.onOpenChange?.({ open: true })\n        },\n        invokeOnClose(ctx) {\n          ctx.onOpenChange?.({ open: false })\n        },\n        toggleVisibility(ctx, evt, { send }) {\n          send({ type: ctx.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\", previousEvent: evt })\n        },\n      },\n      compareFns: {\n        value: (a, b) => a.isEqual(b),\n      },\n    },\n  )\n}\n\nconst sync = {\n  // sync channel inputs\n  inputs(ctx: MachineContext, color?: Color) {\n    const channelInputs = dom.getChannelInputEls(ctx)\n    raf(() => {\n      channelInputs.forEach((inputEl) => {\n        const channel = inputEl.dataset.channel as ExtendedColorChannel | null\n        dom.setValue(inputEl, getChannelValue(color || ctx.value, channel))\n      })\n    })\n  },\n  // sync format select\n  formatSelect(ctx: MachineContext) {\n    const selectEl = dom.getFormatSelectEl(ctx)\n    raf(() => {\n      dom.setValue(selectEl, ctx.format)\n    })\n  },\n}\n\nconst invoke = {\n  changeEnd(ctx: MachineContext) {\n    const value = ctx.value.toFormat(ctx.format)\n    ctx.onValueChangeEnd?.({\n      value,\n      valueAsString: ctx.valueAsString,\n    })\n  },\n  change(ctx: MachineContext) {\n    const value = ctx.value.toFormat(ctx.format)\n    ctx.onValueChange?.({\n      value,\n      valueAsString: ctx.valueAsString,\n    })\n\n    dispatchInputValueEvent(dom.getHiddenInputEl(ctx), { value: ctx.valueAsString })\n  },\n  formatChange(ctx: MachineContext) {\n    ctx.onFormatChange?.({ format: ctx.format })\n  },\n}\n\nconst set = {\n  value(ctx: MachineContext, color: Color | ColorType | undefined) {\n    if (!color || ctx.value.isEqual(color)) return\n    ctx.value = color\n    invoke.change(ctx)\n  },\n  format(ctx: MachineContext, format: ColorFormat) {\n    if (ctx.format === format) return\n    ctx.format = format\n    invoke.formatChange(ctx)\n  },\n}\n","import { parseColor, type Color } from \"@zag-js/color-utils\"\n\nexport const parse = (colorString: string): Color => {\n  return parseColor(colorString)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}