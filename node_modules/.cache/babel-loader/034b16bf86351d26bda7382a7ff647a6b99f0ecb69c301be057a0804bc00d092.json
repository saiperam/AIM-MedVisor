{"ast":null,"code":"// src/carousel.anatomy.ts\nimport { createAnatomy } from \"@zag-js/anatomy\";\nvar anatomy = createAnatomy(\"carousel\").parts(\"root\", \"viewport\", \"itemGroup\", \"item\", \"nextTrigger\", \"prevTrigger\", \"indicatorGroup\", \"indicator\");\nvar parts = anatomy.build();\n\n// src/carousel.connect.ts\nimport { dataAttr, isDom } from \"@zag-js/dom-query\";\n\n// src/carousel.dom.ts\nimport { createScope, queryAll } from \"@zag-js/dom-query\";\nvar dom = createScope({\n  getRootId: ctx => ctx.ids?.root ?? `carousel:${ctx.id}`,\n  getViewportId: ctx => ctx.ids?.viewport ?? `carousel:${ctx.id}:viewport`,\n  getItemId: (ctx, index) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`,\n  getItemGroupId: ctx => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`,\n  getNextTriggerId: ctx => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`,\n  getPrevTriggerId: ctx => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`,\n  getIndicatorGroupId: ctx => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`,\n  getIndicatorId: (ctx, index) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getViewportEl: ctx => dom.getById(ctx, dom.getViewportId(ctx)),\n  getSlideGroupEl: ctx => dom.getById(ctx, dom.getItemGroupId(ctx)),\n  getSlideEls: ctx => queryAll(dom.getSlideGroupEl(ctx), `[data-part=item]`)\n});\n\n// src/utils/get-limit.ts\nfunction getLimit(min, max) {\n  const length = Math.abs(min - max);\n  function reachedMin(n) {\n    return n < min;\n  }\n  function reachedMax(n) {\n    return n > max;\n  }\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n  function constrain(n) {\n    if (!reachedAny(n)) return n;\n    return reachedMin(n) ? min : max;\n  }\n  function removeOffset(n) {\n    if (!length) return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n  return {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset\n  };\n}\n\n// src/utils/get-alignment.ts\nimport { isNumber } from \"@zag-js/utils\";\nvar getAlignment = (align, containerSize) => {\n  const predefined = {\n    start,\n    center,\n    end\n  };\n  function start() {\n    return 0;\n  }\n  function center(n) {\n    return end(n) / 2;\n  }\n  function end(n) {\n    return containerSize - n;\n  }\n  function percent() {\n    return containerSize * Number(align);\n  }\n  return n => {\n    if (isNumber(align)) return percent();\n    return predefined[align](n);\n  };\n};\n\n// src/utils/get-slide-groups.ts\nimport { isNumber as isNumber2 } from \"@zag-js/utils\";\nfunction getSlidesToScroll(containerSize, slideSizesWithGaps, slidesPerView) {\n  function byNumber(array, groupSize) {\n    return Array.from(array.keys()).filter(i => i % groupSize === 0).map(i => array.slice(i, i + groupSize));\n  }\n  function bySize(array) {\n    return Array.from(array.keys()).reduce((groups, i) => {\n      const chunk = slideSizesWithGaps.slice(groups.at(-1), i + 1);\n      const chunkSize = chunk.reduce((a, s) => a + s, 0);\n      return !i || chunkSize > containerSize ? groups.concat(i) : groups;\n    }, []).map((start, i, groups) => array.slice(start, groups[i + 1]));\n  }\n  return function groupSlides(array) {\n    return isNumber2(slidesPerView) ? byNumber(array, slidesPerView) : bySize(array);\n  };\n}\n\n// src/utils/get-slide-sizes.ts\nfunction getSlideSizes(ctx) {\n  const startGap = measureStartGap();\n  function measureStartGap() {\n    if (!ctx.containerRect) return 0;\n    const slideRect = ctx.slideRects[0];\n    return Math.abs(ctx.containerRect[ctx.startEdge] - slideRect[ctx.startEdge]);\n  }\n  function measureWithGaps() {\n    return ctx.slideRects.map((rect, index, rects) => {\n      const isFirst = !index;\n      if (isFirst) return Math.abs(slideSizes[index] + startGap);\n      const isLast = index === rects.length - 1;\n      if (isLast) return Math.abs(slideSizes[index]);\n      return Math.abs(rects[index + 1][ctx.startEdge] - rect[ctx.startEdge]);\n    });\n  }\n  const slideSizes = ctx.slideRects.map(slideRect => {\n    return ctx.isVertical ? slideRect.height : slideRect.width;\n  });\n  const slideSizesWithGaps = measureWithGaps();\n  return {\n    slideSizes,\n    slideSizesWithGaps\n  };\n}\n\n// src/utils/get-scroll-snaps.ts\nvar arrayLast = array => array[arrayLastIndex(array)];\nvar arrayLastIndex = array => Math.max(0, array.length - 1);\nfunction getScrollSnaps(ctx) {\n  const {\n    slideSizes,\n    slideSizesWithGaps\n  } = getSlideSizes(ctx);\n  const groupSlides = getSlidesToScroll(ctx.containerSize, slideSizesWithGaps, ctx.slidesPerView);\n  function measureSizes() {\n    return groupSlides(ctx.slideRects).map(rects => arrayLast(rects)[ctx.endEdge] - rects[0][ctx.startEdge]).map(Math.abs);\n  }\n  function measureUnaligned() {\n    return ctx.slideRects.map(slideRect => ctx.containerRect[ctx.startEdge] - slideRect[ctx.startEdge]).map(snap => -Math.abs(snap));\n  }\n  function measureAligned() {\n    const measureFn = getAlignment(ctx.align, ctx.containerSize);\n    const alignments = measureSizes().map(measureFn);\n    return groupSlides(snaps).map(snap => snap[0]).map((snap, index) => snap + alignments[index]);\n  }\n  const snaps = measureUnaligned();\n  const snapsAligned = measureAligned();\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  const scrollLimit = getLimit(snaps[snaps.length - 1], snaps[0]);\n  const scrollProgress = (snapsAligned[ctx.index] - scrollLimit.max) / -scrollLimit.length;\n  return {\n    snaps,\n    snapsAligned,\n    slideSizes,\n    slideSizesWithGaps,\n    contentSize,\n    scrollLimit,\n    scrollProgress: Math.abs(scrollProgress)\n  };\n}\n\n// src/utils/get-slide-in-view.ts\nvar slideThreshold = 0;\nfunction getSlidesInView(ctx) {\n  const roundingSafety = 0.5;\n  const slideOffsets = [0];\n  const {\n    snaps,\n    slideSizes,\n    scrollLimit\n  } = getScrollSnaps(ctx);\n  const slideThresholds = slideSizes.map(slideSize => {\n    const thresholdLimit = getLimit(roundingSafety, slideSize - roundingSafety);\n    return thresholdLimit.constrain(slideSize * slideThreshold);\n  });\n  const slideBounds = slideOffsets.reduce((acc, offset) => {\n    const bounds = snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + slideThresholds[index] + offset,\n      end: snap + ctx.containerSize - slideThresholds[index] + offset,\n      index\n    }));\n    return acc.concat(bounds);\n  }, []);\n  return location => {\n    const loc = scrollLimit.constrain(location);\n    return slideBounds.reduce((list, bound) => {\n      const {\n        index,\n        start,\n        end\n      } = bound;\n      const inList = list.includes(index);\n      const inView = start < loc && end > loc;\n      return !inList && inView ? list.concat([index]) : list;\n    }, []);\n  };\n}\n\n// src/carousel.connect.ts\nfunction connect(state, send, normalize) {\n  const canScrollNext = state.context.canScrollNext;\n  const canScrollPrev = state.context.canScrollPrev;\n  const horizontal = state.context.isHorizontal;\n  const autoPlaying = state.matches(\"autoplay\");\n  const activeSnap = state.context.scrollSnaps[state.context.index];\n  const slidesInView = isDom() ? getSlidesInView(state.context)(activeSnap) : [];\n  function getItemState(props2) {\n    return {\n      valueText: `Slide ${props2.index + 1}`,\n      current: props2.index === state.context.index,\n      next: props2.index === state.context.index + 1,\n      previous: props2.index === state.context.index - 1,\n      inView: slidesInView.includes(props2.index)\n    };\n  }\n  return {\n    index: state.context.index,\n    scrollProgress: state.context.scrollProgress,\n    autoPlaying,\n    canScrollNext,\n    canScrollPrev,\n    scrollTo(index, jump) {\n      send({\n        type: \"GOTO\",\n        index,\n        jump\n      });\n    },\n    scrollToNext() {\n      send(\"NEXT\");\n    },\n    scrollToPrevious() {\n      send(\"PREV\");\n    },\n    getItemState,\n    play() {\n      send(\"PLAY\");\n    },\n    pause() {\n      send(\"PAUSE\");\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: dom.getRootId(state.context),\n        role: \"region\",\n        \"aria-roledescription\": \"carousel\",\n        \"data-orientation\": state.context.orientation,\n        dir: state.context.dir,\n        \"aria-label\": \"Carousel\",\n        style: {\n          \"--slide-spacing\": state.context.spacing,\n          \"--slide-size\": `calc(100% / ${state.context.slidesPerView} - var(--slide-spacing))`\n        }\n      });\n    },\n    getViewportProps() {\n      return normalize.element({\n        ...parts.viewport.attrs,\n        dir: state.context.dir,\n        id: dom.getViewportId(state.context),\n        \"data-orientation\": state.context.orientation\n      });\n    },\n    getItemGroupProps() {\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        id: dom.getItemGroupId(state.context),\n        \"data-orientation\": state.context.orientation,\n        dir: state.context.dir,\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          [horizontal ? \"height\" : \"width\"]: \"auto\",\n          gap: \"var(--slide-spacing)\",\n          transform: state.context.translateValue,\n          transitionProperty: \"transform\",\n          willChange: \"transform\",\n          transitionTimingFunction: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n          transitionDuration: \"0.3s\"\n        }\n      });\n    },\n    getItemProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.item.attrs,\n        id: dom.getItemId(state.context, props2.index),\n        dir: state.context.dir,\n        \"data-current\": dataAttr(itemState.current),\n        \"data-inview\": dataAttr(itemState.inView),\n        role: \"group\",\n        \"aria-roledescription\": \"slide\",\n        \"data-orientation\": state.context.orientation,\n        \"aria-label\": itemState.valueText,\n        style: {\n          position: \"relative\",\n          flex: \"0 0 var(--slide-size)\",\n          [horizontal ? \"minWidth\" : \"minHeight\"]: \"0px\"\n        }\n      });\n    },\n    getPrevTriggerProps() {\n      return normalize.button({\n        ...parts.prevTrigger.attrs,\n        id: dom.getPrevTriggerId(state.context),\n        type: \"button\",\n        tabIndex: -1,\n        disabled: !canScrollPrev,\n        dir: state.context.dir,\n        \"aria-label\": \"Previous Slide\",\n        \"data-orientation\": state.context.orientation,\n        \"aria-controls\": dom.getItemGroupId(state.context),\n        onClick() {\n          send(\"PREV\");\n        }\n      });\n    },\n    getNextTriggerProps() {\n      return normalize.button({\n        ...parts.nextTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getNextTriggerId(state.context),\n        type: \"button\",\n        tabIndex: -1,\n        \"aria-label\": \"Next Slide\",\n        \"data-orientation\": state.context.orientation,\n        \"aria-controls\": dom.getItemGroupId(state.context),\n        disabled: !canScrollNext,\n        onClick() {\n          send(\"NEXT\");\n        }\n      });\n    },\n    getIndicatorGroupProps() {\n      return normalize.element({\n        ...parts.indicatorGroup.attrs,\n        dir: state.context.dir,\n        id: dom.getIndicatorGroupId(state.context),\n        \"data-orientation\": state.context.orientation\n      });\n    },\n    getIndicatorProps(props2) {\n      return normalize.button({\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        id: dom.getIndicatorId(state.context, props2.index),\n        type: \"button\",\n        \"data-orientation\": state.context.orientation,\n        \"data-index\": props2.index,\n        \"data-readonly\": dataAttr(props2.readOnly),\n        \"data-current\": dataAttr(props2.index === state.context.index),\n        onClick() {\n          if (props2.readOnly) return;\n          send({\n            type: \"GOTO\",\n            index: props2.index\n          });\n        }\n      });\n    }\n  };\n}\n\n// src/carousel.machine.ts\nimport { createMachine, ref } from \"@zag-js/core\";\nimport { compact, isEqual, nextIndex, prevIndex } from \"@zag-js/utils\";\nfunction machine(userContext) {\n  const ctx = compact(userContext);\n  return createMachine({\n    id: \"carousel\",\n    initial: \"idle\",\n    context: {\n      index: 0,\n      orientation: \"horizontal\",\n      align: \"start\",\n      loop: false,\n      slidesPerView: 1,\n      spacing: \"0px\",\n      ...ctx,\n      scrollSnaps: [],\n      scrollProgress: 0,\n      containerSize: 0,\n      slideRects: []\n    },\n    watch: {\n      index: [\"setScrollSnaps\"]\n    },\n    on: {\n      NEXT: {\n        actions: [\"scrollToNext\"]\n      },\n      PREV: {\n        actions: [\"scrollToPrev\"]\n      },\n      GOTO: {\n        actions: [\"scrollTo\"]\n      },\n      MEASURE_DOM: {\n        actions: [\"measureElements\", \"setScrollSnaps\"]\n      },\n      PLAY: \"autoplay\"\n    },\n    states: {\n      idle: {\n        on: {\n          POINTER_DOWN: \"dragging\"\n        }\n      },\n      autoplay: {\n        activities: [\"trackDocumentVisibility\"],\n        every: {\n          2e3: [\"scrollToNext\"]\n        },\n        on: {\n          PAUSE: \"idle\"\n        }\n      },\n      dragging: {\n        on: {\n          POINTER_UP: \"idle\",\n          POINTER_MOVE: {\n            actions: [\"setScrollSnaps\"]\n          }\n        }\n      }\n    },\n    activities: [\"trackContainerResize\", \"trackSlideMutation\"],\n    entry: [\"measureElements\", \"setScrollSnaps\"],\n    computed: {\n      isRtl: ctx2 => ctx2.dir === \"rtl\",\n      isHorizontal: ctx2 => ctx2.orientation === \"horizontal\",\n      isVertical: ctx2 => ctx2.orientation === \"vertical\",\n      canScrollNext: ctx2 => ctx2.loop || ctx2.index < ctx2.scrollSnaps.length - 1,\n      canScrollPrev: ctx2 => ctx2.loop || ctx2.index > 0,\n      startEdge(ctx2) {\n        if (ctx2.isVertical) return \"top\";\n        return ctx2.isRtl ? \"right\" : \"left\";\n      },\n      endEdge(ctx2) {\n        if (ctx2.isVertical) return \"bottom\";\n        return ctx2.isRtl ? \"left\" : \"right\";\n      },\n      translateValue: ctx2 => {\n        const scrollSnap = ctx2.scrollSnaps[ctx2.index];\n        return ctx2.isHorizontal ? `translate3d(${scrollSnap}px, 0, 0)` : `translate3d(0, ${scrollSnap}px, 0)`;\n      }\n    }\n  }, {\n    activities: {\n      trackSlideMutation(ctx2, _evt, {\n        send\n      }) {\n        const slideGroupEl = dom.getSlideGroupEl(ctx2);\n        if (!slideGroupEl) return;\n        const win = dom.getWin(ctx2);\n        const observer = new win.MutationObserver(() => {\n          send({\n            type: \"MEASURE_DOM\",\n            src: \"mutation\"\n          });\n        });\n        observer.observe(slideGroupEl, {\n          childList: true\n        });\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackContainerResize(ctx2, _evt, {\n        send\n      }) {\n        const slideGroupEl = dom.getSlideGroupEl(ctx2);\n        if (!slideGroupEl) return;\n        const win = dom.getWin(ctx2);\n        const observer = new win.ResizeObserver(entries => {\n          entries.forEach(entry => {\n            if (entry.target === slideGroupEl) {\n              send({\n                type: \"MEASURE_DOM\",\n                src: \"resize\"\n              });\n            }\n          });\n        });\n        observer.observe(slideGroupEl);\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackDocumentVisibility(ctx2, _evt, {\n        send\n      }) {\n        const doc = dom.getDoc(ctx2);\n        const onVisibilityChange = () => {\n          if (doc.visibilityState !== \"visible\") {\n            send({\n              type: \"PAUSE\",\n              src: \"document-hidden\"\n            });\n          }\n        };\n        doc.addEventListener(\"visibilitychange\", onVisibilityChange);\n        return () => {\n          doc.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        };\n      }\n    },\n    guards: {\n      loop: ctx2 => ctx2.loop,\n      isLastSlide: ctx2 => ctx2.index === ctx2.scrollSnaps.length - 1,\n      isFirstSlide: ctx2 => ctx2.index === 0\n    },\n    actions: {\n      scrollToNext(ctx2) {\n        const index = nextIndex(ctx2.scrollSnaps, ctx2.index);\n        set.index(ctx2, index);\n      },\n      scrollToPrev(ctx2) {\n        const index = prevIndex(ctx2.scrollSnaps, ctx2.index);\n        set.index(ctx2, index);\n      },\n      setScrollSnaps(ctx2) {\n        const {\n          snapsAligned,\n          scrollProgress\n        } = getScrollSnaps(ctx2);\n        ctx2.scrollSnaps = snapsAligned;\n        ctx2.scrollProgress = scrollProgress;\n      },\n      scrollTo(ctx2, evt) {\n        const index = Math.max(0, Math.min(evt.index, ctx2.scrollSnaps.length - 1));\n        set.index(ctx2, index);\n      },\n      measureElements\n    }\n  });\n}\nvar measureElements = ctx => {\n  const slideGroupEl = dom.getSlideGroupEl(ctx);\n  if (!slideGroupEl) return;\n  ctx.containerRect = ref(slideGroupEl.getBoundingClientRect());\n  ctx.containerSize = ctx.isHorizontal ? ctx.containerRect.width : ctx.containerRect.height;\n  ctx.slideRects = ref(dom.getSlideEls(ctx).map(slide => slide.getBoundingClientRect()));\n};\nvar invoke = {\n  change: ctx => {\n    ctx.onIndexChange?.({\n      index: ctx.index\n    });\n  }\n};\nvar set = {\n  index: (ctx, index) => {\n    if (isEqual(ctx.index, index)) return;\n    ctx.index = index;\n    invoke.change(ctx);\n  }\n};\n\n// src/carousel.props.ts\nimport { createProps } from \"@zag-js/types\";\nimport { createSplitProps } from \"@zag-js/utils\";\nvar props = createProps()([\"align\", \"dir\", \"getRootNode\", \"id\", \"ids\", \"index\", \"loop\", \"onIndexChange\", \"orientation\", \"slidesPerView\", \"spacing\"]);\nvar splitProps = createSplitProps(props);\nvar indicatorProps = createProps()([\"index\", \"readOnly\"]);\nvar splitIndicatorProps = createSplitProps(indicatorProps);\nexport { anatomy, connect, indicatorProps, machine, props, splitIndicatorProps, splitProps };","map":{"version":3,"names":["createAnatomy","anatomy","parts","build","dataAttr","isDom","createScope","queryAll","dom","getRootId","ctx","ids","root","id","getViewportId","viewport","getItemId","index","item","getItemGroupId","itemGroup","getNextTriggerId","nextTrigger","getPrevTriggerId","prevTrigger","getIndicatorGroupId","indicatorGroup","getIndicatorId","indicator","getRootEl","getById","getViewportEl","getSlideGroupEl","getSlideEls","getLimit","min","max","length","Math","abs","reachedMin","n","reachedMax","reachedAny","constrain","removeOffset","ceil","isNumber","getAlignment","align","containerSize","predefined","start","center","end","percent","Number","isNumber2","getSlidesToScroll","slideSizesWithGaps","slidesPerView","byNumber","array","groupSize","Array","from","keys","filter","i","map","slice","bySize","reduce","groups","chunk","at","chunkSize","a","s","concat","groupSlides","getSlideSizes","startGap","measureStartGap","containerRect","slideRect","slideRects","startEdge","measureWithGaps","rect","rects","isFirst","slideSizes","isLast","isVertical","height","width","arrayLast","arrayLastIndex","getScrollSnaps","measureSizes","endEdge","measureUnaligned","snap","measureAligned","measureFn","alignments","snaps","snapsAligned","contentSize","scrollLimit","scrollProgress","slideThreshold","getSlidesInView","roundingSafety","slideOffsets","slideThresholds","slideSize","thresholdLimit","slideBounds","acc","offset","bounds","location","loc","list","bound","inList","includes","inView","connect","state","send","normalize","canScrollNext","context","canScrollPrev","horizontal","isHorizontal","autoPlaying","matches","activeSnap","scrollSnaps","slidesInView","getItemState","props2","valueText","current","next","previous","scrollTo","jump","type","scrollToNext","scrollToPrevious","play","pause","getRootProps","element","attrs","role","orientation","dir","style","spacing","getViewportProps","getItemGroupProps","display","flexDirection","gap","transform","translateValue","transitionProperty","willChange","transitionTimingFunction","transitionDuration","getItemProps","itemState","position","flex","getPrevTriggerProps","button","tabIndex","disabled","onClick","getNextTriggerProps","getIndicatorGroupProps","getIndicatorProps","readOnly","createMachine","ref","compact","isEqual","nextIndex","prevIndex","machine","userContext","initial","loop","watch","on","NEXT","actions","PREV","GOTO","MEASURE_DOM","PLAY","states","idle","POINTER_DOWN","autoplay","activities","every","PAUSE","dragging","POINTER_UP","POINTER_MOVE","entry","computed","isRtl","ctx2","scrollSnap","trackSlideMutation","_evt","slideGroupEl","win","getWin","observer","MutationObserver","src","observe","childList","disconnect","trackContainerResize","ResizeObserver","entries","forEach","target","trackDocumentVisibility","doc","getDoc","onVisibilityChange","visibilityState","addEventListener","removeEventListener","guards","isLastSlide","isFirstSlide","set","scrollToPrev","setScrollSnaps","evt","measureElements","getBoundingClientRect","slide","invoke","change","onIndexChange","createProps","createSplitProps","props","splitProps","indicatorProps","splitIndicatorProps"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/carousel.anatomy.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/carousel.connect.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/carousel.dom.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/utils/get-limit.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/utils/get-alignment.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/utils/get-slide-groups.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/utils/get-slide-sizes.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/utils/get-scroll-snaps.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/utils/get-slide-in-view.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/carousel.machine.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/carousel/src/carousel.props.ts"],"sourcesContent":["import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"carousel\").parts(\n  \"root\",\n  \"viewport\",\n  \"itemGroup\",\n  \"item\",\n  \"nextTrigger\",\n  \"prevTrigger\",\n  \"indicatorGroup\",\n  \"indicator\",\n)\n\nexport const parts = anatomy.build()\n","import { dataAttr, isDom } from \"@zag-js/dom-query\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./carousel.anatomy\"\nimport { dom } from \"./carousel.dom\"\nimport type { ItemProps, ItemState, MachineApi, Send, State } from \"./carousel.types\"\nimport { getSlidesInView } from \"./utils/get-slide-in-view\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T> {\n  const canScrollNext = state.context.canScrollNext\n  const canScrollPrev = state.context.canScrollPrev\n  const horizontal = state.context.isHorizontal\n  const autoPlaying = state.matches(\"autoplay\")\n\n  const activeSnap = state.context.scrollSnaps[state.context.index]\n  const slidesInView = isDom() ? getSlidesInView(state.context)(activeSnap) : []\n\n  function getItemState(props: ItemProps): ItemState {\n    return {\n      valueText: `Slide ${props.index + 1}`,\n      current: props.index === state.context.index,\n      next: props.index === state.context.index + 1,\n      previous: props.index === state.context.index - 1,\n      inView: slidesInView.includes(props.index),\n    }\n  }\n\n  return {\n    index: state.context.index,\n    scrollProgress: state.context.scrollProgress,\n    autoPlaying,\n    canScrollNext,\n    canScrollPrev,\n    scrollTo(index, jump) {\n      send({ type: \"GOTO\", index, jump })\n    },\n    scrollToNext() {\n      send(\"NEXT\")\n    },\n    scrollToPrevious() {\n      send(\"PREV\")\n    },\n    getItemState: getItemState,\n    play() {\n      send(\"PLAY\")\n    },\n    pause() {\n      send(\"PAUSE\")\n    },\n\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: dom.getRootId(state.context),\n        role: \"region\",\n        \"aria-roledescription\": \"carousel\",\n        \"data-orientation\": state.context.orientation,\n        dir: state.context.dir,\n        \"aria-label\": \"Carousel\",\n        style: {\n          \"--slide-spacing\": state.context.spacing,\n          \"--slide-size\": `calc(100% / ${state.context.slidesPerView} - var(--slide-spacing))`,\n        },\n      })\n    },\n\n    getViewportProps() {\n      return normalize.element({\n        ...parts.viewport.attrs,\n        dir: state.context.dir,\n        id: dom.getViewportId(state.context),\n        \"data-orientation\": state.context.orientation,\n      })\n    },\n\n    getItemGroupProps() {\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        id: dom.getItemGroupId(state.context),\n        \"data-orientation\": state.context.orientation,\n        dir: state.context.dir,\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          [horizontal ? \"height\" : \"width\"]: \"auto\",\n          gap: \"var(--slide-spacing)\",\n          transform: state.context.translateValue,\n          transitionProperty: \"transform\",\n          willChange: \"transform\",\n          transitionTimingFunction: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n          transitionDuration: \"0.3s\",\n        },\n      })\n    },\n\n    getItemProps(props) {\n      const itemState = getItemState(props)\n\n      return normalize.element({\n        ...parts.item.attrs,\n        id: dom.getItemId(state.context, props.index),\n        dir: state.context.dir,\n        \"data-current\": dataAttr(itemState.current),\n        \"data-inview\": dataAttr(itemState.inView),\n        role: \"group\",\n        \"aria-roledescription\": \"slide\",\n        \"data-orientation\": state.context.orientation,\n        \"aria-label\": itemState.valueText,\n        style: {\n          position: \"relative\",\n          flex: \"0 0 var(--slide-size)\",\n          [horizontal ? \"minWidth\" : \"minHeight\"]: \"0px\",\n        },\n      })\n    },\n\n    getPrevTriggerProps() {\n      return normalize.button({\n        ...parts.prevTrigger.attrs,\n        id: dom.getPrevTriggerId(state.context),\n        type: \"button\",\n        tabIndex: -1,\n        disabled: !canScrollPrev,\n        dir: state.context.dir,\n        \"aria-label\": \"Previous Slide\",\n        \"data-orientation\": state.context.orientation,\n        \"aria-controls\": dom.getItemGroupId(state.context),\n        onClick() {\n          send(\"PREV\")\n        },\n      })\n    },\n\n    getNextTriggerProps() {\n      return normalize.button({\n        ...parts.nextTrigger.attrs,\n        dir: state.context.dir,\n        id: dom.getNextTriggerId(state.context),\n        type: \"button\",\n        tabIndex: -1,\n        \"aria-label\": \"Next Slide\",\n        \"data-orientation\": state.context.orientation,\n        \"aria-controls\": dom.getItemGroupId(state.context),\n        disabled: !canScrollNext,\n        onClick() {\n          send(\"NEXT\")\n        },\n      })\n    },\n\n    getIndicatorGroupProps() {\n      return normalize.element({\n        ...parts.indicatorGroup.attrs,\n        dir: state.context.dir,\n        id: dom.getIndicatorGroupId(state.context),\n        \"data-orientation\": state.context.orientation,\n      })\n    },\n\n    getIndicatorProps(props) {\n      return normalize.button({\n        ...parts.indicator.attrs,\n        dir: state.context.dir,\n        id: dom.getIndicatorId(state.context, props.index),\n        type: \"button\",\n        \"data-orientation\": state.context.orientation,\n        \"data-index\": props.index,\n        \"data-readonly\": dataAttr(props.readOnly),\n        \"data-current\": dataAttr(props.index === state.context.index),\n        onClick() {\n          if (props.readOnly) return\n          send({ type: \"GOTO\", index: props.index })\n        },\n      })\n    },\n  }\n}\n","import { createScope, queryAll } from \"@zag-js/dom-query\"\nimport type { MachineContext as Ctx } from \"./carousel.types\"\n\nexport const dom = createScope({\n  getRootId: (ctx: Ctx) => ctx.ids?.root ?? `carousel:${ctx.id}`,\n  getViewportId: (ctx: Ctx) => ctx.ids?.viewport ?? `carousel:${ctx.id}:viewport`,\n  getItemId: (ctx: Ctx, index: number) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`,\n  getItemGroupId: (ctx: Ctx) => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`,\n  getNextTriggerId: (ctx: Ctx) => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`,\n  getPrevTriggerId: (ctx: Ctx) => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`,\n  getIndicatorGroupId: (ctx: Ctx) => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`,\n  getIndicatorId: (ctx: Ctx, index: number) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`,\n\n  getRootEl: (ctx: Ctx) => dom.getById(ctx, dom.getRootId(ctx)),\n  getViewportEl: (ctx: Ctx) => dom.getById(ctx, dom.getViewportId(ctx)),\n  getSlideGroupEl: (ctx: Ctx) => dom.getById(ctx, dom.getItemGroupId(ctx)),\n  getSlideEls: (ctx: Ctx) => queryAll(dom.getSlideGroupEl(ctx), `[data-part=item]`),\n})\n","export function getLimit(min: number, max: number) {\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  return {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n}\n","import { isNumber } from \"@zag-js/utils\"\n\nexport type AlignmentOptionType = \"start\" | \"center\" | \"end\" | number\n\nexport const getAlignment = (align: AlignmentOptionType, containerSize: number) => {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return containerSize - n\n  }\n\n  function percent(): number {\n    return containerSize * Number(align)\n  }\n\n  return (n: number) => {\n    if (isNumber(align)) return percent()\n    return predefined[align](n)\n  }\n}\n","import { isNumber } from \"@zag-js/utils\"\nimport type { MachineContext } from \"../carousel.types\"\n\nexport function getSlidesToScroll(\n  containerSize: number,\n  slideSizesWithGaps: number[],\n  slidesPerView: MachineContext[\"slidesPerView\"],\n) {\n  function byNumber<T>(array: T[], groupSize: number): T[][] {\n    return Array.from(array.keys())\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<T>(array: T[]): T[][] {\n    return Array.from(array.keys())\n      .reduce((groups: number[], i) => {\n        const chunk = slideSizesWithGaps.slice(groups.at(-1), i + 1)\n        const chunkSize = chunk.reduce((a, s) => a + s, 0)\n        return !i || chunkSize > containerSize ? groups.concat(i) : groups\n      }, [])\n      .map((start, i, groups) => array.slice(start, groups[i + 1]))\n  }\n\n  return function groupSlides<T>(array: T[]): T[][] {\n    return isNumber(slidesPerView) ? byNumber(array, slidesPerView) : bySize(array)\n  }\n}\n","import type { MachineContext } from \"../carousel.types\"\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function getSlideSizes(ctx: MachineContext): SlideSizesType {\n  const startGap = measureStartGap()\n\n  function measureStartGap(): number {\n    if (!ctx.containerRect) return 0\n    const slideRect = ctx.slideRects[0]\n    return Math.abs(ctx.containerRect[ctx.startEdge] - slideRect[ctx.startEdge])\n  }\n\n  function measureWithGaps(): number[] {\n    return ctx.slideRects.map((rect, index, rects) => {\n      const isFirst = !index\n      if (isFirst) return Math.abs(slideSizes[index] + startGap)\n\n      const isLast = index === rects.length - 1\n      if (isLast) return Math.abs(slideSizes[index])\n\n      return Math.abs(rects[index + 1][ctx.startEdge] - rect[ctx.startEdge])\n    })\n  }\n\n  const slideSizes = ctx.slideRects.map((slideRect) => {\n    return ctx.isVertical ? slideRect.height : slideRect.width\n  })\n  const slideSizesWithGaps = measureWithGaps()\n\n  return {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n}\n","import type { MachineContext } from \"../carousel.types\"\nimport { getAlignment } from \"./get-alignment\"\nimport { getLimit } from \"./get-limit\"\nimport { getSlidesToScroll } from \"./get-slide-groups\"\nimport { getSlideSizes } from \"./get-slide-sizes\"\n\nconst arrayLast = <T>(array: T[]): T => array[arrayLastIndex(array)]\nconst arrayLastIndex = <T>(array: T[]): number => Math.max(0, array.length - 1)\n\nexport function getScrollSnaps(ctx: MachineContext) {\n  const { slideSizes, slideSizesWithGaps } = getSlideSizes(ctx)\n\n  const groupSlides = getSlidesToScroll(ctx.containerSize!, slideSizesWithGaps, ctx.slidesPerView)\n\n  function measureSizes(): number[] {\n    return groupSlides(ctx.slideRects)\n      .map((rects) => arrayLast(rects)[ctx.endEdge] - rects[0][ctx.startEdge])\n      .map(Math.abs)\n  }\n\n  function measureUnaligned(): number[] {\n    return ctx.slideRects\n      .map((slideRect) => ctx.containerRect![ctx.startEdge] - slideRect[ctx.startEdge])\n      .map((snap) => -Math.abs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const measureFn = getAlignment(ctx.align, ctx.containerSize!)\n    const alignments = measureSizes().map(measureFn)\n\n    return groupSlides(snaps)\n      .map((snap) => snap[0])\n      .map((snap, index) => snap + alignments[index])\n  }\n\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n\n  const scrollLimit = getLimit(snaps[snaps.length - 1], snaps[0])\n  const scrollProgress = (snapsAligned[ctx.index] - scrollLimit.max) / -scrollLimit.length\n\n  return {\n    snaps,\n    snapsAligned,\n    slideSizes,\n    slideSizesWithGaps,\n    contentSize,\n    scrollLimit,\n    scrollProgress: Math.abs(scrollProgress),\n  }\n}\n","import type { MachineContext } from \"../carousel.types\"\nimport { getLimit } from \"./get-limit\"\nimport { getScrollSnaps } from \"./get-scroll-snaps\"\n\ntype Bound = {\n  start: number\n  end: number\n  index: number\n}\n\nconst slideThreshold = 0\n\nexport function getSlidesInView(ctx: MachineContext) {\n  const roundingSafety = 0.5\n  const slideOffsets = [0]\n\n  const { snaps, slideSizes, scrollLimit } = getScrollSnaps(ctx)\n\n  const slideThresholds = slideSizes.map((slideSize) => {\n    const thresholdLimit = getLimit(roundingSafety, slideSize - roundingSafety)\n    return thresholdLimit.constrain(slideSize * slideThreshold)\n  })\n\n  const slideBounds = slideOffsets.reduce((acc: Bound[], offset) => {\n    const bounds = snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + slideThresholds[index] + offset,\n      end: snap + ctx.containerSize - slideThresholds[index] + offset,\n      index,\n    }))\n    return acc.concat(bounds)\n  }, [])\n\n  return (location: number) => {\n    const loc = scrollLimit.constrain(location)\n    return slideBounds.reduce((list: number[], bound) => {\n      const { index, start, end } = bound\n      const inList = list.includes(index)\n      const inView = start < loc && end > loc\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n}\n","import { createMachine, ref } from \"@zag-js/core\"\nimport { compact, isEqual, nextIndex, prevIndex } from \"@zag-js/utils\"\nimport { dom } from \"./carousel.dom\"\nimport type { MachineContext, MachineState, UserDefinedContext } from \"./carousel.types\"\nimport { getScrollSnaps } from \"./utils/get-scroll-snaps\"\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"carousel\",\n      initial: \"idle\",\n      context: {\n        index: 0,\n        orientation: \"horizontal\",\n        align: \"start\",\n        loop: false,\n        slidesPerView: 1,\n        spacing: \"0px\",\n        ...ctx,\n        scrollSnaps: [],\n        scrollProgress: 0,\n        containerSize: 0,\n        slideRects: [],\n      },\n\n      watch: {\n        index: [\"setScrollSnaps\"],\n      },\n\n      on: {\n        NEXT: {\n          actions: [\"scrollToNext\"],\n        },\n        PREV: {\n          actions: [\"scrollToPrev\"],\n        },\n        GOTO: {\n          actions: [\"scrollTo\"],\n        },\n        MEASURE_DOM: {\n          actions: [\"measureElements\", \"setScrollSnaps\"],\n        },\n        PLAY: \"autoplay\",\n      },\n\n      states: {\n        idle: {\n          on: {\n            POINTER_DOWN: \"dragging\",\n          },\n        },\n        autoplay: {\n          activities: [\"trackDocumentVisibility\"],\n          every: {\n            2000: [\"scrollToNext\"],\n          },\n          on: {\n            PAUSE: \"idle\",\n          },\n        },\n        dragging: {\n          on: {\n            POINTER_UP: \"idle\",\n            POINTER_MOVE: {\n              actions: [\"setScrollSnaps\"],\n            },\n          },\n        },\n      },\n      activities: [\"trackContainerResize\", \"trackSlideMutation\"],\n      entry: [\"measureElements\", \"setScrollSnaps\"],\n      computed: {\n        isRtl: (ctx) => ctx.dir === \"rtl\",\n        isHorizontal: (ctx) => ctx.orientation === \"horizontal\",\n        isVertical: (ctx) => ctx.orientation === \"vertical\",\n        canScrollNext: (ctx) => ctx.loop || ctx.index < ctx.scrollSnaps.length - 1,\n        canScrollPrev: (ctx) => ctx.loop || ctx.index > 0,\n        startEdge(ctx) {\n          if (ctx.isVertical) return \"top\"\n          return ctx.isRtl ? \"right\" : \"left\"\n        },\n        endEdge(ctx) {\n          if (ctx.isVertical) return \"bottom\"\n          return ctx.isRtl ? \"left\" : \"right\"\n        },\n        translateValue: (ctx) => {\n          const scrollSnap = ctx.scrollSnaps[ctx.index]\n          return ctx.isHorizontal ? `translate3d(${scrollSnap}px, 0, 0)` : `translate3d(0, ${scrollSnap}px, 0)`\n        },\n      },\n    },\n    {\n      activities: {\n        trackSlideMutation(ctx, _evt, { send }) {\n          const slideGroupEl = dom.getSlideGroupEl(ctx)\n          if (!slideGroupEl) return\n          const win = dom.getWin(ctx)\n          const observer = new win.MutationObserver(() => {\n            send({ type: \"MEASURE_DOM\", src: \"mutation\" })\n          })\n          observer.observe(slideGroupEl, { childList: true })\n          return () => {\n            observer.disconnect()\n          }\n        },\n        trackContainerResize(ctx, _evt, { send }) {\n          const slideGroupEl = dom.getSlideGroupEl(ctx)\n          if (!slideGroupEl) return\n          const win = dom.getWin(ctx)\n          const observer = new win.ResizeObserver((entries) => {\n            entries.forEach((entry) => {\n              if (entry.target === slideGroupEl) {\n                send({ type: \"MEASURE_DOM\", src: \"resize\" })\n              }\n            })\n          })\n          observer.observe(slideGroupEl)\n          return () => {\n            observer.disconnect()\n          }\n        },\n        trackDocumentVisibility(ctx, _evt, { send }) {\n          const doc = dom.getDoc(ctx)\n          const onVisibilityChange = () => {\n            if (doc.visibilityState !== \"visible\") {\n              send({ type: \"PAUSE\", src: \"document-hidden\" })\n            }\n          }\n          doc.addEventListener(\"visibilitychange\", onVisibilityChange)\n          return () => {\n            doc.removeEventListener(\"visibilitychange\", onVisibilityChange)\n          }\n        },\n      },\n      guards: {\n        loop: (ctx) => ctx.loop,\n        isLastSlide: (ctx) => ctx.index === ctx.scrollSnaps.length - 1,\n        isFirstSlide: (ctx) => ctx.index === 0,\n      },\n      actions: {\n        scrollToNext(ctx) {\n          const index = nextIndex(ctx.scrollSnaps, ctx.index)\n          set.index(ctx, index)\n        },\n        scrollToPrev(ctx) {\n          const index = prevIndex(ctx.scrollSnaps, ctx.index)\n          set.index(ctx, index)\n        },\n        setScrollSnaps(ctx) {\n          const { snapsAligned, scrollProgress } = getScrollSnaps(ctx)\n          ctx.scrollSnaps = snapsAligned\n          ctx.scrollProgress = scrollProgress\n        },\n        scrollTo(ctx, evt) {\n          const index = Math.max(0, Math.min(evt.index, ctx.scrollSnaps.length - 1))\n          set.index(ctx, index)\n        },\n        measureElements,\n      },\n    },\n  )\n}\n\nconst measureElements = (ctx: MachineContext) => {\n  const slideGroupEl = dom.getSlideGroupEl(ctx)\n  if (!slideGroupEl) return\n  ctx.containerRect = ref(slideGroupEl.getBoundingClientRect())\n  ctx.containerSize = ctx.isHorizontal ? ctx.containerRect.width : ctx.containerRect.height\n  ctx.slideRects = ref(dom.getSlideEls(ctx).map((slide) => slide.getBoundingClientRect()))\n}\n\nconst invoke = {\n  change: (ctx: MachineContext) => {\n    ctx.onIndexChange?.({ index: ctx.index })\n  },\n}\n\nconst set = {\n  index: (ctx: MachineContext, index: number) => {\n    if (isEqual(ctx.index, index)) return\n    ctx.index = index\n    invoke.change(ctx)\n  },\n}\n","import { createProps } from \"@zag-js/types\"\nimport { createSplitProps } from \"@zag-js/utils\"\nimport type { IndicatorProps, UserDefinedContext } from \"./carousel.types\"\n\nexport const props = createProps<UserDefinedContext>()([\n  \"align\",\n  \"dir\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"index\",\n  \"loop\",\n  \"onIndexChange\",\n  \"orientation\",\n  \"slidesPerView\",\n  \"spacing\",\n])\nexport const splitProps = createSplitProps<Partial<UserDefinedContext>>(props)\n\nexport const indicatorProps = createProps<IndicatorProps>()([\"index\", \"readOnly\"])\nexport const splitIndicatorProps = createSplitProps<IndicatorProps>(indicatorProps)\n"],"mappings":";AAAA,SAASA,aAAA,QAAqB;AAEvB,IAAMC,OAAA,GAAUD,aAAA,CAAc,UAAU,EAAEE,KAAA,CAC/C,QACA,YACA,aACA,QACA,eACA,eACA,kBACA,WACF;AAEO,IAAMA,KAAA,GAAQD,OAAA,CAAQE,KAAA,CAAM;;;ACbnC,SAASC,QAAA,EAAUC,KAAA,QAAa;;;ACAhC,SAASC,WAAA,EAAaC,QAAA,QAAgB;AAG/B,IAAMC,GAAA,GAAMF,WAAA,CAAY;EAC7BG,SAAA,EAAYC,GAAA,IAAaA,GAAA,CAAIC,GAAA,EAAKC,IAAA,IAAQ,YAAYF,GAAA,CAAIG,EAAE;EAC5DC,aAAA,EAAgBJ,GAAA,IAAaA,GAAA,CAAIC,GAAA,EAAKI,QAAA,IAAY,YAAYL,GAAA,CAAIG,EAAE;EACpEG,SAAA,EAAWA,CAACN,GAAA,EAAUO,KAAA,KAAkBP,GAAA,CAAIC,GAAA,EAAKO,IAAA,GAAOD,KAAK,KAAK,YAAYP,GAAA,CAAIG,EAAE,SAASI,KAAK;EAClGE,cAAA,EAAiBT,GAAA,IAAaA,GAAA,CAAIC,GAAA,EAAKS,SAAA,IAAa,YAAYV,GAAA,CAAIG,EAAE;EACtEQ,gBAAA,EAAmBX,GAAA,IAAaA,GAAA,CAAIC,GAAA,EAAKW,WAAA,IAAe,YAAYZ,GAAA,CAAIG,EAAE;EAC1EU,gBAAA,EAAmBb,GAAA,IAAaA,GAAA,CAAIC,GAAA,EAAKa,WAAA,IAAe,YAAYd,GAAA,CAAIG,EAAE;EAC1EY,mBAAA,EAAsBf,GAAA,IAAaA,GAAA,CAAIC,GAAA,EAAKe,cAAA,IAAkB,YAAYhB,GAAA,CAAIG,EAAE;EAChFc,cAAA,EAAgBA,CAACjB,GAAA,EAAUO,KAAA,KAAkBP,GAAA,CAAIC,GAAA,EAAKiB,SAAA,GAAYX,KAAK,KAAK,YAAYP,GAAA,CAAIG,EAAE,cAAcI,KAAK;EAEjHY,SAAA,EAAYnB,GAAA,IAAaF,GAAA,CAAIsB,OAAA,CAAQpB,GAAA,EAAKF,GAAA,CAAIC,SAAA,CAAUC,GAAG,CAAC;EAC5DqB,aAAA,EAAgBrB,GAAA,IAAaF,GAAA,CAAIsB,OAAA,CAAQpB,GAAA,EAAKF,GAAA,CAAIM,aAAA,CAAcJ,GAAG,CAAC;EACpEsB,eAAA,EAAkBtB,GAAA,IAAaF,GAAA,CAAIsB,OAAA,CAAQpB,GAAA,EAAKF,GAAA,CAAIW,cAAA,CAAeT,GAAG,CAAC;EACvEuB,WAAA,EAAcvB,GAAA,IAAaH,QAAA,CAASC,GAAA,CAAIwB,eAAA,CAAgBtB,GAAG,GAAG,kBAAkB;AAClF,CAAC;;;ACjBM,SAASwB,SAASC,GAAA,EAAaC,GAAA,EAAa;EACjD,MAAMC,MAAA,GAASC,IAAA,CAAKC,GAAA,CAAIJ,GAAA,GAAMC,GAAG;EAEjC,SAASI,WAAWC,CAAA,EAAoB;IACtC,OAAOA,CAAA,GAAIN,GAAA;EACb;EAEA,SAASO,WAAWD,CAAA,EAAoB;IACtC,OAAOA,CAAA,GAAIL,GAAA;EACb;EAEA,SAASO,WAAWF,CAAA,EAAoB;IACtC,OAAOD,UAAA,CAAWC,CAAC,KAAKC,UAAA,CAAWD,CAAC;EACtC;EAEA,SAASG,UAAUH,CAAA,EAAmB;IACpC,IAAI,CAACE,UAAA,CAAWF,CAAC,GAAG,OAAOA,CAAA;IAC3B,OAAOD,UAAA,CAAWC,CAAC,IAAIN,GAAA,GAAMC,GAAA;EAC/B;EAEA,SAASS,aAAaJ,CAAA,EAAmB;IACvC,IAAI,CAACJ,MAAA,EAAQ,OAAOI,CAAA;IACpB,OAAOA,CAAA,GAAIJ,MAAA,GAASC,IAAA,CAAKQ,IAAA,EAAML,CAAA,GAAIL,GAAA,IAAOC,MAAM;EAClD;EAEA,OAAO;IACLA,MAAA;IACAD,GAAA;IACAD,GAAA;IACAS,SAAA;IACAD,UAAA;IACAD,UAAA;IACAF,UAAA;IACAK;EACF;AACF;;;ACnCA,SAASE,QAAA,QAAgB;AAIlB,IAAMC,YAAA,GAAeA,CAACC,KAAA,EAA4BC,aAAA,KAA0B;EACjF,MAAMC,UAAA,GAAa;IAAEC,KAAA;IAAOC,MAAA;IAAQC;EAAI;EAExC,SAASF,MAAA,EAAgB;IACvB,OAAO;EACT;EAEA,SAASC,OAAOZ,CAAA,EAAmB;IACjC,OAAOa,GAAA,CAAIb,CAAC,IAAI;EAClB;EAEA,SAASa,IAAIb,CAAA,EAAmB;IAC9B,OAAOS,aAAA,GAAgBT,CAAA;EACzB;EAEA,SAASc,QAAA,EAAkB;IACzB,OAAOL,aAAA,GAAgBM,MAAA,CAAOP,KAAK;EACrC;EAEA,OAAQR,CAAA,IAAc;IACpB,IAAIM,QAAA,CAASE,KAAK,GAAG,OAAOM,OAAA,CAAQ;IACpC,OAAOJ,UAAA,CAAWF,KAAK,EAAER,CAAC;EAC5B;AACF;;;AC3BA,SAASM,QAAA,IAAAU,SAAA,QAAgB;AAGlB,SAASC,kBACdR,aAAA,EACAS,kBAAA,EACAC,aAAA,EACA;EACA,SAASC,SAAYC,KAAA,EAAYC,SAAA,EAA0B;IACzD,OAAOC,KAAA,CAAMC,IAAA,CAAKH,KAAA,CAAMI,IAAA,CAAK,CAAC,EAC3BC,MAAA,CAAQC,CAAA,IAAMA,CAAA,GAAIL,SAAA,KAAc,CAAC,EACjCM,GAAA,CAAKD,CAAA,IAAMN,KAAA,CAAMQ,KAAA,CAAMF,CAAA,EAAGA,CAAA,GAAIL,SAAS,CAAC;EAC7C;EAEA,SAASQ,OAAUT,KAAA,EAAmB;IACpC,OAAOE,KAAA,CAAMC,IAAA,CAAKH,KAAA,CAAMI,IAAA,CAAK,CAAC,EAC3BM,MAAA,CAAO,CAACC,MAAA,EAAkBL,CAAA,KAAM;MAC/B,MAAMM,KAAA,GAAQf,kBAAA,CAAmBW,KAAA,CAAMG,MAAA,CAAOE,EAAA,CAAG,EAAE,GAAGP,CAAA,GAAI,CAAC;MAC3D,MAAMQ,SAAA,GAAYF,KAAA,CAAMF,MAAA,CAAO,CAACK,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA,EAAG,CAAC;MACjD,OAAO,CAACV,CAAA,IAAKQ,SAAA,GAAY1B,aAAA,GAAgBuB,MAAA,CAAOM,MAAA,CAAOX,CAAC,IAAIK,MAAA;IAC9D,GAAG,EAAE,EACJJ,GAAA,CAAI,CAACjB,KAAA,EAAOgB,CAAA,EAAGK,MAAA,KAAWX,KAAA,CAAMQ,KAAA,CAAMlB,KAAA,EAAOqB,MAAA,CAAOL,CAAA,GAAI,CAAC,CAAC,CAAC;EAChE;EAEA,OAAO,SAASY,YAAelB,KAAA,EAAmB;IAChD,OAAOL,SAAA,CAASG,aAAa,IAAIC,QAAA,CAASC,KAAA,EAAOF,aAAa,IAAIW,MAAA,CAAOT,KAAK;EAChF;AACF;;;ACpBO,SAASmB,cAAcvE,GAAA,EAAqC;EACjE,MAAMwE,QAAA,GAAWC,eAAA,CAAgB;EAEjC,SAASA,gBAAA,EAA0B;IACjC,IAAI,CAACzE,GAAA,CAAI0E,aAAA,EAAe,OAAO;IAC/B,MAAMC,SAAA,GAAY3E,GAAA,CAAI4E,UAAA,CAAW,CAAC;IAClC,OAAOhD,IAAA,CAAKC,GAAA,CAAI7B,GAAA,CAAI0E,aAAA,CAAc1E,GAAA,CAAI6E,SAAS,IAAIF,SAAA,CAAU3E,GAAA,CAAI6E,SAAS,CAAC;EAC7E;EAEA,SAASC,gBAAA,EAA4B;IACnC,OAAO9E,GAAA,CAAI4E,UAAA,CAAWjB,GAAA,CAAI,CAACoB,IAAA,EAAMxE,KAAA,EAAOyE,KAAA,KAAU;MAChD,MAAMC,OAAA,GAAU,CAAC1E,KAAA;MACjB,IAAI0E,OAAA,EAAS,OAAOrD,IAAA,CAAKC,GAAA,CAAIqD,UAAA,CAAW3E,KAAK,IAAIiE,QAAQ;MAEzD,MAAMW,MAAA,GAAS5E,KAAA,KAAUyE,KAAA,CAAMrD,MAAA,GAAS;MACxC,IAAIwD,MAAA,EAAQ,OAAOvD,IAAA,CAAKC,GAAA,CAAIqD,UAAA,CAAW3E,KAAK,CAAC;MAE7C,OAAOqB,IAAA,CAAKC,GAAA,CAAImD,KAAA,CAAMzE,KAAA,GAAQ,CAAC,EAAEP,GAAA,CAAI6E,SAAS,IAAIE,IAAA,CAAK/E,GAAA,CAAI6E,SAAS,CAAC;IACvE,CAAC;EACH;EAEA,MAAMK,UAAA,GAAalF,GAAA,CAAI4E,UAAA,CAAWjB,GAAA,CAAKgB,SAAA,IAAc;IACnD,OAAO3E,GAAA,CAAIoF,UAAA,GAAaT,SAAA,CAAUU,MAAA,GAASV,SAAA,CAAUW,KAAA;EACvD,CAAC;EACD,MAAMrC,kBAAA,GAAqB6B,eAAA,CAAgB;EAE3C,OAAO;IACLI,UAAA;IACAjC;EACF;AACF;;;AC/BA,IAAMsC,SAAA,GAAgBnC,KAAA,IAAkBA,KAAA,CAAMoC,cAAA,CAAepC,KAAK,CAAC;AACnE,IAAMoC,cAAA,GAAqBpC,KAAA,IAAuBxB,IAAA,CAAKF,GAAA,CAAI,GAAG0B,KAAA,CAAMzB,MAAA,GAAS,CAAC;AAEvE,SAAS8D,eAAezF,GAAA,EAAqB;EAClD,MAAM;IAAEkF,UAAA;IAAYjC;EAAmB,IAAIsB,aAAA,CAAcvE,GAAG;EAE5D,MAAMsE,WAAA,GAActB,iBAAA,CAAkBhD,GAAA,CAAIwC,aAAA,EAAgBS,kBAAA,EAAoBjD,GAAA,CAAIkD,aAAa;EAE/F,SAASwC,aAAA,EAAyB;IAChC,OAAOpB,WAAA,CAAYtE,GAAA,CAAI4E,UAAU,EAC9BjB,GAAA,CAAKqB,KAAA,IAAUO,SAAA,CAAUP,KAAK,EAAEhF,GAAA,CAAI2F,OAAO,IAAIX,KAAA,CAAM,CAAC,EAAEhF,GAAA,CAAI6E,SAAS,CAAC,EACtElB,GAAA,CAAI/B,IAAA,CAAKC,GAAG;EACjB;EAEA,SAAS+D,iBAAA,EAA6B;IACpC,OAAO5F,GAAA,CAAI4E,UAAA,CACRjB,GAAA,CAAKgB,SAAA,IAAc3E,GAAA,CAAI0E,aAAA,CAAe1E,GAAA,CAAI6E,SAAS,IAAIF,SAAA,CAAU3E,GAAA,CAAI6E,SAAS,CAAC,EAC/ElB,GAAA,CAAKkC,IAAA,IAAS,CAACjE,IAAA,CAAKC,GAAA,CAAIgE,IAAI,CAAC;EAClC;EAEA,SAASC,eAAA,EAA2B;IAClC,MAAMC,SAAA,GAAYzD,YAAA,CAAatC,GAAA,CAAIuC,KAAA,EAAOvC,GAAA,CAAIwC,aAAc;IAC5D,MAAMwD,UAAA,GAAaN,YAAA,CAAa,EAAE/B,GAAA,CAAIoC,SAAS;IAE/C,OAAOzB,WAAA,CAAY2B,KAAK,EACrBtC,GAAA,CAAKkC,IAAA,IAASA,IAAA,CAAK,CAAC,CAAC,EACrBlC,GAAA,CAAI,CAACkC,IAAA,EAAMtF,KAAA,KAAUsF,IAAA,GAAOG,UAAA,CAAWzF,KAAK,CAAC;EAClD;EAEA,MAAM0F,KAAA,GAAQL,gBAAA,CAAiB;EAC/B,MAAMM,YAAA,GAAeJ,cAAA,CAAe;EAEpC,MAAMK,WAAA,GAAc,CAACZ,SAAA,CAAUU,KAAK,IAAIV,SAAA,CAAUtC,kBAAkB;EAEpE,MAAMmD,WAAA,GAAc5E,QAAA,CAASyE,KAAA,CAAMA,KAAA,CAAMtE,MAAA,GAAS,CAAC,GAAGsE,KAAA,CAAM,CAAC,CAAC;EAC9D,MAAMI,cAAA,IAAkBH,YAAA,CAAalG,GAAA,CAAIO,KAAK,IAAI6F,WAAA,CAAY1E,GAAA,IAAO,CAAC0E,WAAA,CAAYzE,MAAA;EAElF,OAAO;IACLsE,KAAA;IACAC,YAAA;IACAhB,UAAA;IACAjC,kBAAA;IACAkD,WAAA;IACAC,WAAA;IACAC,cAAA,EAAgBzE,IAAA,CAAKC,GAAA,CAAIwE,cAAc;EACzC;AACF;;;AC1CA,IAAMC,cAAA,GAAiB;AAEhB,SAASC,gBAAgBvG,GAAA,EAAqB;EACnD,MAAMwG,cAAA,GAAiB;EACvB,MAAMC,YAAA,GAAe,CAAC,CAAC;EAEvB,MAAM;IAAER,KAAA;IAAOf,UAAA;IAAYkB;EAAY,IAAIX,cAAA,CAAezF,GAAG;EAE7D,MAAM0G,eAAA,GAAkBxB,UAAA,CAAWvB,GAAA,CAAKgD,SAAA,IAAc;IACpD,MAAMC,cAAA,GAAiBpF,QAAA,CAASgF,cAAA,EAAgBG,SAAA,GAAYH,cAAc;IAC1E,OAAOI,cAAA,CAAe1E,SAAA,CAAUyE,SAAA,GAAYL,cAAc;EAC5D,CAAC;EAED,MAAMO,WAAA,GAAcJ,YAAA,CAAa3C,MAAA,CAAO,CAACgD,GAAA,EAAcC,MAAA,KAAW;IAChE,MAAMC,MAAA,GAASf,KAAA,CAAMtC,GAAA,CAAI,CAACkC,IAAA,EAAMtF,KAAA,MAAW;MACzCmC,KAAA,EAAOmD,IAAA,GAAOX,UAAA,CAAW3E,KAAK,IAAImG,eAAA,CAAgBnG,KAAK,IAAIwG,MAAA;MAC3DnE,GAAA,EAAKiD,IAAA,GAAO7F,GAAA,CAAIwC,aAAA,GAAgBkE,eAAA,CAAgBnG,KAAK,IAAIwG,MAAA;MACzDxG;IACF,EAAE;IACF,OAAOuG,GAAA,CAAIzC,MAAA,CAAO2C,MAAM;EAC1B,GAAG,EAAE;EAEL,OAAQC,QAAA,IAAqB;IAC3B,MAAMC,GAAA,GAAMd,WAAA,CAAYlE,SAAA,CAAU+E,QAAQ;IAC1C,OAAOJ,WAAA,CAAY/C,MAAA,CAAO,CAACqD,IAAA,EAAgBC,KAAA,KAAU;MACnD,MAAM;QAAE7G,KAAA;QAAOmC,KAAA;QAAOE;MAAI,IAAIwE,KAAA;MAC9B,MAAMC,MAAA,GAASF,IAAA,CAAKG,QAAA,CAAS/G,KAAK;MAClC,MAAMgH,MAAA,GAAS7E,KAAA,GAAQwE,GAAA,IAAOtE,GAAA,GAAMsE,GAAA;MACpC,OAAO,CAACG,MAAA,IAAUE,MAAA,GAASJ,IAAA,CAAK9C,MAAA,CAAO,CAAC9D,KAAK,CAAC,IAAI4G,IAAA;IACpD,GAAG,EAAE;EACP;AACF;;;APlCO,SAASK,QAA6BC,KAAA,EAAcC,IAAA,EAAYC,SAAA,EAA6C;EAClH,MAAMC,aAAA,GAAgBH,KAAA,CAAMI,OAAA,CAAQD,aAAA;EACpC,MAAME,aAAA,GAAgBL,KAAA,CAAMI,OAAA,CAAQC,aAAA;EACpC,MAAMC,UAAA,GAAaN,KAAA,CAAMI,OAAA,CAAQG,YAAA;EACjC,MAAMC,WAAA,GAAcR,KAAA,CAAMS,OAAA,CAAQ,UAAU;EAE5C,MAAMC,UAAA,GAAaV,KAAA,CAAMI,OAAA,CAAQO,WAAA,CAAYX,KAAA,CAAMI,OAAA,CAAQtH,KAAK;EAChE,MAAM8H,YAAA,GAAe1I,KAAA,CAAM,IAAI4G,eAAA,CAAgBkB,KAAA,CAAMI,OAAO,EAAEM,UAAU,IAAI,EAAC;EAE7E,SAASG,aAAaC,MAAA,EAA6B;IACjD,OAAO;MACLC,SAAA,EAAW,SAASD,MAAA,CAAMhI,KAAA,GAAQ,CAAC;MACnCkI,OAAA,EAASF,MAAA,CAAMhI,KAAA,KAAUkH,KAAA,CAAMI,OAAA,CAAQtH,KAAA;MACvCmI,IAAA,EAAMH,MAAA,CAAMhI,KAAA,KAAUkH,KAAA,CAAMI,OAAA,CAAQtH,KAAA,GAAQ;MAC5CoI,QAAA,EAAUJ,MAAA,CAAMhI,KAAA,KAAUkH,KAAA,CAAMI,OAAA,CAAQtH,KAAA,GAAQ;MAChDgH,MAAA,EAAQc,YAAA,CAAaf,QAAA,CAASiB,MAAA,CAAMhI,KAAK;IAC3C;EACF;EAEA,OAAO;IACLA,KAAA,EAAOkH,KAAA,CAAMI,OAAA,CAAQtH,KAAA;IACrB8F,cAAA,EAAgBoB,KAAA,CAAMI,OAAA,CAAQxB,cAAA;IAC9B4B,WAAA;IACAL,aAAA;IACAE,aAAA;IACAc,SAASrI,KAAA,EAAOsI,IAAA,EAAM;MACpBnB,IAAA,CAAK;QAAEoB,IAAA,EAAM;QAAQvI,KAAA;QAAOsI;MAAK,CAAC;IACpC;IACAE,aAAA,EAAe;MACbrB,IAAA,CAAK,MAAM;IACb;IACAsB,iBAAA,EAAmB;MACjBtB,IAAA,CAAK,MAAM;IACb;IACAY,YAAA;IACAW,KAAA,EAAO;MACLvB,IAAA,CAAK,MAAM;IACb;IACAwB,MAAA,EAAQ;MACNxB,IAAA,CAAK,OAAO;IACd;IAEAyB,aAAA,EAAe;MACb,OAAOxB,SAAA,CAAUyB,OAAA,CAAQ;QACvB,GAAG5J,KAAA,CAAMU,IAAA,CAAKmJ,KAAA;QACdlJ,EAAA,EAAIL,GAAA,CAAIC,SAAA,CAAU0H,KAAA,CAAMI,OAAO;QAC/ByB,IAAA,EAAM;QACN,wBAAwB;QACxB,oBAAoB7B,KAAA,CAAMI,OAAA,CAAQ0B,WAAA;QAClCC,GAAA,EAAK/B,KAAA,CAAMI,OAAA,CAAQ2B,GAAA;QACnB,cAAc;QACdC,KAAA,EAAO;UACL,mBAAmBhC,KAAA,CAAMI,OAAA,CAAQ6B,OAAA;UACjC,gBAAgB,eAAejC,KAAA,CAAMI,OAAA,CAAQ3E,aAAa;QAC5D;MACF,CAAC;IACH;IAEAyG,iBAAA,EAAmB;MACjB,OAAOhC,SAAA,CAAUyB,OAAA,CAAQ;QACvB,GAAG5J,KAAA,CAAMa,QAAA,CAASgJ,KAAA;QAClBG,GAAA,EAAK/B,KAAA,CAAMI,OAAA,CAAQ2B,GAAA;QACnBrJ,EAAA,EAAIL,GAAA,CAAIM,aAAA,CAAcqH,KAAA,CAAMI,OAAO;QACnC,oBAAoBJ,KAAA,CAAMI,OAAA,CAAQ0B;MACpC,CAAC;IACH;IAEAK,kBAAA,EAAoB;MAClB,OAAOjC,SAAA,CAAUyB,OAAA,CAAQ;QACvB,GAAG5J,KAAA,CAAMkB,SAAA,CAAU2I,KAAA;QACnBlJ,EAAA,EAAIL,GAAA,CAAIW,cAAA,CAAegH,KAAA,CAAMI,OAAO;QACpC,oBAAoBJ,KAAA,CAAMI,OAAA,CAAQ0B,WAAA;QAClCC,GAAA,EAAK/B,KAAA,CAAMI,OAAA,CAAQ2B,GAAA;QACnBC,KAAA,EAAO;UACLI,OAAA,EAAS;UACTC,aAAA,EAAe/B,UAAA,GAAa,QAAQ;UACpC,CAACA,UAAA,GAAa,WAAW,OAAO,GAAG;UACnCgC,GAAA,EAAK;UACLC,SAAA,EAAWvC,KAAA,CAAMI,OAAA,CAAQoC,cAAA;UACzBC,kBAAA,EAAoB;UACpBC,UAAA,EAAY;UACZC,wBAAA,EAA0B;UAC1BC,kBAAA,EAAoB;QACtB;MACF,CAAC;IACH;IAEAC,aAAa/B,MAAA,EAAO;MAClB,MAAMgC,SAAA,GAAYjC,YAAA,CAAaC,MAAK;MAEpC,OAAOZ,SAAA,CAAUyB,OAAA,CAAQ;QACvB,GAAG5J,KAAA,CAAMgB,IAAA,CAAK6I,KAAA;QACdlJ,EAAA,EAAIL,GAAA,CAAIQ,SAAA,CAAUmH,KAAA,CAAMI,OAAA,EAASU,MAAA,CAAMhI,KAAK;QAC5CiJ,GAAA,EAAK/B,KAAA,CAAMI,OAAA,CAAQ2B,GAAA;QACnB,gBAAgB9J,QAAA,CAAS6K,SAAA,CAAU9B,OAAO;QAC1C,eAAe/I,QAAA,CAAS6K,SAAA,CAAUhD,MAAM;QACxC+B,IAAA,EAAM;QACN,wBAAwB;QACxB,oBAAoB7B,KAAA,CAAMI,OAAA,CAAQ0B,WAAA;QAClC,cAAcgB,SAAA,CAAU/B,SAAA;QACxBiB,KAAA,EAAO;UACLe,QAAA,EAAU;UACVC,IAAA,EAAM;UACN,CAAC1C,UAAA,GAAa,aAAa,WAAW,GAAG;QAC3C;MACF,CAAC;IACH;IAEA2C,oBAAA,EAAsB;MACpB,OAAO/C,SAAA,CAAUgD,MAAA,CAAO;QACtB,GAAGnL,KAAA,CAAMsB,WAAA,CAAYuI,KAAA;QACrBlJ,EAAA,EAAIL,GAAA,CAAIe,gBAAA,CAAiB4G,KAAA,CAAMI,OAAO;QACtCiB,IAAA,EAAM;QACN8B,QAAA,EAAU;QACVC,QAAA,EAAU,CAAC/C,aAAA;QACX0B,GAAA,EAAK/B,KAAA,CAAMI,OAAA,CAAQ2B,GAAA;QACnB,cAAc;QACd,oBAAoB/B,KAAA,CAAMI,OAAA,CAAQ0B,WAAA;QAClC,iBAAiBzJ,GAAA,CAAIW,cAAA,CAAegH,KAAA,CAAMI,OAAO;QACjDiD,QAAA,EAAU;UACRpD,IAAA,CAAK,MAAM;QACb;MACF,CAAC;IACH;IAEAqD,oBAAA,EAAsB;MACpB,OAAOpD,SAAA,CAAUgD,MAAA,CAAO;QACtB,GAAGnL,KAAA,CAAMoB,WAAA,CAAYyI,KAAA;QACrBG,GAAA,EAAK/B,KAAA,CAAMI,OAAA,CAAQ2B,GAAA;QACnBrJ,EAAA,EAAIL,GAAA,CAAIa,gBAAA,CAAiB8G,KAAA,CAAMI,OAAO;QACtCiB,IAAA,EAAM;QACN8B,QAAA,EAAU;QACV,cAAc;QACd,oBAAoBnD,KAAA,CAAMI,OAAA,CAAQ0B,WAAA;QAClC,iBAAiBzJ,GAAA,CAAIW,cAAA,CAAegH,KAAA,CAAMI,OAAO;QACjDgD,QAAA,EAAU,CAACjD,aAAA;QACXkD,QAAA,EAAU;UACRpD,IAAA,CAAK,MAAM;QACb;MACF,CAAC;IACH;IAEAsD,uBAAA,EAAyB;MACvB,OAAOrD,SAAA,CAAUyB,OAAA,CAAQ;QACvB,GAAG5J,KAAA,CAAMwB,cAAA,CAAeqI,KAAA;QACxBG,GAAA,EAAK/B,KAAA,CAAMI,OAAA,CAAQ2B,GAAA;QACnBrJ,EAAA,EAAIL,GAAA,CAAIiB,mBAAA,CAAoB0G,KAAA,CAAMI,OAAO;QACzC,oBAAoBJ,KAAA,CAAMI,OAAA,CAAQ0B;MACpC,CAAC;IACH;IAEA0B,kBAAkB1C,MAAA,EAAO;MACvB,OAAOZ,SAAA,CAAUgD,MAAA,CAAO;QACtB,GAAGnL,KAAA,CAAM0B,SAAA,CAAUmI,KAAA;QACnBG,GAAA,EAAK/B,KAAA,CAAMI,OAAA,CAAQ2B,GAAA;QACnBrJ,EAAA,EAAIL,GAAA,CAAImB,cAAA,CAAewG,KAAA,CAAMI,OAAA,EAASU,MAAA,CAAMhI,KAAK;QACjDuI,IAAA,EAAM;QACN,oBAAoBrB,KAAA,CAAMI,OAAA,CAAQ0B,WAAA;QAClC,cAAchB,MAAA,CAAMhI,KAAA;QACpB,iBAAiBb,QAAA,CAAS6I,MAAA,CAAM2C,QAAQ;QACxC,gBAAgBxL,QAAA,CAAS6I,MAAA,CAAMhI,KAAA,KAAUkH,KAAA,CAAMI,OAAA,CAAQtH,KAAK;QAC5DuK,QAAA,EAAU;UACR,IAAIvC,MAAA,CAAM2C,QAAA,EAAU;UACpBxD,IAAA,CAAK;YAAEoB,IAAA,EAAM;YAAQvI,KAAA,EAAOgI,MAAA,CAAMhI;UAAM,CAAC;QAC3C;MACF,CAAC;IACH;EACF;AACF;;;AQ/KA,SAAS4K,aAAA,EAAeC,GAAA,QAAW;AACnC,SAASC,OAAA,EAASC,OAAA,EAASC,SAAA,EAAWC,SAAA,QAAiB;AAKhD,SAASC,QAAQC,WAAA,EAAiC;EACvD,MAAM1L,GAAA,GAAMqL,OAAA,CAAQK,WAAW;EAC/B,OAAOP,aAAA,CACL;IACEhL,EAAA,EAAI;IACJwL,OAAA,EAAS;IACT9D,OAAA,EAAS;MACPtH,KAAA,EAAO;MACPgJ,WAAA,EAAa;MACbhH,KAAA,EAAO;MACPqJ,IAAA,EAAM;MACN1I,aAAA,EAAe;MACfwG,OAAA,EAAS;MACT,GAAG1J,GAAA;MACHoI,WAAA,EAAa,EAAC;MACd/B,cAAA,EAAgB;MAChB7D,aAAA,EAAe;MACfoC,UAAA,EAAY;IACd;IAEAiH,KAAA,EAAO;MACLtL,KAAA,EAAO,CAAC,gBAAgB;IAC1B;IAEAuL,EAAA,EAAI;MACFC,IAAA,EAAM;QACJC,OAAA,EAAS,CAAC,cAAc;MAC1B;MACAC,IAAA,EAAM;QACJD,OAAA,EAAS,CAAC,cAAc;MAC1B;MACAE,IAAA,EAAM;QACJF,OAAA,EAAS,CAAC,UAAU;MACtB;MACAG,WAAA,EAAa;QACXH,OAAA,EAAS,CAAC,mBAAmB,gBAAgB;MAC/C;MACAI,IAAA,EAAM;IACR;IAEAC,MAAA,EAAQ;MACNC,IAAA,EAAM;QACJR,EAAA,EAAI;UACFS,YAAA,EAAc;QAChB;MACF;MACAC,QAAA,EAAU;QACRC,UAAA,EAAY,CAAC,yBAAyB;QACtCC,KAAA,EAAO;UACL,KAAM,CAAC,cAAc;QACvB;QACAZ,EAAA,EAAI;UACFa,KAAA,EAAO;QACT;MACF;MACAC,QAAA,EAAU;QACRd,EAAA,EAAI;UACFe,UAAA,EAAY;UACZC,YAAA,EAAc;YACZd,OAAA,EAAS,CAAC,gBAAgB;UAC5B;QACF;MACF;IACF;IACAS,UAAA,EAAY,CAAC,wBAAwB,oBAAoB;IACzDM,KAAA,EAAO,CAAC,mBAAmB,gBAAgB;IAC3CC,QAAA,EAAU;MACRC,KAAA,EAAQC,IAAA,IAAQA,IAAA,CAAI1D,GAAA,KAAQ;MAC5BxB,YAAA,EAAekF,IAAA,IAAQA,IAAA,CAAI3D,WAAA,KAAgB;MAC3CnE,UAAA,EAAa8H,IAAA,IAAQA,IAAA,CAAI3D,WAAA,KAAgB;MACzC3B,aAAA,EAAgBsF,IAAA,IAAQA,IAAA,CAAItB,IAAA,IAAQsB,IAAA,CAAI3M,KAAA,GAAQ2M,IAAA,CAAI9E,WAAA,CAAYzG,MAAA,GAAS;MACzEmG,aAAA,EAAgBoF,IAAA,IAAQA,IAAA,CAAItB,IAAA,IAAQsB,IAAA,CAAI3M,KAAA,GAAQ;MAChDsE,UAAUqI,IAAA,EAAK;QACb,IAAIA,IAAA,CAAI9H,UAAA,EAAY,OAAO;QAC3B,OAAO8H,IAAA,CAAID,KAAA,GAAQ,UAAU;MAC/B;MACAtH,QAAQuH,IAAA,EAAK;QACX,IAAIA,IAAA,CAAI9H,UAAA,EAAY,OAAO;QAC3B,OAAO8H,IAAA,CAAID,KAAA,GAAQ,SAAS;MAC9B;MACAhD,cAAA,EAAiBiD,IAAA,IAAQ;QACvB,MAAMC,UAAA,GAAaD,IAAA,CAAI9E,WAAA,CAAY8E,IAAA,CAAI3M,KAAK;QAC5C,OAAO2M,IAAA,CAAIlF,YAAA,GAAe,eAAemF,UAAU,cAAc,kBAAkBA,UAAU;MAC/F;IACF;EACF,GACA;IACEV,UAAA,EAAY;MACVW,mBAAmBF,IAAA,EAAKG,IAAA,EAAM;QAAE3F;MAAK,GAAG;QACtC,MAAM4F,YAAA,GAAexN,GAAA,CAAIwB,eAAA,CAAgB4L,IAAG;QAC5C,IAAI,CAACI,YAAA,EAAc;QACnB,MAAMC,GAAA,GAAMzN,GAAA,CAAI0N,MAAA,CAAON,IAAG;QAC1B,MAAMO,QAAA,GAAW,IAAIF,GAAA,CAAIG,gBAAA,CAAiB,MAAM;UAC9ChG,IAAA,CAAK;YAAEoB,IAAA,EAAM;YAAe6E,GAAA,EAAK;UAAW,CAAC;QAC/C,CAAC;QACDF,QAAA,CAASG,OAAA,CAAQN,YAAA,EAAc;UAAEO,SAAA,EAAW;QAAK,CAAC;QAClD,OAAO,MAAM;UACXJ,QAAA,CAASK,UAAA,CAAW;QACtB;MACF;MACAC,qBAAqBb,IAAA,EAAKG,IAAA,EAAM;QAAE3F;MAAK,GAAG;QACxC,MAAM4F,YAAA,GAAexN,GAAA,CAAIwB,eAAA,CAAgB4L,IAAG;QAC5C,IAAI,CAACI,YAAA,EAAc;QACnB,MAAMC,GAAA,GAAMzN,GAAA,CAAI0N,MAAA,CAAON,IAAG;QAC1B,MAAMO,QAAA,GAAW,IAAIF,GAAA,CAAIS,cAAA,CAAgBC,OAAA,IAAY;UACnDA,OAAA,CAAQC,OAAA,CAASnB,KAAA,IAAU;YACzB,IAAIA,KAAA,CAAMoB,MAAA,KAAWb,YAAA,EAAc;cACjC5F,IAAA,CAAK;gBAAEoB,IAAA,EAAM;gBAAe6E,GAAA,EAAK;cAAS,CAAC;YAC7C;UACF,CAAC;QACH,CAAC;QACDF,QAAA,CAASG,OAAA,CAAQN,YAAY;QAC7B,OAAO,MAAM;UACXG,QAAA,CAASK,UAAA,CAAW;QACtB;MACF;MACAM,wBAAwBlB,IAAA,EAAKG,IAAA,EAAM;QAAE3F;MAAK,GAAG;QAC3C,MAAM2G,GAAA,GAAMvO,GAAA,CAAIwO,MAAA,CAAOpB,IAAG;QAC1B,MAAMqB,kBAAA,GAAqBA,CAAA,KAAM;UAC/B,IAAIF,GAAA,CAAIG,eAAA,KAAoB,WAAW;YACrC9G,IAAA,CAAK;cAAEoB,IAAA,EAAM;cAAS6E,GAAA,EAAK;YAAkB,CAAC;UAChD;QACF;QACAU,GAAA,CAAII,gBAAA,CAAiB,oBAAoBF,kBAAkB;QAC3D,OAAO,MAAM;UACXF,GAAA,CAAIK,mBAAA,CAAoB,oBAAoBH,kBAAkB;QAChE;MACF;IACF;IACAI,MAAA,EAAQ;MACN/C,IAAA,EAAOsB,IAAA,IAAQA,IAAA,CAAItB,IAAA;MACnBgD,WAAA,EAAc1B,IAAA,IAAQA,IAAA,CAAI3M,KAAA,KAAU2M,IAAA,CAAI9E,WAAA,CAAYzG,MAAA,GAAS;MAC7DkN,YAAA,EAAe3B,IAAA,IAAQA,IAAA,CAAI3M,KAAA,KAAU;IACvC;IACAyL,OAAA,EAAS;MACPjD,aAAamE,IAAA,EAAK;QAChB,MAAM3M,KAAA,GAAQgL,SAAA,CAAU2B,IAAA,CAAI9E,WAAA,EAAa8E,IAAA,CAAI3M,KAAK;QAClDuO,GAAA,CAAIvO,KAAA,CAAM2M,IAAA,EAAK3M,KAAK;MACtB;MACAwO,aAAa7B,IAAA,EAAK;QAChB,MAAM3M,KAAA,GAAQiL,SAAA,CAAU0B,IAAA,CAAI9E,WAAA,EAAa8E,IAAA,CAAI3M,KAAK;QAClDuO,GAAA,CAAIvO,KAAA,CAAM2M,IAAA,EAAK3M,KAAK;MACtB;MACAyO,eAAe9B,IAAA,EAAK;QAClB,MAAM;UAAEhH,YAAA;UAAcG;QAAe,IAAIZ,cAAA,CAAeyH,IAAG;QAC3DA,IAAA,CAAI9E,WAAA,GAAclC,YAAA;QAClBgH,IAAA,CAAI7G,cAAA,GAAiBA,cAAA;MACvB;MACAuC,SAASsE,IAAA,EAAK+B,GAAA,EAAK;QACjB,MAAM1O,KAAA,GAAQqB,IAAA,CAAKF,GAAA,CAAI,GAAGE,IAAA,CAAKH,GAAA,CAAIwN,GAAA,CAAI1O,KAAA,EAAO2M,IAAA,CAAI9E,WAAA,CAAYzG,MAAA,GAAS,CAAC,CAAC;QACzEmN,GAAA,CAAIvO,KAAA,CAAM2M,IAAA,EAAK3M,KAAK;MACtB;MACA2O;IACF;EACF,CACF;AACF;AAEA,IAAMA,eAAA,GAAmBlP,GAAA,IAAwB;EAC/C,MAAMsN,YAAA,GAAexN,GAAA,CAAIwB,eAAA,CAAgBtB,GAAG;EAC5C,IAAI,CAACsN,YAAA,EAAc;EACnBtN,GAAA,CAAI0E,aAAA,GAAgB0G,GAAA,CAAIkC,YAAA,CAAa6B,qBAAA,CAAsB,CAAC;EAC5DnP,GAAA,CAAIwC,aAAA,GAAgBxC,GAAA,CAAIgI,YAAA,GAAehI,GAAA,CAAI0E,aAAA,CAAcY,KAAA,GAAQtF,GAAA,CAAI0E,aAAA,CAAcW,MAAA;EACnFrF,GAAA,CAAI4E,UAAA,GAAawG,GAAA,CAAItL,GAAA,CAAIyB,WAAA,CAAYvB,GAAG,EAAE2D,GAAA,CAAKyL,KAAA,IAAUA,KAAA,CAAMD,qBAAA,CAAsB,CAAC,CAAC;AACzF;AAEA,IAAME,MAAA,GAAS;EACbC,MAAA,EAAStP,GAAA,IAAwB;IAC/BA,GAAA,CAAIuP,aAAA,GAAgB;MAAEhP,KAAA,EAAOP,GAAA,CAAIO;IAAM,CAAC;EAC1C;AACF;AAEA,IAAMuO,GAAA,GAAM;EACVvO,KAAA,EAAOA,CAACP,GAAA,EAAqBO,KAAA,KAAkB;IAC7C,IAAI+K,OAAA,CAAQtL,GAAA,CAAIO,KAAA,EAAOA,KAAK,GAAG;IAC/BP,GAAA,CAAIO,KAAA,GAAQA,KAAA;IACZ8O,MAAA,CAAOC,MAAA,CAAOtP,GAAG;EACnB;AACF;;;ACxLA,SAASwP,WAAA,QAAmB;AAC5B,SAASC,gBAAA,QAAwB;AAG1B,IAAMC,KAAA,GAAQF,WAAA,CAAgC,EAAE,CACrD,SACA,OACA,eACA,MACA,OACA,SACA,QACA,iBACA,eACA,iBACA,UACD;AACM,IAAMG,UAAA,GAAaF,gBAAA,CAA8CC,KAAK;AAEtE,IAAME,cAAA,GAAiBJ,WAAA,CAA4B,EAAE,CAAC,SAAS,UAAU,CAAC;AAC1E,IAAMK,mBAAA,GAAsBJ,gBAAA,CAAiCG,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}