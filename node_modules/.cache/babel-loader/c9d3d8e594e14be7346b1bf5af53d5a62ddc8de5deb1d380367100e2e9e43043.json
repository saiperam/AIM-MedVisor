{"ast":null,"code":"// src/toast-group.connect.ts\nimport { isMachine, subscribe } from \"@zag-js/core\";\nimport { contains } from \"@zag-js/dom-query\";\nimport { runIfFn, uuid } from \"@zag-js/utils\";\n\n// src/toast.anatomy.ts\nimport { createAnatomy } from \"@zag-js/anatomy\";\nvar anatomy = createAnatomy(\"toast\").parts(\"group\", \"root\", \"title\", \"description\", \"actionTrigger\", \"closeTrigger\");\nvar parts = anatomy.build();\n\n// src/toast.dom.ts\nimport { createScope } from \"@zag-js/dom-query\";\nvar dom = createScope({\n  getRegionId: placement => `toast-group:${placement}`,\n  getRegionEl: (ctx, placement) => dom.getById(ctx, `toast-group:${placement}`),\n  getRootId: ctx => `toast:${ctx.id}`,\n  getRootEl: ctx => dom.getById(ctx, dom.getRootId(ctx)),\n  getTitleId: ctx => `toast:${ctx.id}:title`,\n  getDescriptionId: ctx => `toast:${ctx.id}:description`,\n  getCloseTriggerId: ctx => `toast${ctx.id}:close`\n});\n\n// src/toast.utils.ts\nimport { MAX_Z_INDEX } from \"@zag-js/dom-query\";\nfunction getToastsByPlacement(toasts, placement) {\n  return toasts.filter(toast => toast.state.context.placement === placement);\n}\nvar defaultTimeouts = {\n  info: 5e3,\n  error: 5e3,\n  success: 2e3,\n  loading: Infinity,\n  DEFAULT: 5e3\n};\nfunction getToastDuration(duration, type) {\n  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;\n}\nfunction getGroupPlacementStyle(ctx, placement) {\n  const offset = ctx.offsets;\n  const computedOffset = typeof offset === \"string\" ? {\n    left: offset,\n    right: offset,\n    bottom: offset,\n    top: offset\n  } : offset;\n  const rtl = ctx.dir === \"rtl\";\n  const computedPlacement = placement.replace(\"-start\", rtl ? \"-right\" : \"-left\").replace(\"-end\", rtl ? \"-left\" : \"-right\");\n  const isRighty = computedPlacement.includes(\"right\");\n  const isLefty = computedPlacement.includes(\"left\");\n  const styles = {\n    position: \"fixed\",\n    pointerEvents: ctx.count > 0 ? void 0 : \"none\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"--gap\": `${ctx.gap}px`,\n    \"--first-height\": `${ctx.heights[0]?.height || 0}px`,\n    zIndex: MAX_Z_INDEX\n  };\n  let alignItems = \"center\";\n  if (isRighty) alignItems = \"flex-end\";\n  if (isLefty) alignItems = \"flex-start\";\n  styles.alignItems = alignItems;\n  if (computedPlacement.includes(\"top\")) {\n    const offset2 = computedOffset.top;\n    styles.top = `max(env(safe-area-inset-top, 0px), ${offset2})`;\n  }\n  if (computedPlacement.includes(\"bottom\")) {\n    const offset2 = computedOffset.bottom;\n    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset2})`;\n  }\n  if (!computedPlacement.includes(\"left\")) {\n    const offset2 = computedOffset.right;\n    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset2})`;\n  }\n  if (!computedPlacement.includes(\"right\")) {\n    const offset2 = computedOffset.left;\n    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset2})`;\n  }\n  return styles;\n}\nfunction getPlacementStyle(ctx, visible) {\n  const [side] = ctx.placement.split(\"-\");\n  const sibling = !ctx.frontmost;\n  const overlap = !ctx.stacked;\n  const styles = {\n    position: \"absolute\",\n    pointerEvents: \"auto\",\n    \"--opacity\": \"0\",\n    \"--remove-delay\": `${ctx.removeDelay}ms`,\n    \"--duration\": `${ctx.type === \"loading\" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,\n    \"--initial-height\": `${ctx.height}px`,\n    \"--offset\": `${ctx.offset}px`,\n    \"--index\": ctx.index,\n    \"--z-index\": ctx.zIndex,\n    \"--lift-amount\": \"calc(var(--lift) * var(--gap))\",\n    \"--y\": \"100%\",\n    \"--x\": \"0\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (side === \"top\") {\n    assign({\n      top: \"0\",\n      \"--sign\": \"-1\",\n      \"--y\": \"-100%\",\n      \"--lift\": \"1\"\n    });\n  } else if (side === \"bottom\") {\n    assign({\n      bottom: \"0\",\n      \"--sign\": \"1\",\n      \"--y\": \"100%\",\n      \"--lift\": \"-1\"\n    });\n  }\n  if (ctx.mounted) {\n    assign({\n      \"--y\": \"0\",\n      \"--opacity\": \"1\"\n    });\n    if (ctx.stacked) {\n      assign({\n        \"--y\": \"calc(var(--lift) * var(--offset))\",\n        \"--height\": \"var(--initial-height)\"\n      });\n    }\n  }\n  if (!visible) {\n    assign({\n      \"--opacity\": \"0\",\n      pointerEvents: \"none\"\n    });\n  }\n  if (sibling && overlap) {\n    assign({\n      \"--base-scale\": \"var(--index) * 0.05 + 1\",\n      \"--y\": \"calc(var(--lift-amount) * var(--index))\",\n      \"--scale\": \"calc(-1 * var(--base-scale))\",\n      \"--height\": \"var(--first-height)\"\n    });\n    if (!visible) {\n      assign({\n        \"--y\": \"calc(var(--sign) * 40%)\"\n      });\n    }\n  }\n  if (sibling && ctx.stacked && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * var(--offset) + var(--lift) * -100%)\"\n    });\n  }\n  if (ctx.frontmost && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * -100%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostBeforeStyle(ctx, visible) {\n  const styles = {\n    position: \"absolute\",\n    inset: \"0\",\n    scale: \"1 2\",\n    pointerEvents: visible ? \"none\" : \"auto\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (ctx.frontmost && !visible) {\n    assign({\n      height: \"calc(var(--initial-height) + 80%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostAfterStyle(_ctx, _visible) {\n  return {\n    position: \"absolute\",\n    left: \"0\",\n    height: \"calc(var(--gap) + 2px)\",\n    bottom: \"100%\",\n    width: \"100%\"\n  };\n}\n\n// src/toast-group.connect.ts\nfunction groupConnect(serviceOrState, send, normalize) {\n  function getState() {\n    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState;\n    return result;\n  }\n  function getToastsByPlacementImpl(placement) {\n    return getToastsByPlacement(getState().context.toasts, placement);\n  }\n  function isVisible(id) {\n    const toasts = getState().context.toasts;\n    if (!toasts.length) return false;\n    return !!toasts.find(toast => toast.id == id);\n  }\n  function create(options) {\n    const uid = `toast:${uuid()}`;\n    const id = options.id ? options.id : uid;\n    if (isVisible(id)) return id;\n    send({\n      type: \"ADD_TOAST\",\n      toast: {\n        ...options,\n        id\n      }\n    });\n    return id;\n  }\n  function update(id, options) {\n    if (!isVisible(id)) return id;\n    send({\n      type: \"UPDATE_TOAST\",\n      id,\n      toast: options\n    });\n    return id;\n  }\n  function upsert(options) {\n    const {\n      id\n    } = options;\n    const visible = id ? isVisible(id) : false;\n    if (visible && id != null) {\n      return update(id, options);\n    } else {\n      return create(options);\n    }\n  }\n  function dismiss(id) {\n    if (id == null) {\n      send(\"DISMISS_ALL\");\n    } else if (isVisible(id)) {\n      send({\n        type: \"DISMISS_TOAST\",\n        id\n      });\n    }\n  }\n  return {\n    getCount() {\n      return getState().context.count;\n    },\n    getPlacements() {\n      const toasts = getState().context.toasts;\n      const placements = toasts.map(toast => toast.state.context.placement);\n      return Array.from(new Set(placements));\n    },\n    getToastsByPlacement: getToastsByPlacementImpl,\n    isVisible,\n    create,\n    update,\n    upsert,\n    dismiss,\n    remove(id) {\n      if (id == null) {\n        send(\"REMOVE_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"REMOVE_TOAST\",\n          id\n        });\n      }\n    },\n    dismissByPlacement(placement) {\n      const toasts = getToastsByPlacementImpl(placement);\n      toasts.forEach(toast => dismiss(toast.id));\n    },\n    loading(options) {\n      return upsert({\n        ...options,\n        type: \"loading\"\n      });\n    },\n    success(options) {\n      return upsert({\n        ...options,\n        type: \"success\"\n      });\n    },\n    error(options) {\n      return upsert({\n        ...options,\n        type: \"error\"\n      });\n    },\n    promise(promise, options, shared = {}) {\n      const id = upsert({\n        ...shared,\n        ...options.loading,\n        type: \"loading\"\n      });\n      runIfFn(promise).then(response => {\n        const successOptions = runIfFn(options.success, response);\n        upsert({\n          ...shared,\n          ...successOptions,\n          id,\n          type: \"success\"\n        });\n      }).catch(error => {\n        const errorOptions = runIfFn(options.error, error);\n        upsert({\n          ...shared,\n          ...errorOptions,\n          id,\n          type: \"error\"\n        });\n      }).finally(() => {\n        options.finally?.();\n      });\n      return id;\n    },\n    pause(id) {\n      if (id == null) {\n        send(\"PAUSE_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"PAUSE_TOAST\",\n          id\n        });\n      }\n    },\n    resume(id) {\n      if (id == null) {\n        send(\"RESUME_ALL\");\n      } else if (isVisible(id)) {\n        send({\n          type: \"RESUME_TOAST\",\n          id\n        });\n      }\n    },\n    getGroupProps(options) {\n      const {\n        placement,\n        label = \"Notifications\"\n      } = options;\n      const state = getState();\n      const hotkeyLabel = state.context.hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n      const [side, align = \"center\"] = placement.split(\"-\");\n      return normalize.element({\n        ...parts.group.attrs,\n        dir: state.context.dir,\n        tabIndex: -1,\n        \"aria-label\": `${placement} ${label} ${hotkeyLabel}`,\n        id: dom.getRegionId(placement),\n        \"data-placement\": placement,\n        \"data-side\": side,\n        \"data-align\": align,\n        \"aria-live\": \"polite\",\n        role: \"region\",\n        style: getGroupPlacementStyle(state.context, placement),\n        onMouseMove() {\n          send({\n            type: \"REGION.POINTER_ENTER\",\n            placement\n          });\n        },\n        onMouseLeave() {\n          send({\n            type: \"REGION.POINTER_LEAVE\",\n            placement\n          });\n        },\n        onFocus(event) {\n          send({\n            type: \"REGION.FOCUS\",\n            target: event.relatedTarget\n          });\n        },\n        onBlur(event) {\n          if (state.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {\n            send({\n              type: \"REGION.BLUR\"\n            });\n          }\n        }\n      });\n    },\n    subscribe(fn) {\n      const state = getState();\n      return subscribe(state.context.toasts, () => {\n        const toasts = getToastsByPlacementImpl(state.context.placement);\n        const contexts = toasts.map(toast => toast.getState().context);\n        fn(contexts);\n      });\n    }\n  };\n}\n\n// src/toast-group.machine.ts\nimport { createMachine as createMachine2, ref } from \"@zag-js/core\";\nimport { trackDismissableBranch } from \"@zag-js/dismissable\";\nimport { addDomEvent } from \"@zag-js/dom-event\";\nimport { compact as compact2 } from \"@zag-js/utils\";\n\n// src/toast.machine.ts\nimport { createMachine, guards } from \"@zag-js/core\";\nimport { queryAll, raf } from \"@zag-js/dom-query\";\nimport { compact, warn } from \"@zag-js/utils\";\nvar {\n  not,\n  and,\n  or\n} = guards;\nfunction createToastMachine(options) {\n  const {\n    type = \"info\",\n    duration,\n    id = \"1\",\n    placement = \"bottom\",\n    removeDelay = 200,\n    ...restProps\n  } = options;\n  const ctx = compact(restProps);\n  const computedDuration = getToastDuration(duration, type);\n  return createMachine({\n    id,\n    context: {\n      id,\n      type,\n      remaining: computedDuration,\n      duration: computedDuration,\n      removeDelay,\n      createdAt: Date.now(),\n      placement,\n      ...ctx,\n      height: 0,\n      offset: 0,\n      frontmost: false,\n      mounted: false,\n      index: -1,\n      zIndex: 0\n    },\n    initial: type === \"loading\" ? \"visible:persist\" : \"visible\",\n    on: {\n      UPDATE: [{\n        guard: and(\"hasTypeChanged\", \"isChangingToLoading\"),\n        target: \"visible:persist\",\n        actions: [\"setContext\"]\n      }, {\n        guard: or(\"hasDurationChanged\", \"hasTypeChanged\"),\n        target: \"visible:updating\",\n        actions: [\"setContext\"]\n      }, {\n        actions: [\"setContext\"]\n      }],\n      MEASURE: {\n        actions: [\"measureHeight\"]\n      }\n    },\n    entry: [\"invokeOnVisible\"],\n    activities: [\"trackHeight\"],\n    states: {\n      \"visible:updating\": {\n        tags: [\"visible\", \"updating\"],\n        after: {\n          0: \"visible\"\n        }\n      },\n      \"visible:persist\": {\n        tags: [\"visible\", \"paused\"],\n        on: {\n          RESUME: {\n            guard: not(\"isLoadingType\"),\n            target: \"visible\",\n            actions: [\"setCreatedAt\"]\n          },\n          DISMISS: \"dismissing\"\n        }\n      },\n      visible: {\n        tags: [\"visible\"],\n        after: {\n          VISIBLE_DURATION: \"dismissing\"\n        },\n        on: {\n          DISMISS: \"dismissing\",\n          PAUSE: {\n            target: \"visible:persist\",\n            actions: \"setRemainingDuration\"\n          }\n        }\n      },\n      dismissing: {\n        entry: \"invokeOnDismiss\",\n        after: {\n          REMOVE_DELAY: {\n            target: \"unmounted\",\n            actions: \"notifyParentToRemove\"\n          }\n        }\n      },\n      unmounted: {\n        entry: \"invokeOnUnmount\",\n        type: \"final\"\n      }\n    }\n  }, {\n    activities: {\n      trackHeight(ctx2, _evt, {\n        self\n      }) {\n        let cleanup;\n        raf(() => {\n          const rootEl = dom.getRootEl(ctx2);\n          if (!rootEl) return;\n          ctx2.mounted = true;\n          const ghosts = queryAll(rootEl, \"[data-ghost]\");\n          warn(ghosts.length !== 2, \"[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements\");\n          const syncHeight = () => {\n            const originalHeight = rootEl.style.height;\n            rootEl.style.height = \"auto\";\n            const newHeight = rootEl.getBoundingClientRect().height;\n            rootEl.style.height = originalHeight;\n            ctx2.height = newHeight;\n            self.sendParent({\n              type: \"UPDATE_HEIGHT\",\n              id: self.id,\n              height: newHeight,\n              placement: ctx2.placement\n            });\n          };\n          syncHeight();\n          const win = dom.getWin(ctx2);\n          const observer = new win.MutationObserver(syncHeight);\n          observer.observe(rootEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n          });\n          cleanup = () => observer.disconnect();\n        });\n        return () => cleanup?.();\n      }\n    },\n    guards: {\n      isChangingToLoading: (_, evt) => evt.toast?.type === \"loading\",\n      isLoadingType: ctx2 => ctx2.type === \"loading\",\n      hasTypeChanged: (ctx2, evt) => evt.toast?.type != null && evt.toast.type !== ctx2.type,\n      hasDurationChanged: (ctx2, evt) => evt.toast?.duration != null && evt.toast.duration !== ctx2.duration\n    },\n    delays: {\n      VISIBLE_DURATION: ctx2 => ctx2.remaining,\n      REMOVE_DELAY: ctx2 => ctx2.removeDelay\n    },\n    actions: {\n      measureHeight(ctx2, _evt, {\n        self\n      }) {\n        raf(() => {\n          const rootEl = dom.getRootEl(ctx2);\n          if (!rootEl) return;\n          ctx2.mounted = true;\n          const originalHeight = rootEl.style.height;\n          rootEl.style.height = \"auto\";\n          const newHeight = rootEl.getBoundingClientRect().height;\n          rootEl.style.height = originalHeight;\n          ctx2.height = newHeight;\n          self.sendParent({\n            type: \"UPDATE_HEIGHT\",\n            id: self.id,\n            height: newHeight,\n            placement: ctx2.placement\n          });\n        });\n      },\n      setRemainingDuration(ctx2) {\n        ctx2.remaining -= Date.now() - ctx2.createdAt;\n      },\n      setCreatedAt(ctx2) {\n        ctx2.createdAt = Date.now();\n      },\n      notifyParentToRemove(_ctx, _evt, {\n        self\n      }) {\n        self.sendParent({\n          type: \"REMOVE_TOAST\",\n          id: self.id\n        });\n      },\n      invokeOnDismiss(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"dismissing\"\n        });\n      },\n      invokeOnUnmount(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"unmounted\"\n        });\n      },\n      invokeOnVisible(ctx2) {\n        ctx2.onStatusChange?.({\n          status: \"visible\"\n        });\n      },\n      setContext(ctx2, evt) {\n        const duration2 = evt.toast?.duration;\n        const type2 = evt.toast?.type ?? ctx2.type;\n        const computedDuration2 = getToastDuration(duration2, type2);\n        Object.assign(ctx2, {\n          ...evt.toast,\n          duration: computedDuration2,\n          remaining: computedDuration2\n        });\n      }\n    }\n  });\n}\n\n// src/toast-group.machine.ts\nfunction groupMachine(userContext) {\n  const ctx = compact2(userContext);\n  return createMachine2({\n    id: \"toaster\",\n    initial: ctx.overlap ? \"overlap\" : \"stack\",\n    context: {\n      dir: \"ltr\",\n      max: Number.MAX_SAFE_INTEGER,\n      gap: 16,\n      pauseOnPageIdle: false,\n      hotkey: [\"altKey\", \"KeyT\"],\n      offsets: \"1rem\",\n      placement: \"bottom\",\n      removeDelay: 200,\n      ...ctx,\n      toasts: [],\n      lastFocusedEl: null,\n      isFocusWithin: false,\n      heights: []\n    },\n    computed: {\n      count: ctx2 => ctx2.toasts.length\n    },\n    activities: [\"trackDocumentVisibility\", \"trackHotKeyPress\"],\n    watch: {\n      toasts: [\"collapsedIfEmpty\", \"setDismissableBranch\"]\n    },\n    exit: [\"removeToasts\", \"clearDismissableBranch\", \"clearLastFocusedEl\"],\n    on: {\n      PAUSE_TOAST: {\n        actions: [\"pauseToast\"]\n      },\n      PAUSE_ALL: {\n        actions: [\"pauseToasts\"]\n      },\n      RESUME_TOAST: {\n        actions: [\"resumeToast\"]\n      },\n      RESUME_ALL: {\n        actions: [\"resumeToasts\"]\n      },\n      ADD_TOAST: {\n        guard: \"isWithinRange\",\n        actions: [\"createToast\", \"syncToastIndex\"]\n      },\n      UPDATE_TOAST: {\n        actions: [\"updateToast\"]\n      },\n      DISMISS_TOAST: {\n        actions: [\"dismissToast\"]\n      },\n      DISMISS_ALL: {\n        actions: [\"dismissToasts\"]\n      },\n      REMOVE_TOAST: {\n        actions: [\"removeToast\", \"syncToastIndex\", \"syncToastOffset\"]\n      },\n      REMOVE_ALL: {\n        actions: [\"removeToasts\"]\n      },\n      UPDATE_HEIGHT: {\n        actions: [\"syncHeights\", \"syncToastOffset\"]\n      },\n      \"DOC.HOTKEY\": {\n        actions: [\"focusRegionEl\"]\n      },\n      \"REGION.BLUR\": [{\n        guard: \"isOverlapping\",\n        target: \"overlap\",\n        actions: [\"resumeToasts\", \"restoreLastFocusedEl\"]\n      }, {\n        actions: [\"resumeToasts\", \"restoreLastFocusedEl\"]\n      }]\n    },\n    states: {\n      stack: {\n        entry: [\"expandToasts\"],\n        on: {\n          \"REGION.POINTER_LEAVE\": [{\n            guard: \"isOverlapping\",\n            target: \"overlap\",\n            actions: [\"resumeToasts\"]\n          }, {\n            actions: [\"resumeToasts\"]\n          }],\n          \"REGION.OVERLAP\": {\n            target: \"overlap\"\n          },\n          \"REGION.FOCUS\": {\n            actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n          },\n          \"REGION.POINTER_ENTER\": {\n            actions: [\"pauseToasts\"]\n          }\n        }\n      },\n      overlap: {\n        entry: [\"collapseToasts\"],\n        on: {\n          \"REGION.STACK\": {\n            target: \"stack\"\n          },\n          \"REGION.POINTER_ENTER\": {\n            target: \"stack\",\n            actions: [\"pauseToasts\"]\n          },\n          \"REGION.FOCUS\": {\n            target: \"stack\",\n            actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isWithinRange: ctx2 => ctx2.toasts.length < ctx2.max,\n      isOverlapping: ctx2 => !!ctx2.overlap\n    },\n    activities: {\n      trackHotKeyPress(ctx2, _evt, {\n        send\n      }) {\n        const handleKeyDown = event => {\n          const isHotkeyPressed = ctx2.hotkey.every(key => event[key] || event.code === key);\n          if (!isHotkeyPressed) return;\n          send({\n            type: \"DOC.HOTKEY\"\n          });\n        };\n        return addDomEvent(document, \"keydown\", handleKeyDown, {\n          capture: true\n        });\n      },\n      trackDocumentVisibility(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.pauseOnPageIdle) return;\n        const doc = dom.getDoc(ctx2);\n        return addDomEvent(doc, \"visibilitychange\", () => {\n          send(doc.visibilityState === \"hidden\" ? \"PAUSE_ALL\" : \"RESUME_ALL\");\n        });\n      }\n    },\n    actions: {\n      setDismissableBranch(ctx2) {\n        const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);\n        const hasToasts = currentToasts.length > 0;\n        if (!hasToasts) {\n          ctx2._cleanup?.();\n          return;\n        }\n        if (hasToasts && ctx2._cleanup) {\n          return;\n        }\n        const groupEl = () => dom.getRegionEl(ctx2, ctx2.placement);\n        ctx2._cleanup = trackDismissableBranch(groupEl, {\n          defer: true\n        });\n      },\n      clearDismissableBranch(ctx2) {\n        ctx2._cleanup?.();\n      },\n      focusRegionEl(ctx2) {\n        queueMicrotask(() => {\n          dom.getRegionEl(ctx2, ctx2.placement)?.focus();\n        });\n      },\n      expandToasts(ctx2) {\n        each(ctx2, toast => {\n          toast.state.context.stacked = true;\n        });\n      },\n      collapseToasts(ctx2) {\n        each(ctx2, toast => {\n          toast.state.context.stacked = false;\n        });\n      },\n      collapsedIfEmpty(ctx2, _evt, {\n        send\n      }) {\n        if (!ctx2.overlap || ctx2.toasts.length > 1) return;\n        send(\"REGION.OVERLAP\");\n      },\n      pauseToast(_ctx, evt, {\n        self\n      }) {\n        self.sendChild(\"PAUSE\", evt.id);\n      },\n      pauseToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"PAUSE\"));\n      },\n      resumeToast(_ctx, evt, {\n        self\n      }) {\n        self.sendChild(\"RESUME\", evt.id);\n      },\n      resumeToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"RESUME\"));\n      },\n      measureToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"MEASURE\"));\n      },\n      createToast(ctx2, evt, {\n        self,\n        getState\n      }) {\n        const options = {\n          placement: ctx2.placement,\n          duration: ctx2.duration,\n          removeDelay: ctx2.removeDelay,\n          ...evt.toast,\n          dir: ctx2.dir,\n          getRootNode: ctx2.getRootNode,\n          stacked: getState().matches(\"stack\")\n        };\n        const toast = createToastMachine(options);\n        const actor = self.spawn(toast);\n        ctx2.toasts = [actor, ...ctx2.toasts];\n      },\n      updateToast(_ctx, evt, {\n        self\n      }) {\n        self.sendChild({\n          type: \"UPDATE\",\n          toast: evt.toast\n        }, evt.id);\n      },\n      dismissToast(_ctx, evt, {\n        self\n      }) {\n        self.sendChild(\"DISMISS\", evt.id);\n      },\n      dismissToasts(ctx2) {\n        ctx2.toasts.forEach(toast => toast.send(\"DISMISS\"));\n      },\n      removeToast(ctx2, evt, {\n        self\n      }) {\n        self.stopChild(evt.id);\n        ctx2.toasts = ctx2.toasts.filter(toast => toast.id !== evt.id);\n        ctx2.heights = ctx2.heights.filter(height => height.id !== evt.id);\n      },\n      removeToasts(ctx2, _evt, {\n        self\n      }) {\n        ctx2.toasts.forEach(toast => self.stopChild(toast.id));\n        ctx2.toasts = [];\n        ctx2.heights = [];\n      },\n      syncHeights(ctx2, evt) {\n        const existing = ctx2.heights.find(height => height.id === evt.id);\n        if (existing) {\n          existing.height = evt.height;\n          existing.placement = evt.placement;\n        } else {\n          const newHeight = {\n            id: evt.id,\n            height: evt.height,\n            placement: evt.placement\n          };\n          ctx2.heights = [newHeight, ...ctx2.heights];\n        }\n      },\n      syncToastIndex(ctx2) {\n        each(ctx2, (toast, index, toasts) => {\n          toast.state.context.index = index;\n          toast.state.context.frontmost = index === 0;\n          toast.state.context.zIndex = toasts.length - index;\n        });\n      },\n      syncToastOffset(ctx2, evt) {\n        const placement = evt.placement ?? ctx2.placement;\n        each({\n          ...ctx2,\n          placement\n        }, toast => {\n          const heightIndex = Math.max(ctx2.heights.findIndex(height => height.id === toast.id), 0);\n          const toastsHeightBefore = ctx2.heights.reduce((prev, curr, reducerIndex) => {\n            if (reducerIndex >= heightIndex) return prev;\n            return prev + curr.height;\n          }, 0);\n          toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;\n        });\n      },\n      setLastFocusedEl(ctx2, evt) {\n        if (ctx2.isFocusWithin || !evt.target) return;\n        ctx2.isFocusWithin = true;\n        ctx2.lastFocusedEl = ref(evt.target);\n      },\n      restoreLastFocusedEl(ctx2) {\n        ctx2.isFocusWithin = false;\n        if (!ctx2.lastFocusedEl) return;\n        ctx2.lastFocusedEl.focus({\n          preventScroll: true\n        });\n        ctx2.lastFocusedEl = null;\n      },\n      clearLastFocusedEl(ctx2) {\n        if (!ctx2.lastFocusedEl) return;\n        ctx2.lastFocusedEl.focus({\n          preventScroll: true\n        });\n        ctx2.lastFocusedEl = null;\n        ctx2.isFocusWithin = false;\n      }\n    }\n  });\n}\nfunction each(ctx, fn) {\n  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);\n  currentToasts.forEach(fn);\n}\n\n// src/toast.connect.ts\nimport { dataAttr } from \"@zag-js/dom-query\";\nfunction connect(state, send, normalize) {\n  const visible = state.hasTag(\"visible\");\n  const paused = state.hasTag(\"paused\");\n  const placement = state.context.placement;\n  const type = state.context.type;\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return {\n    type,\n    title: state.context.title,\n    description: state.context.description,\n    placement,\n    visible,\n    paused,\n    pause() {\n      send(\"PAUSE\");\n    },\n    resume() {\n      send(\"RESUME\");\n    },\n    dismiss() {\n      send(\"DISMISS\");\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-state\": visible ? \"open\" : \"closed\",\n        \"data-type\": type,\n        \"data-placement\": placement,\n        \"data-align\": align,\n        \"data-side\": side,\n        \"data-mounted\": dataAttr(state.context.mounted),\n        \"data-paused\": dataAttr(paused),\n        \"data-first\": dataAttr(state.context.frontmost),\n        \"data-sibling\": dataAttr(!state.context.frontmost),\n        \"data-stack\": dataAttr(state.context.stacked),\n        \"data-overlap\": dataAttr(!state.context.stacked),\n        role: \"status\",\n        \"aria-atomic\": \"true\",\n        \"aria-describedby\": state.context.description ? dom.getDescriptionId(state.context) : void 0,\n        \"aria-labelledby\": state.context.title ? dom.getTitleId(state.context) : void 0,\n        tabIndex: 0,\n        style: getPlacementStyle(state.context, visible),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (event.key == \"Escape\") {\n            send(\"DISMISS\");\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    /* Leave a ghost div to avoid setting hover to false when transitioning out */\n    getGhostBeforeProps() {\n      return normalize.element({\n        \"data-ghost\": \"before\",\n        style: getGhostBeforeStyle(state.context, visible)\n      });\n    },\n    /* Needed to avoid setting hover to false when in between toasts */\n    getGhostAfterProps() {\n      return normalize.element({\n        \"data-ghost\": \"after\",\n        style: getGhostAfterStyle(state.context, visible)\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: dom.getTitleId(state.context)\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: dom.getDescriptionId(state.context)\n      });\n    },\n    getActionTriggerProps() {\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"DISMISS\");\n        }\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        id: dom.getCloseTriggerId(state.context),\n        ...parts.closeTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": \"Dismiss notification\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send(\"DISMISS\");\n        }\n      });\n    }\n  };\n}\n\n// src/index.ts\nvar group = {\n  connect: groupConnect,\n  machine: groupMachine\n};\nexport { anatomy, connect, createToastMachine as createMachine, group };","map":{"version":3,"names":["isMachine","subscribe","contains","runIfFn","uuid","createAnatomy","anatomy","parts","build","createScope","dom","getRegionId","placement","getRegionEl","ctx","getById","getRootId","id","getRootEl","getTitleId","getDescriptionId","getCloseTriggerId","MAX_Z_INDEX","getToastsByPlacement","toasts","filter","toast","state","context","defaultTimeouts","info","error","success","loading","Infinity","DEFAULT","getToastDuration","duration","type","getGroupPlacementStyle","offset","offsets","computedOffset","left","right","bottom","top","rtl","dir","computedPlacement","replace","isRighty","includes","isLefty","styles","position","pointerEvents","count","display","flexDirection","gap","heights","height","zIndex","alignItems","offset2","insetInlineEnd","insetInlineStart","getPlacementStyle","visible","side","split","sibling","frontmost","overlap","stacked","removeDelay","Number","MAX_SAFE_INTEGER","index","assign","overrides","Object","mounted","getGhostBeforeStyle","inset","scale","getGhostAfterStyle","_ctx","_visible","width","groupConnect","serviceOrState","send","normalize","getState","result","getToastsByPlacementImpl","isVisible","length","find","create","options","uid","update","upsert","dismiss","getCount","getPlacements","placements","map","Array","from","Set","remove","dismissByPlacement","forEach","promise","shared","then","response","successOptions","catch","errorOptions","finally","pause","resume","getGroupProps","label","hotkeyLabel","hotkey","join","align","element","group","attrs","tabIndex","role","style","onMouseMove","onMouseLeave","onFocus","event","target","relatedTarget","onBlur","isFocusWithin","currentTarget","fn","contexts","createMachine","createMachine2","ref","trackDismissableBranch","addDomEvent","compact","compact2","guards","queryAll","raf","warn","not","and","or","createToastMachine","restProps","computedDuration","remaining","createdAt","Date","now","initial","on","UPDATE","guard","actions","MEASURE","entry","activities","states","tags","after","RESUME","DISMISS","VISIBLE_DURATION","PAUSE","dismissing","REMOVE_DELAY","unmounted","trackHeight","ctx2","_evt","self","cleanup","rootEl","ghosts","syncHeight","originalHeight","newHeight","getBoundingClientRect","sendParent","win","getWin","observer","MutationObserver","observe","childList","subtree","characterData","disconnect","isChangingToLoading","_","evt","isLoadingType","hasTypeChanged","hasDurationChanged","delays","measureHeight","setRemainingDuration","setCreatedAt","notifyParentToRemove","invokeOnDismiss","onStatusChange","status","invokeOnUnmount","invokeOnVisible","setContext","duration2","type2","computedDuration2","groupMachine","userContext","max","pauseOnPageIdle","lastFocusedEl","computed","watch","exit","PAUSE_TOAST","PAUSE_ALL","RESUME_TOAST","RESUME_ALL","ADD_TOAST","UPDATE_TOAST","DISMISS_TOAST","DISMISS_ALL","REMOVE_TOAST","REMOVE_ALL","UPDATE_HEIGHT","stack","isWithinRange","isOverlapping","trackHotKeyPress","handleKeyDown","isHotkeyPressed","every","key","code","document","capture","trackDocumentVisibility","doc","getDoc","visibilityState","setDismissableBranch","currentToasts","hasToasts","_cleanup","groupEl","defer","clearDismissableBranch","focusRegionEl","queueMicrotask","focus","expandToasts","each","collapseToasts","collapsedIfEmpty","pauseToast","sendChild","pauseToasts","resumeToast","resumeToasts","measureToasts","createToast","getRootNode","matches","actor","spawn","updateToast","dismissToast","dismissToasts","removeToast","stopChild","removeToasts","syncHeights","existing","syncToastIndex","syncToastOffset","heightIndex","Math","findIndex","toastsHeightBefore","reduce","prev","curr","reducerIndex","setLastFocusedEl","restoreLastFocusedEl","preventScroll","clearLastFocusedEl","dataAttr","connect","hasTag","paused","title","description","getRootProps","root","onKeyDown","defaultPrevented","preventDefault","getGhostBeforeProps","getGhostAfterProps","getTitleProps","getDescriptionProps","getActionTriggerProps","button","actionTrigger","onClick","getCloseTriggerProps","closeTrigger","machine"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast-group.connect.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.anatomy.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.dom.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast-group.machine.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.machine.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/toast.connect.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/toast/src/index.ts"],"sourcesContent":["import { isMachine, subscribe } from \"@zag-js/core\"\nimport { contains } from \"@zag-js/dom-query\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { runIfFn, uuid } from \"@zag-js/utils\"\nimport { parts } from \"./toast.anatomy\"\nimport { dom } from \"./toast.dom\"\nimport type { GroupMachineApi, GroupSend, GroupService, GroupState, Options, Placement } from \"./toast.types\"\nimport { getGroupPlacementStyle, getToastsByPlacement } from \"./toast.utils\"\n\nexport function groupConnect<T extends PropTypes, O = any>(\n  serviceOrState: GroupState<O> | GroupService<O>,\n  send: GroupSend,\n  normalize: NormalizeProps<T>,\n): GroupMachineApi<T, O> {\n  //\n\n  function getState(): GroupState<O> {\n    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState\n    return result as GroupState<O>\n  }\n\n  function getToastsByPlacementImpl(placement: Placement) {\n    return getToastsByPlacement(getState().context.toasts, placement)\n  }\n\n  function isVisible(id: string) {\n    const toasts = getState().context.toasts\n    if (!toasts.length) return false\n    return !!toasts.find((toast) => toast.id == id)\n  }\n\n  function create(options: Options<O>) {\n    const uid = `toast:${uuid()}`\n    const id = options.id ? options.id : uid\n\n    if (isVisible(id)) return id\n    send({ type: \"ADD_TOAST\", toast: { ...options, id } })\n\n    return id\n  }\n\n  function update(id: string, options: Options<O>) {\n    if (!isVisible(id)) return id\n    send({ type: \"UPDATE_TOAST\", id, toast: options })\n    return id\n  }\n\n  function upsert(options: Options<O>) {\n    const { id } = options\n    const visible = id ? isVisible(id) : false\n    if (visible && id != null) {\n      return update(id, options)\n    } else {\n      return create(options)\n    }\n  }\n\n  function dismiss(id?: string) {\n    if (id == null) {\n      send(\"DISMISS_ALL\")\n    } else if (isVisible(id)) {\n      send({ type: \"DISMISS_TOAST\", id })\n    }\n  }\n\n  return {\n    getCount() {\n      return getState().context.count\n    },\n    getPlacements() {\n      const toasts = getState().context.toasts\n      const placements = toasts.map((toast) => toast.state.context.placement!)\n      return Array.from(new Set(placements))\n    },\n    getToastsByPlacement: getToastsByPlacementImpl,\n    isVisible,\n    create,\n    update,\n    upsert,\n    dismiss,\n\n    remove(id) {\n      if (id == null) {\n        send(\"REMOVE_ALL\")\n      } else if (isVisible(id)) {\n        send({ type: \"REMOVE_TOAST\", id })\n      }\n    },\n\n    dismissByPlacement(placement) {\n      const toasts = getToastsByPlacementImpl(placement)\n      toasts.forEach((toast) => dismiss(toast.id))\n    },\n    loading(options) {\n      return upsert({ ...options, type: \"loading\" })\n    },\n    success(options) {\n      return upsert({ ...options, type: \"success\" })\n    },\n    error(options) {\n      return upsert({ ...options, type: \"error\" })\n    },\n\n    promise(promise, options, shared = {}) {\n      const id = upsert({ ...shared, ...options.loading, type: \"loading\" })\n\n      runIfFn(promise)\n        .then((response) => {\n          const successOptions = runIfFn(options.success, response)\n          upsert({ ...shared, ...successOptions, id, type: \"success\" })\n        })\n        .catch((error) => {\n          const errorOptions = runIfFn(options.error, error)\n          upsert({ ...shared, ...errorOptions, id, type: \"error\" })\n        })\n        .finally(() => {\n          options.finally?.()\n        })\n\n      return id\n    },\n\n    pause(id) {\n      if (id == null) {\n        send(\"PAUSE_ALL\")\n      } else if (isVisible(id)) {\n        send({ type: \"PAUSE_TOAST\", id })\n      }\n    },\n\n    resume(id) {\n      if (id == null) {\n        send(\"RESUME_ALL\")\n      } else if (isVisible(id)) {\n        send({ type: \"RESUME_TOAST\", id })\n      }\n    },\n\n    getGroupProps(options) {\n      const { placement, label = \"Notifications\" } = options\n      const state = getState()\n      const hotkeyLabel = state.context.hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\")\n      const [side, align = \"center\"] = placement.split(\"-\")\n\n      return normalize.element({\n        ...parts.group.attrs,\n        dir: state.context.dir,\n        tabIndex: -1,\n        \"aria-label\": `${placement} ${label} ${hotkeyLabel}`,\n        id: dom.getRegionId(placement),\n        \"data-placement\": placement,\n        \"data-side\": side,\n        \"data-align\": align,\n        \"aria-live\": \"polite\",\n        role: \"region\",\n        style: getGroupPlacementStyle(state.context, placement),\n        onMouseMove() {\n          send({ type: \"REGION.POINTER_ENTER\", placement })\n        },\n        onMouseLeave() {\n          send({ type: \"REGION.POINTER_LEAVE\", placement })\n        },\n        onFocus(event) {\n          send({ type: \"REGION.FOCUS\", target: event.relatedTarget })\n        },\n        onBlur(event) {\n          if (state.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {\n            send({ type: \"REGION.BLUR\" })\n          }\n        },\n      })\n    },\n\n    subscribe(fn) {\n      const state = getState()\n      return subscribe(state.context.toasts, () => {\n        const toasts = getToastsByPlacementImpl(state.context.placement)\n        const contexts = toasts.map((toast) => toast.getState().context)\n        fn(contexts)\n      })\n    },\n  }\n}\n","import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"toast\").parts(\n  \"group\",\n  \"root\",\n  \"title\",\n  \"description\",\n  \"actionTrigger\",\n  \"closeTrigger\",\n)\n\nexport const parts = anatomy.build()\n","import { createScope } from \"@zag-js/dom-query\"\nimport type { MachineContext as Ctx, Placement, GroupMachineContext as GroupCtx } from \"./toast.types\"\n\nexport const dom = createScope({\n  getRegionId: (placement: Placement) => `toast-group:${placement}`,\n  getRegionEl: (ctx: GroupCtx, placement: Placement) => dom.getById(ctx, `toast-group:${placement}`),\n\n  getRootId: (ctx: Ctx) => `toast:${ctx.id}`,\n  getRootEl: (ctx: Ctx) => dom.getById(ctx, dom.getRootId(ctx)),\n  getTitleId: (ctx: Ctx) => `toast:${ctx.id}:title`,\n  getDescriptionId: (ctx: Ctx) => `toast:${ctx.id}:description`,\n  getCloseTriggerId: (ctx: Ctx) => `toast${ctx.id}:close`,\n})\n","import { MAX_Z_INDEX } from \"@zag-js/dom-query\"\nimport type { Style } from \"@zag-js/types\"\nimport type { GroupMachineContext, MachineContext, Placement, Service, Type } from \"./toast.types\"\n\nexport function getToastsByPlacement<T>(toasts: Service<T>[], placement: Placement) {\n  return toasts.filter((toast) => toast.state.context.placement === placement)\n}\n\nexport const defaultTimeouts: Record<Type, number> = {\n  info: 5000,\n  error: 5000,\n  success: 2000,\n  loading: Infinity,\n  DEFAULT: 5000,\n}\n\nexport function getToastDuration(duration: number | undefined, type: NonNullable<MachineContext[\"type\"]>) {\n  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT\n}\n\nexport function getGroupPlacementStyle<T>(ctx: GroupMachineContext<T>, placement: Placement): Style {\n  const offset = ctx.offsets\n  const computedOffset =\n    typeof offset === \"string\" ? { left: offset, right: offset, bottom: offset, top: offset } : offset\n\n  const rtl = ctx.dir === \"rtl\"\n  const computedPlacement = placement\n    .replace(\"-start\", rtl ? \"-right\" : \"-left\")\n    .replace(\"-end\", rtl ? \"-left\" : \"-right\")\n\n  const isRighty = computedPlacement.includes(\"right\")\n  const isLefty = computedPlacement.includes(\"left\")\n\n  const styles: Style = {\n    position: \"fixed\",\n    pointerEvents: ctx.count > 0 ? undefined : \"none\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"--gap\": `${ctx.gap}px`,\n    \"--first-height\": `${ctx.heights[0]?.height || 0}px`,\n    zIndex: MAX_Z_INDEX,\n  }\n\n  let alignItems: Style[\"alignItems\"] = \"center\"\n  if (isRighty) alignItems = \"flex-end\"\n  if (isLefty) alignItems = \"flex-start\"\n\n  styles.alignItems = alignItems\n\n  if (computedPlacement.includes(\"top\")) {\n    const offset = computedOffset.top\n    styles.top = `max(env(safe-area-inset-top, 0px), ${offset})`\n  }\n\n  if (computedPlacement.includes(\"bottom\")) {\n    const offset = computedOffset.bottom\n    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset})`\n  }\n\n  if (!computedPlacement.includes(\"left\")) {\n    const offset = computedOffset.right\n    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset})`\n  }\n\n  if (!computedPlacement.includes(\"right\")) {\n    const offset = computedOffset.left\n    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset})`\n  }\n\n  return styles\n}\n\nexport function getPlacementStyle<T>(ctx: MachineContext<T>, visible: boolean): Style {\n  const [side] = ctx.placement!.split(\"-\")\n  const sibling = !ctx.frontmost\n  const overlap = !ctx.stacked\n\n  const styles: Style = {\n    position: \"absolute\",\n    pointerEvents: \"auto\",\n    \"--opacity\": \"0\",\n    \"--remove-delay\": `${ctx.removeDelay}ms`,\n    \"--duration\": `${ctx.type === \"loading\" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,\n    \"--initial-height\": `${ctx.height}px`,\n    \"--offset\": `${ctx.offset}px`,\n    \"--index\": ctx.index,\n    \"--z-index\": ctx.zIndex,\n    \"--lift-amount\": \"calc(var(--lift) * var(--gap))\",\n    \"--y\": \"100%\",\n    \"--x\": \"0\",\n  }\n\n  const assign = (overrides: Style) => Object.assign(styles, overrides)\n\n  if (side === \"top\") {\n    //\n    assign({\n      top: \"0\",\n      \"--sign\": \"-1\",\n      \"--y\": \"-100%\",\n      \"--lift\": \"1\",\n    })\n    //\n  } else if (side === \"bottom\") {\n    //\n    assign({\n      bottom: \"0\",\n      \"--sign\": \"1\",\n      \"--y\": \"100%\",\n      \"--lift\": \"-1\",\n    })\n  }\n\n  if (ctx.mounted) {\n    assign({\n      \"--y\": \"0\",\n      \"--opacity\": \"1\",\n    })\n\n    if (ctx.stacked) {\n      assign({\n        \"--y\": \"calc(var(--lift) * var(--offset))\",\n        \"--height\": \"var(--initial-height)\",\n      })\n    }\n  }\n\n  if (!visible) {\n    assign({\n      \"--opacity\": \"0\",\n      pointerEvents: \"none\",\n    })\n  }\n\n  if (sibling && overlap) {\n    assign({\n      \"--base-scale\": \"var(--index) * 0.05 + 1\",\n      \"--y\": \"calc(var(--lift-amount) * var(--index))\",\n      \"--scale\": \"calc(-1 * var(--base-scale))\",\n      \"--height\": \"var(--first-height)\",\n    })\n\n    if (!visible) {\n      assign({\n        \"--y\": \"calc(var(--sign) * 40%)\",\n      })\n    }\n  }\n\n  if (sibling && ctx.stacked && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * var(--offset) + var(--lift) * -100%)\",\n    })\n  }\n\n  if (ctx.frontmost && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * -100%)\",\n    })\n  }\n\n  return styles\n}\n\nexport function getGhostBeforeStyle<T>(ctx: MachineContext<T>, visible: boolean): Style {\n  const styles: Style = {\n    position: \"absolute\",\n    inset: \"0\",\n    scale: \"1 2\",\n    pointerEvents: visible ? \"none\" : \"auto\",\n  }\n\n  const assign = (overrides: Style) => Object.assign(styles, overrides)\n\n  if (ctx.frontmost && !visible) {\n    assign({\n      height: \"calc(var(--initial-height) + 80%)\",\n    })\n  }\n\n  return styles\n}\n\nexport function getGhostAfterStyle<T>(_ctx: MachineContext<T>, _visible: boolean): Style {\n  return {\n    position: \"absolute\",\n    left: \"0\",\n    height: \"calc(var(--gap) + 2px)\",\n    bottom: \"100%\",\n    width: \"100%\",\n  }\n}\n","import { createMachine, ref } from \"@zag-js/core\"\nimport { trackDismissableBranch } from \"@zag-js/dismissable\"\nimport { addDomEvent } from \"@zag-js/dom-event\"\nimport { compact } from \"@zag-js/utils\"\nimport { dom } from \"./toast.dom\"\nimport { createToastMachine } from \"./toast.machine\"\nimport type {\n  GroupMachineContext,\n  GroupMachineState,\n  MachineContext,\n  Service,\n  UserDefinedGroupContext,\n} from \"./toast.types\"\nimport { getToastsByPlacement } from \"./toast.utils\"\n\nexport function groupMachine<T = any>(userContext: UserDefinedGroupContext) {\n  const ctx = compact(userContext)\n  return createMachine<GroupMachineContext<T>, GroupMachineState>(\n    {\n      id: \"toaster\",\n      initial: ctx.overlap ? \"overlap\" : \"stack\",\n      context: {\n        dir: \"ltr\",\n        max: Number.MAX_SAFE_INTEGER,\n        gap: 16,\n        pauseOnPageIdle: false,\n        hotkey: [\"altKey\", \"KeyT\"],\n        offsets: \"1rem\",\n        placement: \"bottom\",\n        removeDelay: 200,\n        ...ctx,\n        toasts: [],\n        lastFocusedEl: null,\n        isFocusWithin: false,\n        heights: [],\n      },\n\n      computed: {\n        count: (ctx) => ctx.toasts.length,\n      },\n\n      activities: [\"trackDocumentVisibility\", \"trackHotKeyPress\"],\n\n      watch: {\n        toasts: [\"collapsedIfEmpty\", \"setDismissableBranch\"],\n      },\n\n      exit: [\"removeToasts\", \"clearDismissableBranch\", \"clearLastFocusedEl\"],\n\n      on: {\n        PAUSE_TOAST: {\n          actions: [\"pauseToast\"],\n        },\n        PAUSE_ALL: {\n          actions: [\"pauseToasts\"],\n        },\n        RESUME_TOAST: {\n          actions: [\"resumeToast\"],\n        },\n        RESUME_ALL: {\n          actions: [\"resumeToasts\"],\n        },\n        ADD_TOAST: {\n          guard: \"isWithinRange\",\n          actions: [\"createToast\", \"syncToastIndex\"],\n        },\n        UPDATE_TOAST: {\n          actions: [\"updateToast\"],\n        },\n        DISMISS_TOAST: {\n          actions: [\"dismissToast\"],\n        },\n        DISMISS_ALL: {\n          actions: [\"dismissToasts\"],\n        },\n        REMOVE_TOAST: {\n          actions: [\"removeToast\", \"syncToastIndex\", \"syncToastOffset\"],\n        },\n        REMOVE_ALL: {\n          actions: [\"removeToasts\"],\n        },\n        UPDATE_HEIGHT: {\n          actions: [\"syncHeights\", \"syncToastOffset\"],\n        },\n        \"DOC.HOTKEY\": {\n          actions: [\"focusRegionEl\"],\n        },\n        \"REGION.BLUR\": [\n          {\n            guard: \"isOverlapping\",\n            target: \"overlap\",\n            actions: [\"resumeToasts\", \"restoreLastFocusedEl\"],\n          },\n          {\n            actions: [\"resumeToasts\", \"restoreLastFocusedEl\"],\n          },\n        ],\n      },\n\n      states: {\n        stack: {\n          entry: [\"expandToasts\"],\n          on: {\n            \"REGION.POINTER_LEAVE\": [\n              {\n                guard: \"isOverlapping\",\n                target: \"overlap\",\n                actions: [\"resumeToasts\"],\n              },\n              {\n                actions: [\"resumeToasts\"],\n              },\n            ],\n            \"REGION.OVERLAP\": {\n              target: \"overlap\",\n            },\n            \"REGION.FOCUS\": {\n              actions: [\"setLastFocusedEl\", \"pauseToasts\"],\n            },\n            \"REGION.POINTER_ENTER\": {\n              actions: [\"pauseToasts\"],\n            },\n          },\n        },\n        overlap: {\n          entry: [\"collapseToasts\"],\n          on: {\n            \"REGION.STACK\": {\n              target: \"stack\",\n            },\n            \"REGION.POINTER_ENTER\": {\n              target: \"stack\",\n              actions: [\"pauseToasts\"],\n            },\n            \"REGION.FOCUS\": {\n              target: \"stack\",\n              actions: [\"setLastFocusedEl\", \"pauseToasts\"],\n            },\n          },\n        },\n      },\n    },\n    {\n      guards: {\n        isWithinRange: (ctx) => ctx.toasts.length < ctx.max,\n        isOverlapping: (ctx) => !!ctx.overlap,\n      },\n      activities: {\n        trackHotKeyPress(ctx, _evt, { send }) {\n          const handleKeyDown = (event: KeyboardEvent) => {\n            const isHotkeyPressed = ctx.hotkey.every((key) => (event as any)[key] || event.code === key)\n            if (!isHotkeyPressed) return\n            send({ type: \"DOC.HOTKEY\" })\n          }\n          return addDomEvent(document, \"keydown\", handleKeyDown, { capture: true })\n        },\n        trackDocumentVisibility(ctx, _evt, { send }) {\n          if (!ctx.pauseOnPageIdle) return\n          const doc = dom.getDoc(ctx)\n          return addDomEvent(doc, \"visibilitychange\", () => {\n            send(doc.visibilityState === \"hidden\" ? \"PAUSE_ALL\" : \"RESUME_ALL\")\n          })\n        },\n      },\n      actions: {\n        setDismissableBranch(ctx) {\n          const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement)\n          const hasToasts = currentToasts.length > 0\n\n          if (!hasToasts) {\n            ctx._cleanup?.()\n            return\n          }\n\n          if (hasToasts && ctx._cleanup) {\n            return\n          }\n\n          //  mark toast as a dismissable branch\n          //  so that interacting with them will not close dismissable layers\n          const groupEl = () => dom.getRegionEl(ctx, ctx.placement)\n          ctx._cleanup = trackDismissableBranch(groupEl, { defer: true })\n        },\n        clearDismissableBranch(ctx) {\n          ctx._cleanup?.()\n        },\n        focusRegionEl(ctx) {\n          queueMicrotask(() => {\n            dom.getRegionEl(ctx, ctx.placement)?.focus()\n          })\n        },\n        expandToasts(ctx) {\n          each(ctx, (toast) => {\n            toast.state.context.stacked = true\n          })\n        },\n        collapseToasts(ctx) {\n          each(ctx, (toast) => {\n            toast.state.context.stacked = false\n          })\n        },\n        collapsedIfEmpty(ctx, _evt, { send }) {\n          if (!ctx.overlap || ctx.toasts.length > 1) return\n          send(\"REGION.OVERLAP\")\n        },\n        pauseToast(_ctx, evt, { self }) {\n          self.sendChild(\"PAUSE\", evt.id)\n        },\n        pauseToasts(ctx) {\n          ctx.toasts.forEach((toast) => toast.send(\"PAUSE\"))\n        },\n        resumeToast(_ctx, evt, { self }) {\n          self.sendChild(\"RESUME\", evt.id)\n        },\n        resumeToasts(ctx) {\n          ctx.toasts.forEach((toast) => toast.send(\"RESUME\"))\n        },\n        measureToasts(ctx) {\n          ctx.toasts.forEach((toast) => toast.send(\"MEASURE\"))\n        },\n        createToast(ctx, evt, { self, getState }) {\n          const options: MachineContext<T> = {\n            placement: ctx.placement,\n            duration: ctx.duration,\n            removeDelay: ctx.removeDelay,\n            ...evt.toast,\n            dir: ctx.dir,\n            getRootNode: ctx.getRootNode,\n            stacked: getState().matches(\"stack\"),\n          }\n\n          const toast = createToastMachine(options)\n\n          const actor = self.spawn(toast)\n          ctx.toasts = [actor, ...ctx.toasts]\n        },\n        updateToast(_ctx, evt, { self }) {\n          self.sendChild({ type: \"UPDATE\", toast: evt.toast }, evt.id)\n        },\n        dismissToast(_ctx, evt, { self }) {\n          self.sendChild(\"DISMISS\", evt.id)\n        },\n        dismissToasts(ctx) {\n          ctx.toasts.forEach((toast) => toast.send(\"DISMISS\"))\n        },\n        removeToast(ctx, evt, { self }) {\n          self.stopChild(evt.id)\n          ctx.toasts = ctx.toasts.filter((toast) => toast.id !== evt.id)\n          ctx.heights = ctx.heights.filter((height) => height.id !== evt.id)\n        },\n        removeToasts(ctx, _evt, { self }) {\n          ctx.toasts.forEach((toast) => self.stopChild(toast.id))\n          ctx.toasts = []\n          ctx.heights = []\n        },\n        syncHeights(ctx, evt) {\n          const existing = ctx.heights.find((height) => height.id === evt.id)\n          if (existing) {\n            existing.height = evt.height\n            existing.placement = evt.placement\n          } else {\n            const newHeight = { id: evt.id, height: evt.height, placement: evt.placement }\n            ctx.heights = [newHeight, ...ctx.heights]\n          }\n        },\n        syncToastIndex(ctx) {\n          each(ctx, (toast, index, toasts) => {\n            // Note: This is an intentional side effect\n            // consider writing directly to the DOM (root element)\n            toast.state.context.index = index\n            toast.state.context.frontmost = index === 0\n            toast.state.context.zIndex = toasts.length - index\n          })\n        },\n        syncToastOffset(ctx, evt) {\n          const placement = evt.placement ?? ctx.placement\n\n          // Notify each toast of it's index\n          each({ ...ctx, placement }, (toast) => {\n            const heightIndex = Math.max(\n              ctx.heights.findIndex((height) => height.id === toast.id),\n              0,\n            )\n\n            // calculate offset until toast\n            const toastsHeightBefore = ctx.heights.reduce((prev, curr, reducerIndex) => {\n              if (reducerIndex >= heightIndex) return prev\n              return prev + curr.height\n            }, 0)\n\n            // Note: This is an intentional side effect\n            // consider writing directly to the DOM (root element)\n            toast.state.context.offset = heightIndex * ctx.gap + toastsHeightBefore\n          })\n        },\n        setLastFocusedEl(ctx, evt) {\n          if (ctx.isFocusWithin || !evt.target) return\n          ctx.isFocusWithin = true\n          ctx.lastFocusedEl = ref(evt.target)\n        },\n        restoreLastFocusedEl(ctx) {\n          ctx.isFocusWithin = false\n          if (!ctx.lastFocusedEl) return\n          ctx.lastFocusedEl.focus({ preventScroll: true })\n          ctx.lastFocusedEl = null\n        },\n        clearLastFocusedEl(ctx) {\n          if (!ctx.lastFocusedEl) return\n          ctx.lastFocusedEl.focus({ preventScroll: true })\n          ctx.lastFocusedEl = null\n          ctx.isFocusWithin = false\n        },\n      },\n    },\n  )\n}\n\nfunction each(ctx: GroupMachineContext, fn: (toast: Service<any>, index: number, arr: Service<any>[]) => void) {\n  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement)\n  currentToasts.forEach(fn)\n}\n","import { createMachine, guards } from \"@zag-js/core\"\nimport { queryAll, raf } from \"@zag-js/dom-query\"\nimport { compact, warn } from \"@zag-js/utils\"\nimport { dom } from \"./toast.dom\"\nimport type { MachineContext, MachineState, Options } from \"./toast.types\"\nimport { getToastDuration } from \"./toast.utils\"\n\nconst { not, and, or } = guards\n\nexport function createToastMachine<T>(options: Options<T>) {\n  const { type = \"info\", duration, id = \"1\", placement = \"bottom\", removeDelay = 200, ...restProps } = options\n  const ctx = compact(restProps)\n\n  const computedDuration = getToastDuration(duration, type)\n\n  return createMachine<MachineContext<T>, MachineState>(\n    {\n      id,\n      context: {\n        id,\n        type,\n        remaining: computedDuration,\n        duration: computedDuration,\n        removeDelay,\n        createdAt: Date.now(),\n        placement,\n        ...ctx,\n        height: 0,\n        offset: 0,\n        frontmost: false,\n        mounted: false,\n        index: -1,\n        zIndex: 0,\n      },\n\n      initial: type === \"loading\" ? \"visible:persist\" : \"visible\",\n\n      on: {\n        UPDATE: [\n          {\n            guard: and(\"hasTypeChanged\", \"isChangingToLoading\"),\n            target: \"visible:persist\",\n            actions: [\"setContext\"],\n          },\n          {\n            guard: or(\"hasDurationChanged\", \"hasTypeChanged\"),\n            target: \"visible:updating\",\n            actions: [\"setContext\"],\n          },\n          {\n            actions: [\"setContext\"],\n          },\n        ],\n        MEASURE: {\n          actions: [\"measureHeight\"],\n        },\n      },\n\n      entry: [\"invokeOnVisible\"],\n\n      activities: [\"trackHeight\"],\n\n      states: {\n        \"visible:updating\": {\n          tags: [\"visible\", \"updating\"],\n          after: {\n            0: \"visible\",\n          },\n        },\n\n        \"visible:persist\": {\n          tags: [\"visible\", \"paused\"],\n          on: {\n            RESUME: {\n              guard: not(\"isLoadingType\"),\n              target: \"visible\",\n              actions: [\"setCreatedAt\"],\n            },\n            DISMISS: \"dismissing\",\n          },\n        },\n\n        visible: {\n          tags: [\"visible\"],\n          after: {\n            VISIBLE_DURATION: \"dismissing\",\n          },\n          on: {\n            DISMISS: \"dismissing\",\n            PAUSE: {\n              target: \"visible:persist\",\n              actions: \"setRemainingDuration\",\n            },\n          },\n        },\n\n        dismissing: {\n          entry: \"invokeOnDismiss\",\n          after: {\n            REMOVE_DELAY: {\n              target: \"unmounted\",\n              actions: \"notifyParentToRemove\",\n            },\n          },\n        },\n\n        unmounted: {\n          entry: \"invokeOnUnmount\",\n          type: \"final\",\n        },\n      },\n    },\n    {\n      activities: {\n        trackHeight(ctx, _evt, { self }) {\n          let cleanup: VoidFunction\n          raf(() => {\n            const rootEl = dom.getRootEl(ctx)\n            if (!rootEl) return\n            ctx.mounted = true\n\n            const ghosts = queryAll(rootEl, \"[data-ghost]\")\n\n            warn(\n              ghosts.length !== 2,\n              \"[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements\",\n            )\n\n            const syncHeight = () => {\n              const originalHeight = rootEl.style.height\n              rootEl.style.height = \"auto\"\n              const newHeight = rootEl.getBoundingClientRect().height\n              rootEl.style.height = originalHeight\n\n              ctx.height = newHeight\n              self.sendParent({ type: \"UPDATE_HEIGHT\", id: self.id, height: newHeight, placement: ctx.placement })\n            }\n\n            syncHeight()\n\n            const win = dom.getWin(ctx)\n\n            const observer = new win.MutationObserver(syncHeight)\n            observer.observe(rootEl, { childList: true, subtree: true, characterData: true })\n\n            cleanup = () => observer.disconnect()\n          })\n\n          return () => cleanup?.()\n        },\n      },\n\n      guards: {\n        isChangingToLoading: (_, evt) => evt.toast?.type === \"loading\",\n        isLoadingType: (ctx) => ctx.type === \"loading\",\n        hasTypeChanged: (ctx, evt) => evt.toast?.type != null && evt.toast.type !== ctx.type,\n        hasDurationChanged: (ctx, evt) => evt.toast?.duration != null && evt.toast.duration !== ctx.duration,\n      },\n\n      delays: {\n        VISIBLE_DURATION: (ctx) => ctx.remaining,\n        REMOVE_DELAY: (ctx) => ctx.removeDelay,\n      },\n\n      actions: {\n        measureHeight(ctx, _evt, { self }) {\n          raf(() => {\n            const rootEl = dom.getRootEl(ctx)\n            if (!rootEl) return\n\n            ctx.mounted = true\n\n            const originalHeight = rootEl.style.height\n            rootEl.style.height = \"auto\"\n\n            const newHeight = rootEl.getBoundingClientRect().height\n            rootEl.style.height = originalHeight\n            ctx.height = newHeight\n\n            self.sendParent({ type: \"UPDATE_HEIGHT\", id: self.id, height: newHeight, placement: ctx.placement })\n          })\n        },\n        setRemainingDuration(ctx) {\n          ctx.remaining -= Date.now() - ctx.createdAt\n        },\n        setCreatedAt(ctx) {\n          ctx.createdAt = Date.now()\n        },\n        notifyParentToRemove(_ctx, _evt, { self }) {\n          self.sendParent({ type: \"REMOVE_TOAST\", id: self.id })\n        },\n        invokeOnDismiss(ctx) {\n          ctx.onStatusChange?.({ status: \"dismissing\" })\n        },\n        invokeOnUnmount(ctx) {\n          ctx.onStatusChange?.({ status: \"unmounted\" })\n        },\n        invokeOnVisible(ctx) {\n          ctx.onStatusChange?.({ status: \"visible\" })\n        },\n        setContext(ctx, evt) {\n          const duration = evt.toast?.duration\n          const type = evt.toast?.type ?? ctx.type\n\n          const computedDuration = getToastDuration(duration, type)\n\n          Object.assign(ctx, {\n            ...evt.toast,\n            duration: computedDuration,\n            remaining: computedDuration,\n          })\n        },\n      },\n    },\n  )\n}\n","import { dataAttr } from \"@zag-js/dom-query\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./toast.anatomy\"\nimport { dom } from \"./toast.dom\"\nimport type { MachineApi, Send, State } from \"./toast.types\"\nimport { getGhostAfterStyle, getGhostBeforeStyle, getPlacementStyle } from \"./toast.utils\"\n\nexport function connect<T extends PropTypes, O>(\n  state: State<O>,\n  send: Send,\n  normalize: NormalizeProps<T>,\n): MachineApi<T, O> {\n  const visible = state.hasTag(\"visible\")\n  const paused = state.hasTag(\"paused\")\n\n  const placement = state.context.placement!\n  const type = state.context.type!\n\n  const [side, align = \"center\"] = placement.split(\"-\")\n\n  return {\n    type: type,\n    title: state.context.title,\n    description: state.context.description,\n    placement,\n    visible: visible,\n    paused: paused,\n\n    pause() {\n      send(\"PAUSE\")\n    },\n\n    resume() {\n      send(\"RESUME\")\n    },\n\n    dismiss() {\n      send(\"DISMISS\")\n    },\n\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: state.context.dir,\n        id: dom.getRootId(state.context),\n        \"data-state\": visible ? \"open\" : \"closed\",\n        \"data-type\": type,\n        \"data-placement\": placement,\n        \"data-align\": align,\n        \"data-side\": side,\n        \"data-mounted\": dataAttr(state.context.mounted),\n        \"data-paused\": dataAttr(paused),\n\n        \"data-first\": dataAttr(state.context.frontmost),\n        \"data-sibling\": dataAttr(!state.context.frontmost),\n        \"data-stack\": dataAttr(state.context.stacked),\n        \"data-overlap\": dataAttr(!state.context.stacked),\n\n        role: \"status\",\n        \"aria-atomic\": \"true\",\n        \"aria-describedby\": state.context.description ? dom.getDescriptionId(state.context) : undefined,\n        \"aria-labelledby\": state.context.title ? dom.getTitleId(state.context) : undefined,\n        tabIndex: 0,\n        style: getPlacementStyle(state.context, visible),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return\n          if (event.key == \"Escape\") {\n            send(\"DISMISS\")\n            event.preventDefault()\n          }\n        },\n      })\n    },\n\n    /* Leave a ghost div to avoid setting hover to false when transitioning out */\n    getGhostBeforeProps() {\n      return normalize.element({\n        \"data-ghost\": \"before\",\n        style: getGhostBeforeStyle(state.context, visible),\n      })\n    },\n\n    /* Needed to avoid setting hover to false when in between toasts */\n    getGhostAfterProps() {\n      return normalize.element({\n        \"data-ghost\": \"after\",\n        style: getGhostAfterStyle(state.context, visible),\n      })\n    },\n\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: dom.getTitleId(state.context),\n      })\n    },\n\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: dom.getDescriptionId(state.context),\n      })\n    },\n\n    getActionTriggerProps() {\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return\n          send(\"DISMISS\")\n        },\n      })\n    },\n\n    getCloseTriggerProps() {\n      return normalize.button({\n        id: dom.getCloseTriggerId(state.context),\n        ...parts.closeTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": \"Dismiss notification\",\n        onClick(event) {\n          if (event.defaultPrevented) return\n          send(\"DISMISS\")\n        },\n      })\n    },\n  }\n}\n","import { groupConnect } from \"./toast-group.connect\"\nimport { groupMachine } from \"./toast-group.machine\"\nimport { createToastMachine as createMachine } from \"./toast.machine\"\n\nexport { anatomy } from \"./toast.anatomy\"\nexport { connect } from \"./toast.connect\"\nexport type {\n  MachineApi as Api,\n  GenericOptions,\n  GroupMachineApi as GroupApi,\n  GroupMachineContext,\n  GroupProps,\n  GroupService,\n  GroupState,\n  MachineContext,\n  Placement,\n  PromiseOptions,\n  Service,\n  StatusChangeDetails,\n  Options,\n  Status,\n  Type,\n} from \"./toast.types\"\nexport { createMachine }\n\nexport const group = {\n  connect: groupConnect,\n  machine: groupMachine,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}