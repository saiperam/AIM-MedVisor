{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/affine-transform.ts\nvar AffineTransform = class _AffineTransform {\n  constructor([m00, m01, m02, m10, m11, m12] = [0, 0, 0, 0, 0, 0]) {\n    __publicField(this, \"m00\");\n    __publicField(this, \"m01\");\n    __publicField(this, \"m02\");\n    __publicField(this, \"m10\");\n    __publicField(this, \"m11\");\n    __publicField(this, \"m12\");\n    __publicField(this, \"rotate\", (...args) => {\n      return this.prepend(_AffineTransform.rotate(...args));\n    });\n    __publicField(this, \"scale\", (...args) => {\n      return this.prepend(_AffineTransform.scale(...args));\n    });\n    __publicField(this, \"translate\", (...args) => {\n      return this.prepend(_AffineTransform.translate(...args));\n    });\n    this.m00 = m00;\n    this.m01 = m01;\n    this.m02 = m02;\n    this.m10 = m10;\n    this.m11 = m11;\n    this.m12 = m12;\n  }\n  applyTo(point) {\n    const {\n      x,\n      y\n    } = point;\n    const {\n      m00,\n      m01,\n      m02,\n      m10,\n      m11,\n      m12\n    } = this;\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12\n    };\n  }\n  prepend(other) {\n    return new _AffineTransform([this.m00 * other.m00 + this.m01 * other.m10,\n    // m00\n    this.m00 * other.m01 + this.m01 * other.m11,\n    // m01\n    this.m00 * other.m02 + this.m01 * other.m12 + this.m02,\n    // m02\n    this.m10 * other.m00 + this.m11 * other.m10,\n    // m10\n    this.m10 * other.m01 + this.m11 * other.m11,\n    // m11\n    this.m10 * other.m02 + this.m11 * other.m12 + this.m12\n    // m12\n    ]);\n  }\n  append(other) {\n    return new _AffineTransform([other.m00 * this.m00 + other.m01 * this.m10,\n    // m00\n    other.m00 * this.m01 + other.m01 * this.m11,\n    // m01\n    other.m00 * this.m02 + other.m01 * this.m12 + other.m02,\n    // m02\n    other.m10 * this.m00 + other.m11 * this.m10,\n    // m10\n    other.m10 * this.m01 + other.m11 * this.m11,\n    // m11\n    other.m10 * this.m02 + other.m11 * this.m12 + other.m12\n    // m12\n    ]);\n  }\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10;\n  }\n  get isInvertible() {\n    const det = this.determinant;\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;\n  }\n  invert() {\n    const det = this.determinant;\n    return new _AffineTransform([this.m11 / det,\n    // m00\n    -this.m01 / det,\n    // m01\n    (this.m01 * this.m12 - this.m11 * this.m02) / det,\n    // m02\n    -this.m10 / det,\n    // m10\n    this.m00 / det,\n    // m11\n    (this.m10 * this.m02 - this.m00 * this.m12) / det\n    // m12\n    ]);\n  }\n  get array() {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1];\n  }\n  get float32Array() {\n    return new Float32Array(this.array);\n  }\n  // Static\n  static get identity() {\n    return new _AffineTransform([1, 0, 0, 0, 1, 0]);\n  }\n  static rotate(theta, origin) {\n    const rotation = new _AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0]);\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), rotation, _AffineTransform.translate(-origin.x, -origin.y));\n    }\n    return rotation;\n  }\n  static scale(sx, sy = sx, origin = {\n    x: 0,\n    y: 0\n  }) {\n    const scale = new _AffineTransform([sx, 0, 0, 0, sy, 0]);\n    if (origin.x !== 0 || origin.y !== 0) {\n      return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), scale, _AffineTransform.translate(-origin.x, -origin.y));\n    }\n    return scale;\n  }\n  static translate(tx, ty) {\n    return new _AffineTransform([1, 0, tx, 0, 1, ty]);\n  }\n  static multiply(...[first, ...rest]) {\n    if (!first) return _AffineTransform.identity;\n    return rest.reduce((result, item) => result.prepend(item), first);\n  }\n  get a() {\n    return this.m00;\n  }\n  get b() {\n    return this.m10;\n  }\n  get c() {\n    return this.m01;\n  }\n  get d() {\n    return this.m11;\n  }\n  get tx() {\n    return this.m02;\n  }\n  get ty() {\n    return this.m12;\n  }\n  get scaleComponents() {\n    return {\n      x: this.a,\n      y: this.d\n    };\n  }\n  get translationComponents() {\n    return {\n      x: this.tx,\n      y: this.ty\n    };\n  }\n  get skewComponents() {\n    return {\n      x: this.c,\n      y: this.b\n    };\n  }\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;\n  }\n};\n\n// src/align.ts\nfunction hAlign(a, ref, h) {\n  let x = ref.minX;\n  if (h === \"left-inside\") x = ref.minX;\n  if (h === \"left-outside\") x = ref.minX - ref.width;\n  if (h === \"right-inside\") x = ref.maxX - ref.width;\n  if (h === \"right-outside\") x = ref.maxX;\n  if (h === \"center\") x = ref.midX - ref.width / 2;\n  return {\n    ...a,\n    x\n  };\n}\nfunction vAlign(a, ref, v) {\n  let y = ref.minY;\n  if (v === \"top-inside\") y = ref.minY;\n  if (v === \"top-outside\") y = ref.minY - a.height;\n  if (v === \"bottom-inside\") y = ref.maxY - a.height;\n  if (v === \"bottom-outside\") y = ref.maxY;\n  if (v === \"center\") y = ref.midY - a.height / 2;\n  return {\n    ...a,\n    y\n  };\n}\nfunction alignRect(a, ref, options) {\n  const {\n    h,\n    v\n  } = options;\n  return vAlign(hAlign(a, ref, h), ref, v);\n}\n\n// src/clamp.ts\nvar clamp = (value, min3, max2) => Math.min(Math.max(value, min3), max2);\nvar clampPoint = (position, size, boundaryRect) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width);\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height);\n  return {\n    x,\n    y\n  };\n};\nvar defaultMinSize = {\n  width: 0,\n  height: 0\n};\nvar defaultMaxSize = {\n  width: Infinity,\n  height: Infinity\n};\nvar clampSize = (size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize.width), maxSize.width),\n    height: Math.min(Math.max(size.height, minSize.height), maxSize.height)\n  };\n};\n\n// src/rect.ts\nvar createPoint = (x, y) => ({\n  x,\n  y\n});\nvar subtractPoints = (a, b) => createPoint(a.x - b.x, a.y - b.y);\nvar addPoints = (a, b) => createPoint(a.x + b.x, a.y + b.y);\nfunction isPoint(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\");\n}\nfunction createRect(r) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = r;\n  const midX = x + width / 2;\n  const midY = y + height / 2;\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY)\n  };\n}\nfunction isRect(v) {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\");\n}\nfunction getRectCenters(v) {\n  const top = createPoint(v.midX, v.minY);\n  const right = createPoint(v.maxX, v.midY);\n  const bottom = createPoint(v.midX, v.maxY);\n  const left = createPoint(v.minX, v.midY);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\nfunction getRectCorners(v) {\n  const top = createPoint(v.minX, v.minY);\n  const right = createPoint(v.maxX, v.minY);\n  const bottom = createPoint(v.maxX, v.maxY);\n  const left = createPoint(v.minX, v.maxY);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\nfunction getRectEdges(v) {\n  const c = getRectCorners(v);\n  const top = [c.top, c.right];\n  const right = [c.right, c.bottom];\n  const bottom = [c.left, c.bottom];\n  const left = [c.top, c.left];\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n}\n\n// src/intersection.ts\nfunction intersects(a, b) {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;\n}\nfunction intersection(a, b) {\n  const x = Math.max(a.x, b.x);\n  const y = Math.max(a.y, b.y);\n  const x2 = Math.min(a.x + a.width, b.x + b.width);\n  const y2 = Math.min(a.y + a.height, b.y + b.height);\n  return createRect({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y\n  });\n}\nfunction collisions(a, b) {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX\n  };\n}\n\n// src/distance.ts\nfunction distance(a, b = {\n  x: 0,\n  y: 0\n}) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\nfunction distanceFromPoint(r, p) {\n  let x = 0;\n  let y = 0;\n  if (p.x < r.x) x = r.x - p.x;else if (p.x > r.maxX) x = p.x - r.maxX;\n  if (p.y < r.y) y = r.y - p.y;else if (p.y > r.maxY) y = p.y - r.maxY;\n  return {\n    x,\n    y,\n    value: distance({\n      x,\n      y\n    })\n  };\n}\nfunction distanceFromRect(a, b) {\n  if (intersects(a, b)) return {\n    x: 0,\n    y: 0,\n    value: 0\n  };\n  const left = a.x < b.x ? a : b;\n  const right = b.x < a.x ? a : b;\n  const upper = a.y < b.y ? a : b;\n  const lower = b.y < a.y ? a : b;\n  let x = left.x === right.x ? 0 : right.x - left.maxX;\n  x = Math.max(0, x);\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;\n  y = Math.max(0, y);\n  return {\n    x,\n    y,\n    value: distance({\n      x,\n      y\n    })\n  };\n}\nfunction distanceBtwEdges(a, b) {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY\n  };\n}\n\n// src/closest.ts\nfunction closest(...pts) {\n  return a => {\n    const ds = pts.map(b => distance(b, a));\n    const c = Math.min.apply(Math, ds);\n    return pts[ds.indexOf(c)];\n  };\n}\nfunction closestSideToRect(ref, r) {\n  if (r.maxX <= ref.minX) return \"left\";\n  if (r.minX >= ref.maxX) return \"right\";\n  if (r.maxY <= ref.minY) return \"top\";\n  if (r.minY >= ref.maxY) return \"bottom\";\n  return \"left\";\n}\nfunction closestSideToPoint(ref, p) {\n  const {\n    x,\n    y\n  } = p;\n  const dl = x - ref.minX;\n  const dr = ref.maxX - x;\n  const dt = y - ref.minY;\n  const db = ref.maxY - y;\n  let closest2 = dl;\n  let side = \"left\";\n  if (dr < closest2) {\n    closest2 = dr;\n    side = \"right\";\n  }\n  if (dt < closest2) {\n    closest2 = dt;\n    side = \"top\";\n  }\n  if (db < closest2) {\n    side = \"bottom\";\n  }\n  return side;\n}\n\n// src/constrain.ts\nvar constrainRect = (rect, boundary) => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height)\n  };\n};\n\n// src/contains.ts\nfunction containsPoint(r, p) {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;\n}\nfunction containsRect(a, b) {\n  return Object.values(getRectCorners(b)).every(c => containsPoint(a, c));\n}\nfunction contains(r, v) {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v);\n}\n\n// src/equality.ts\nvar isSizeEqual = (a, b) => {\n  return a.width === b.width && a.height === b.height;\n};\nvar isPointEqual = (a, b) => {\n  return a.x === b.x && a.y === b.y;\n};\nvar isRectEqual = (a, b) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b);\n};\n\n// src/from-element.ts\nvar styleCache = /* @__PURE__ */new WeakMap();\nfunction getCacheComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window;\n    styleCache.set(el, win.getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\nfunction getElementRect(el, opts = {}) {\n  return createRect(getClientRect(el, opts));\n}\nfunction getClientRect(el, opts = {}) {\n  const {\n    excludeScrollbar = false,\n    excludeBorders = false\n  } = opts;\n  const {\n    x,\n    y,\n    width,\n    height\n  } = el.getBoundingClientRect();\n  const r = {\n    x,\n    y,\n    width,\n    height\n  };\n  const style = getCacheComputedStyle(el);\n  const {\n    borderLeftWidth,\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth);\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth);\n  if (excludeBorders) {\n    r.width -= borderXWidth;\n    r.height -= borderYWidth;\n    r.x += px(borderLeftWidth);\n    r.y += px(borderTopWidth);\n  }\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;\n    r.width -= scrollbarWidth;\n    r.height -= scrollbarHeight;\n  }\n  return r;\n}\nvar px = v => parseFloat(v.replace(\"px\", \"\"));\nvar sum = (...vals) => vals.reduce((sum2, v) => sum2 + (v ? px(v) : 0), 0);\n\n// src/from-points.ts\nfunction getRectFromPoints(...pts) {\n  const xs = pts.map(p => p.x);\n  const ys = pts.map(p => p.y);\n  const x = Math.min(...xs);\n  const y = Math.min(...ys);\n  const width = Math.max(...xs) - x;\n  const height = Math.max(...ys) - y;\n  return createRect({\n    x,\n    y,\n    width,\n    height\n  });\n}\n\n// src/union.ts\nvar {\n  min,\n  max\n} = Math;\nfunction union(...rs) {\n  const pMin = {\n    x: min(...rs.map(r => r.minX)),\n    y: min(...rs.map(r => r.minY))\n  };\n  const pMax = {\n    x: max(...rs.map(r => r.maxX)),\n    y: max(...rs.map(r => r.maxY))\n  };\n  return getRectFromPoints(pMin, pMax);\n}\n\n// src/from-range.ts\nfunction fromRange(range) {\n  let rs = [];\n  const rects = Array.from(range.getClientRects());\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect));\n    return union.apply(void 0, rs);\n  }\n  let start = range.startContainer;\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode;\n  }\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start);\n    rs.push({\n      ...r,\n      x: r.maxX,\n      width: 0\n    });\n  }\n  return union.apply(void 0, rs);\n}\n\n// src/from-rotation.ts\nfunction toRad(d) {\n  return d % 360 * Math.PI / 180;\n}\nfunction rotate(a, d, c) {\n  const r = toRad(d);\n  const sin = Math.sin(r);\n  const cos = Math.cos(r);\n  const x = a.x - c.x;\n  const y = a.y - c.y;\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos\n  };\n}\nfunction getRotationRect(r, deg) {\n  const rr = Object.values(getRectCorners(r)).map(p => rotate(p, deg, r.center));\n  const xs = rr.map(p => p.x);\n  const ys = rr.map(p => p.y);\n  const minX = Math.min(...xs);\n  const minY = Math.min(...ys);\n  const maxX = Math.max(...xs);\n  const maxY = Math.max(...ys);\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  });\n}\n\n// src/from-window.ts\nfunction getWindowRect(win, opts = {}) {\n  return createRect(getViewportRect(win, opts));\n}\nfunction getViewportRect(win, opts) {\n  const {\n    excludeScrollbar = false\n  } = opts;\n  const {\n    innerWidth,\n    innerHeight,\n    document: doc,\n    visualViewport\n  } = win;\n  const width = visualViewport?.width || innerWidth;\n  const height = visualViewport?.height || innerHeight;\n  const rect = {\n    x: 0,\n    y: 0,\n    width,\n    height\n  };\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;\n    rect.width -= scrollbarWidth;\n    rect.height -= scrollbarHeight;\n  }\n  return rect;\n}\n\n// src/operations.ts\nvar isSymmetric = v => \"dx\" in v || \"dy\" in v;\nfunction inset(r, i) {\n  const v = isSymmetric(i) ? {\n    left: i.dx,\n    right: i.dx,\n    top: i.dy,\n    bottom: i.dy\n  } : i;\n  const {\n    top = 0,\n    right = 0,\n    bottom = 0,\n    left = 0\n  } = v;\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom\n  });\n}\nfunction expand(r, v) {\n  const value = typeof v === \"number\" ? {\n    dx: -v,\n    dy: -v\n  } : v;\n  return inset(r, value);\n}\nfunction shrink(r, v) {\n  const value = typeof v === \"number\" ? {\n    dx: -v,\n    dy: -v\n  } : v;\n  return inset(r, value);\n}\nfunction shift(r, o) {\n  const {\n    x = 0,\n    y = 0\n  } = o;\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height\n  });\n}\n\n// src/polygon.ts\nfunction getElementPolygon(rectValue, placement) {\n  const rect = createRect(rectValue);\n  const {\n    top,\n    right,\n    left,\n    bottom\n  } = getRectCorners(rect);\n  const [base] = placement.split(\"-\");\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom]\n  }[base];\n}\nfunction isPointInPolygon(polygon, point) {\n  const {\n    x,\n    y\n  } = point;\n  let c = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n      c = !c;\n    }\n  }\n  return c;\n}\nfunction createPolygonElement() {\n  const id = \"debug-polygon\";\n  const existingPolygon = document.getElementById(id);\n  if (existingPolygon) {\n    return existingPolygon;\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\"\n  });\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n  polygon.setAttribute(\"id\", id);\n  polygon.setAttribute(\"points\", \"0,0 0,0\");\n  svg.appendChild(polygon);\n  document.body.appendChild(svg);\n  return polygon;\n}\nfunction debugPolygon(polygon) {\n  const el = createPolygonElement();\n  const points = polygon.map(point => `${point.x},${point.y}`).join(\" \");\n  el.setAttribute(\"points\", points);\n  return () => {\n    el.remove();\n  };\n}\n\n// src/compass.ts\nvar compassDirectionMap = {\n  n: {\n    x: 0.5,\n    y: 0\n  },\n  ne: {\n    x: 1,\n    y: 0\n  },\n  e: {\n    x: 1,\n    y: 0.5\n  },\n  se: {\n    x: 1,\n    y: 1\n  },\n  s: {\n    x: 0.5,\n    y: 1\n  },\n  sw: {\n    x: 0,\n    y: 1\n  },\n  w: {\n    x: 0,\n    y: 0.5\n  },\n  nw: {\n    x: 0,\n    y: 0\n  }\n};\nvar oppositeDirectionMap = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\"\n};\n\n// src/resize.ts\nvar {\n  sign,\n  abs,\n  min: min2\n} = Math;\nfunction getRectExtentPoint(rect, direction) {\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    midX,\n    midY\n  } = rect;\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX;\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY;\n  return {\n    x,\n    y\n  };\n}\nfunction getOppositeDirection(direction) {\n  return oppositeDirectionMap[direction];\n}\nfunction resizeRect(rect, offset, direction, opts) {\n  const {\n    scalingOriginMode,\n    lockAspectRatio\n  } = opts;\n  const extent = getRectExtentPoint(rect, direction);\n  const oppositeDirection = getOppositeDirection(direction);\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);\n  if (scalingOriginMode === \"center\") {\n    offset = {\n      x: offset.x * 2,\n      y: offset.y * 2\n    };\n  }\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y\n  };\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1\n  };\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y\n  };\n  const scaleX = multiplier.x * newSize.width / rect.width;\n  const scaleY = multiplier.y * newSize.height / rect.height;\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY;\n  const scale = lockAspectRatio ? {\n    x: largestMagnitude,\n    y: largestMagnitude\n  } : {\n    x: extent.x === oppositeExtent.x ? 1 : scaleX,\n    y: extent.y === oppositeExtent.y ? 1 : scaleY\n  };\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y);\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1;\n  }\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x);\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1;\n  }\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);\n    case \"center\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, {\n        x: rect.midX,\n        y: rect.midY\n      }), false);\n  }\n}\nfunction createRectFromPoints(initialPoint, finalPoint, normalized = true) {\n  if (normalized) {\n    return {\n      x: min2(finalPoint.x, initialPoint.x),\n      y: min2(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y)\n    };\n  }\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y\n  };\n}\nfunction transformRect(rect, transform, normalized = true) {\n  const p1 = transform.applyTo({\n    x: rect.minX,\n    y: rect.minY\n  });\n  const p2 = transform.applyTo({\n    x: rect.maxX,\n    y: rect.maxY\n  });\n  return createRectFromPoints(p1, p2, normalized);\n}\nexport { AffineTransform, addPoints, alignRect, clampPoint, clampSize, closest, closestSideToPoint, closestSideToRect, collisions, constrainRect, contains, containsPoint, containsRect, createPoint, createRect, debugPolygon, distance, distanceBtwEdges, distanceFromPoint, distanceFromRect, expand, fromRange, getElementPolygon, getElementRect, getRectCenters, getRectCorners, getRectEdges, getRectFromPoints, getRotationRect, getViewportRect, getWindowRect, inset, intersection, intersects, isPoint, isPointEqual, isPointInPolygon, isRect, isRectEqual, isSizeEqual, isSymmetric, resizeRect, rotate, shift, shrink, subtractPoints, toRad, union };","map":{"version":3,"names":["AffineTransform","_AffineTransform","constructor","m00","m01","m02","m10","m11","m12","__publicField","args","prepend","rotate","scale","translate","applyTo","point","x","y","other","append","determinant","isInvertible","det","isFinite","invert","array","float32Array","Float32Array","identity","theta","origin","rotation","Math","cos","sin","multiply","sx","sy","tx","ty","first","rest","reduce","result","item","a","b","c","d","scaleComponents","translationComponents","skewComponents","toString","hAlign","ref","h","minX","width","maxX","midX","vAlign","v","minY","height","maxY","midY","alignRect","options","clamp","value","min3","max2","min","max","clampPoint","position","size","boundaryRect","defaultMinSize","defaultMaxSize","Infinity","clampSize","minSize","maxSize","createPoint","subtractPoints","addPoints","isPoint","Reflect","has","createRect","r","center","isRect","getRectCenters","top","right","bottom","left","getRectCorners","getRectEdges","intersects","intersection","x2","y2","collisions","distance","sqrt","pow","distanceFromPoint","p","distanceFromRect","upper","lower","distanceBtwEdges","closest","pts","ds","map","apply","indexOf","closestSideToRect","closestSideToPoint","dl","dr","dt","db","closest2","side","constrainRect","rect","boundary","containsPoint","containsRect","Object","values","every","contains","isSizeEqual","isPointEqual","isRectEqual","styleCache","WeakMap","getCacheComputedStyle","el","win","ownerDocument","defaultView","window","set","getComputedStyle","get","getElementRect","opts","getClientRect","excludeScrollbar","excludeBorders","getBoundingClientRect","style","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderXWidth","sum","borderYWidth","px","scrollbarWidth","offsetWidth","clientWidth","scrollbarHeight","offsetHeight","clientHeight","parseFloat","replace","vals","sum2","getRectFromPoints","xs","ys","union","rs","pMin","pMax","fromRange","range","rects","Array","from","getClientRects","length","concat","start","startContainer","nodeType","Node","TEXT_NODE","parentNode","HTMLElement","push","toRad","PI","getRotationRect","deg","rr","getWindowRect","getViewportRect","innerWidth","innerHeight","document","doc","visualViewport","documentElement","isSymmetric","inset","i","dx","dy","expand","shrink","shift","o","getElementPolygon","rectValue","placement","base","split","isPointInPolygon","polygon","j","xi","yi","xj","yj","createPolygonElement","id","existingPolygon","getElementById","svg","createElementNS","assign","opacity","pointerEvents","fill","setAttribute","appendChild","body","debugPolygon","points","join","remove","compassDirectionMap","n","ne","e","se","s","sw","w","nw","oppositeDirectionMap","sign","abs","min2","getRectExtentPoint","direction","includes","getOppositeDirection","resizeRect","offset","scalingOriginMode","lockAspectRatio","extent","oppositeDirection","oppositeExtent","newExtent","multiplier","newSize","scaleX","scaleY","largestMagnitude","transformRect","createRectFromPoints","initialPoint","finalPoint","normalized","transform","p1","p2"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/affine-transform.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/align.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/clamp.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/rect.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/intersection.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/distance.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/closest.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/constrain.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/contains.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/equality.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-element.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-points.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/union.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-range.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-rotation.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/from-window.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/operations.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/polygon.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/compass.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/rect-utils/src/resize.ts"],"sourcesContent":["import type { Point } from \"./types\"\n\nexport class AffineTransform {\n  m00: number\n  m01: number\n  m02: number\n  m10: number\n  m11: number\n  m12: number\n\n  constructor([m00, m01, m02, m10, m11, m12]: Iterable<number> = [0, 0, 0, 0, 0, 0]) {\n    this.m00 = m00\n    this.m01 = m01\n    this.m02 = m02\n    this.m10 = m10\n    this.m11 = m11\n    this.m12 = m12\n  }\n\n  applyTo(point: Point): Point {\n    const { x, y } = point\n    const { m00, m01, m02, m10, m11, m12 } = this\n\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12,\n    }\n  }\n\n  prepend(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      this.m00 * other.m00 + this.m01 * other.m10, // m00\n      this.m00 * other.m01 + this.m01 * other.m11, // m01\n      this.m00 * other.m02 + this.m01 * other.m12 + this.m02, // m02\n      this.m10 * other.m00 + this.m11 * other.m10, // m10\n      this.m10 * other.m01 + this.m11 * other.m11, // m11\n      this.m10 * other.m02 + this.m11 * other.m12 + this.m12, // m12\n    ])\n  }\n\n  append(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      other.m00 * this.m00 + other.m01 * this.m10, // m00\n      other.m00 * this.m01 + other.m01 * this.m11, // m01\n      other.m00 * this.m02 + other.m01 * this.m12 + other.m02, // m02\n      other.m10 * this.m00 + other.m11 * this.m10, // m10\n      other.m10 * this.m01 + other.m11 * this.m11, // m11\n      other.m10 * this.m02 + other.m11 * this.m12 + other.m12, // m12\n    ])\n  }\n\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10\n  }\n\n  get isInvertible() {\n    const det = this.determinant\n\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0\n  }\n\n  invert() {\n    const det = this.determinant\n\n    return new AffineTransform([\n      this.m11 / det, // m00\n      -this.m01 / det, // m01\n      (this.m01 * this.m12 - this.m11 * this.m02) / det, // m02\n      -this.m10 / det, // m10\n      this.m00 / det, // m11\n      (this.m10 * this.m02 - this.m00 * this.m12) / det, // m12\n    ])\n  }\n\n  get array(): number[] {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1]\n  }\n\n  get float32Array(): Float32Array {\n    return new Float32Array(this.array)\n  }\n\n  // Static\n\n  static get identity(): AffineTransform {\n    return new AffineTransform([1, 0, 0, 0, 1, 0])\n  }\n\n  static rotate(theta: number, origin?: Point): AffineTransform {\n    const rotation = new AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0])\n\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        rotation,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return rotation\n  }\n\n  rotate: (typeof AffineTransform)[\"rotate\"] = (...args) => {\n    return this.prepend(AffineTransform.rotate(...args))\n  }\n\n  static scale(sx: number, sy: number = sx, origin: Point = { x: 0, y: 0 }): AffineTransform {\n    const scale = new AffineTransform([sx, 0, 0, 0, sy, 0])\n\n    if (origin.x !== 0 || origin.y !== 0) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        scale,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return scale\n  }\n\n  scale: (typeof AffineTransform)[\"scale\"] = (...args) => {\n    return this.prepend(AffineTransform.scale(...args))\n  }\n\n  static translate(tx: number, ty: number): AffineTransform {\n    return new AffineTransform([1, 0, tx, 0, 1, ty])\n  }\n\n  translate: (typeof AffineTransform)[\"translate\"] = (...args) => {\n    return this.prepend(AffineTransform.translate(...args))\n  }\n\n  static multiply(...[first, ...rest]: AffineTransform[]): AffineTransform {\n    if (!first) return AffineTransform.identity\n    return rest.reduce((result, item) => result.prepend(item), first)\n  }\n\n  get a() {\n    return this.m00\n  }\n\n  get b() {\n    return this.m10\n  }\n\n  get c() {\n    return this.m01\n  }\n\n  get d() {\n    return this.m11\n  }\n\n  get tx() {\n    return this.m02\n  }\n\n  get ty() {\n    return this.m12\n  }\n\n  get scaleComponents(): Point {\n    return { x: this.a, y: this.d }\n  }\n\n  get translationComponents(): Point {\n    return { x: this.tx, y: this.ty }\n  }\n\n  get skewComponents(): Point {\n    return { x: this.c, y: this.b }\n  }\n\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`\n  }\n}\n","import type { AlignOptions, HAlign, Rect, VAlign } from \"./types\"\n\nfunction hAlign(a: Rect, ref: Rect, h: HAlign): Rect {\n  let x = ref.minX\n  if (h === \"left-inside\") x = ref.minX\n  if (h === \"left-outside\") x = ref.minX - ref.width\n  if (h === \"right-inside\") x = ref.maxX - ref.width\n  if (h === \"right-outside\") x = ref.maxX\n  if (h === \"center\") x = ref.midX - ref.width / 2\n  return { ...a, x }\n}\n\nfunction vAlign(a: Rect, ref: Rect, v: VAlign): Rect {\n  let y = ref.minY\n  if (v === \"top-inside\") y = ref.minY\n  if (v === \"top-outside\") y = ref.minY - a.height\n  if (v === \"bottom-inside\") y = ref.maxY - a.height\n  if (v === \"bottom-outside\") y = ref.maxY\n  if (v === \"center\") y = ref.midY - a.height / 2\n  return { ...a, y }\n}\n\nexport function alignRect(a: Rect, ref: Rect, options: AlignOptions): Rect {\n  const { h, v } = options\n  return vAlign(hAlign(a, ref, h), ref, v)\n}\n","import type { Point, RectInit, Size } from \"./types\"\n\nconst clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max)\n\nexport const clampPoint = (position: Point, size: Size, boundaryRect: RectInit) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width)\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height)\n  return { x, y }\n}\n\nconst defaultMinSize: Size = {\n  width: 0,\n  height: 0,\n}\n\nconst defaultMaxSize: Size = {\n  width: Infinity,\n  height: Infinity,\n}\n\nexport const clampSize = (size: Size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize!.width), maxSize!.width),\n    height: Math.min(Math.max(size.height, minSize!.height), maxSize!.height),\n  }\n}\n","import type { Point, Rect, RectEdge, RectInit } from \"./types\"\n\n/* -----------------------------------------------------------------------------\n * Point\n * -----------------------------------------------------------------------------*/\n\nexport const createPoint = (x: number, y: number) => ({ x, y })\n\nexport const subtractPoints = (a: Point, b: Point) => createPoint(a.x - b.x, a.y - b.y)\nexport const addPoints = (a: Point, b: Point) => createPoint(a.x + b.x, a.y + b.y)\n\nexport function isPoint(v: any): v is Point {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\")\n}\n\n/* -----------------------------------------------------------------------------\n * Rect\n * -----------------------------------------------------------------------------*/\n\nexport function createRect(r: RectInit): Rect {\n  const { x, y, width, height } = r\n  const midX = x + width / 2\n  const midY = y + height / 2\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY),\n  }\n}\n\nexport function isRect(v: any): v is Rect {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\")\n}\n\nexport function getRectCenters(v: Rect) {\n  const top = createPoint(v.midX, v.minY)\n  const right = createPoint(v.maxX, v.midY)\n  const bottom = createPoint(v.midX, v.maxY)\n  const left = createPoint(v.minX, v.midY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectCorners(v: Rect) {\n  const top = createPoint(v.minX, v.minY)\n  const right = createPoint(v.maxX, v.minY)\n  const bottom = createPoint(v.maxX, v.maxY)\n  const left = createPoint(v.minX, v.maxY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectEdges(v: Rect) {\n  const c = getRectCorners(v)\n  const top: RectEdge = [c.top, c.right]\n  const right: RectEdge = [c.right, c.bottom]\n  const bottom: RectEdge = [c.left, c.bottom]\n  const left: RectEdge = [c.top, c.left]\n  return { top, right, bottom, left }\n}\n","import { createRect } from \"./rect\"\nimport type { Rect, RectSide } from \"./types\"\n\n/**\n * Checks if a Rect intersects another Rect\n */\nexport function intersects(a: Rect, b: Rect): boolean {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y\n}\n\n/**\n * Returns a new Rect that represents the intersection between two Rects\n */\nexport function intersection(a: Rect, b: Rect): Rect {\n  const x = Math.max(a.x, b.x)\n  const y = Math.max(a.y, b.y)\n  const x2 = Math.min(a.x + a.width, b.x + b.width)\n  const y2 = Math.min(a.y + a.height, b.y + b.height)\n  return createRect({ x, y, width: x2 - x, height: y2 - y })\n}\n\n/**\n * Returns whether two rects collide along each edge\n */\nexport function collisions(a: Rect, b: Rect): Record<RectSide, boolean> {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX,\n  }\n}\n","import { intersects } from \"./intersection\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport interface DistanceValue extends Point {\n  value: number\n}\n\nexport function distance(a: Point, b: Point = { x: 0, y: 0 }): number {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nexport function distanceFromPoint(r: Rect, p: Point): DistanceValue {\n  let x = 0\n  let y = 0\n\n  if (p.x < r.x) x = r.x - p.x\n  else if (p.x > r.maxX) x = p.x - r.maxX\n\n  if (p.y < r.y) y = r.y - p.y\n  else if (p.y > r.maxY) y = p.y - r.maxY\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceFromRect(a: Rect, b: Rect): DistanceValue {\n  if (intersects(a, b)) return { x: 0, y: 0, value: 0 }\n  const left = a.x < b.x ? a : b\n  const right = b.x < a.x ? a : b\n  const upper = a.y < b.y ? a : b\n  const lower = b.y < a.y ? a : b\n  let x = left.x === right.x ? 0 : right.x - left.maxX\n  x = Math.max(0, x)\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY\n  y = Math.max(0, y)\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceBtwEdges(a: Rect, b: Rect): Record<RectSide, number> {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY,\n  }\n}\n","import { distance } from \"./distance\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport function closest(...pts: Point[]) {\n  return (a: Point): Point => {\n    const ds = pts.map((b) => distance(b, a))\n    const c = Math.min.apply(Math, ds)\n    return pts[ds.indexOf(c)]\n  }\n}\n\nexport function closestSideToRect(ref: Rect, r: Rect): RectSide {\n  if (r.maxX <= ref.minX) return \"left\"\n  if (r.minX >= ref.maxX) return \"right\"\n  if (r.maxY <= ref.minY) return \"top\"\n  if (r.minY >= ref.maxY) return \"bottom\"\n  return \"left\"\n}\n\nexport function closestSideToPoint(ref: Rect, p: Point): RectSide {\n  const { x, y } = p\n\n  const dl = x - ref.minX\n  const dr = ref.maxX - x\n  const dt = y - ref.minY\n  const db = ref.maxY - y\n\n  let closest = dl\n  let side: RectSide = \"left\"\n\n  if (dr < closest) {\n    closest = dr\n    side = \"right\"\n  }\n  if (dt < closest) {\n    closest = dt\n    side = \"top\"\n  }\n  if (db < closest) {\n    side = \"bottom\"\n  }\n\n  return side\n}\n","import type { RectInit } from \"./types\"\n\n// given a rect and a boundary, return a new rect that is constrained within the boundary\n// resize or reposition the rect so that it fits within the boundary\nexport const constrainRect = (rect: RectInit, boundary: RectInit): RectInit => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width))\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height))\n\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height),\n  }\n}\n","import { getRectCorners, isRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function containsPoint(r: Rect, p: Point): boolean {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY\n}\n\nexport function containsRect(a: Rect, b: Rect): boolean {\n  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c))\n}\n\nexport function contains(r: Rect, v: Rect | Point): boolean {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v)\n}\n","import type { Point, RectInit, Size } from \"./types\"\n\nexport const isSizeEqual = (a: Size, b: Size) => {\n  return a.width === b.width && a.height === b.height\n}\n\nexport const isPointEqual = (a: Point, b: Point) => {\n  return a.x === b.x && a.y === b.y\n}\n\nexport const isRectEqual = (a: RectInit, b: RectInit) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b)\n}\n","import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nconst styleCache = new WeakMap<HTMLElement, any>()\n\nfunction getCacheComputedStyle(el: HTMLElement) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window\n    styleCache.set(el, win.getComputedStyle(el))\n  }\n  return styleCache.get(el)\n}\n\nexport function getElementRect(el: HTMLElement, opts: ElementRectOptions = {}): Rect {\n  return createRect(getClientRect(el, opts))\n}\n\nexport type ElementRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n  /**\n   * Whether to exclude the element's borders from the calculation.\n   */\n  excludeBorders?: boolean\n}\n\nfunction getClientRect(el: HTMLElement, opts: ElementRectOptions = {}) {\n  const { excludeScrollbar = false, excludeBorders = false } = opts\n\n  const { x, y, width, height } = el.getBoundingClientRect()\n  const r = { x, y, width, height }\n\n  const style = getCacheComputedStyle(el)\n\n  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style\n\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth)\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth)\n\n  if (excludeBorders) {\n    r.width -= borderXWidth\n    r.height -= borderYWidth\n    r.x += px(borderLeftWidth)\n    r.y += px(borderTopWidth)\n  }\n\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth\n    r.width -= scrollbarWidth\n    r.height -= scrollbarHeight\n  }\n\n  return r\n}\n\nconst px = (v: string) => parseFloat(v.replace(\"px\", \"\"))\n\nconst sum = (...vals: string[]) => vals.reduce((sum, v) => sum + (v ? px(v) : 0), 0)\n","import { createRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function getRectFromPoints(...pts: Point[]): Rect {\n  const xs = pts.map((p) => p.x)\n  const ys = pts.map((p) => p.y)\n\n  const x = Math.min(...xs)\n  const y = Math.min(...ys)\n\n  const width = Math.max(...xs) - x\n  const height = Math.max(...ys) - y\n\n  return createRect({ x, y, width, height })\n}\n","import { getRectFromPoints } from \"./from-points\"\nimport type { Rect } from \"./types\"\n\nconst { min, max } = Math\n\nexport function union(...rs: Rect[]): Rect {\n  const pMin = {\n    x: min(...rs.map((r) => r.minX)),\n    y: min(...rs.map((r) => r.minY)),\n  }\n  const pMax = {\n    x: max(...rs.map((r) => r.maxX)),\n    y: max(...rs.map((r) => r.maxY)),\n  }\n  return getRectFromPoints(pMin, pMax)\n}\n","import { createRect } from \"./rect\"\nimport { getElementRect } from \"./from-element\"\nimport { union } from \"./union\"\nimport type { Rect } from \"./types\"\n\nexport function fromRange(range: Range): Rect {\n  let rs: Rect[] = []\n  const rects = Array.from(range.getClientRects())\n\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect))\n    return union.apply(undefined, rs)\n  }\n\n  let start: Node | ParentNode | null = range.startContainer\n\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode\n  }\n\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start)\n    rs.push({ ...r, x: r.maxX, width: 0 })\n  }\n\n  return union.apply(undefined, rs)\n}\n","import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function toRad(d: number) {\n  return ((d % 360) * Math.PI) / 180\n}\n\nexport function rotate(a: Point, d: number, c: Point): Point {\n  const r = toRad(d)\n\n  const sin = Math.sin(r)\n  const cos = Math.cos(r)\n\n  const x = a.x - c.x\n  const y = a.y - c.y\n\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos,\n  }\n}\n\nexport function getRotationRect(r: Rect, deg: number): Rect {\n  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center))\n\n  const xs = rr.map((p) => p.x)\n  const ys = rr.map((p) => p.y)\n\n  const minX = Math.min(...xs)\n  const minY = Math.min(...ys)\n\n  const maxX = Math.max(...xs)\n  const maxY = Math.max(...ys)\n\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  })\n}\n","import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nexport type WindowRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n}\n\n/**\n * Creates a rectange from window object\n */\nexport function getWindowRect(win: Window, opts: WindowRectOptions = {}): Rect {\n  return createRect(getViewportRect(win, opts))\n}\n\n/**\n * Get the rect of the window with the option to exclude the scrollbar\n */\nexport function getViewportRect(win: Window, opts: WindowRectOptions) {\n  const { excludeScrollbar = false } = opts\n  const { innerWidth, innerHeight, document: doc, visualViewport } = win\n  const width = visualViewport?.width || innerWidth\n  const height = visualViewport?.height || innerHeight\n  const rect = { x: 0, y: 0, width, height }\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight\n    rect.width -= scrollbarWidth\n    rect.height -= scrollbarHeight\n  }\n  return rect\n}\n","import { createRect } from \"./rect\"\nimport type { Point, Rect, RectInset, SymmetricRectInset } from \"./types\"\n\nexport const isSymmetric = (v: any): v is SymmetricRectInset => \"dx\" in v || \"dy\" in v\n\nexport function inset(r: Rect, i: RectInset | SymmetricRectInset): Rect {\n  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i\n  const { top = 0, right = 0, bottom = 0, left = 0 } = v\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom,\n  })\n}\n\nexport function expand(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shrink(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shift(r: Rect, o: Partial<Point>): Rect {\n  const { x = 0, y = 0 } = o\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height,\n  })\n}\n","import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, RectInit } from \"./types\"\n\nexport function getElementPolygon(rectValue: RectInit, placement: string) {\n  const rect = createRect(rectValue)\n  const { top, right, left, bottom } = getRectCorners(rect)\n  const [base] = placement.split(\"-\")\n\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom],\n  }[base]\n}\n\nexport function isPointInPolygon(polygon: Point[], point: Point) {\n  const { x, y } = point\n  let c = false\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x\n    const yi = polygon[i].y\n    const xj = polygon[j].x\n    const yj = polygon[j].y\n\n    if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {\n      c = !c\n    }\n  }\n  return c\n}\n\nfunction createPolygonElement() {\n  const id = \"debug-polygon\"\n  const existingPolygon = document.getElementById(id)\n  if (existingPolygon) {\n    return existingPolygon\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\",\n  })\n\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\")\n  polygon.setAttribute(\"id\", id)\n  polygon.setAttribute(\"points\", \"0,0 0,0\")\n  svg.appendChild(polygon)\n  document.body.appendChild(svg)\n  return polygon\n}\n\nexport function debugPolygon(polygon: Point[]) {\n  const el = createPolygonElement()\n  const points = polygon.map((point) => `${point.x},${point.y}`).join(\" \")\n  el.setAttribute(\"points\", points)\n  return () => {\n    el.remove()\n  }\n}\n","import type { Point } from \"./types\"\n\nexport type CompassDirection = \"n\" | \"ne\" | \"e\" | \"se\" | \"s\" | \"sw\" | \"w\" | \"nw\"\n\nexport const compassDirectionMap: Record<CompassDirection, Point> = {\n  n: { x: 0.5, y: 0 },\n  ne: { x: 1, y: 0 },\n  e: { x: 1, y: 0.5 },\n  se: { x: 1, y: 1 },\n  s: { x: 0.5, y: 1 },\n  sw: { x: 0, y: 1 },\n  w: { x: 0, y: 0.5 },\n  nw: { x: 0, y: 0 },\n}\n\nexport const oppositeDirectionMap: Record<CompassDirection, CompassDirection> = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\",\n}\n","import { AffineTransform } from \"./affine-transform\"\nimport { compassDirectionMap, oppositeDirectionMap, type CompassDirection } from \"./compass\"\nimport type { Point, Rect, RectInit, ScalingOptions } from \"./types\"\n\nconst { sign, abs, min } = Math\n\nfunction getRectExtentPoint(rect: Rect, direction: CompassDirection) {\n  const { minX, minY, maxX, maxY, midX, midY } = rect\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY\n  return { x, y }\n}\n\nfunction getOppositeDirection(direction: CompassDirection) {\n  return oppositeDirectionMap[direction]\n}\n\nexport function resizeRect(rect: Rect, offset: Point, direction: CompassDirection, opts: ScalingOptions) {\n  const { scalingOriginMode, lockAspectRatio } = opts\n\n  const extent = getRectExtentPoint(rect, direction)\n\n  const oppositeDirection = getOppositeDirection(direction)\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection)\n\n  if (scalingOriginMode === \"center\") {\n    offset = { x: offset.x * 2, y: offset.y * 2 }\n  }\n\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y,\n  }\n\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1,\n  }\n\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y,\n  }\n\n  const scaleX = (multiplier.x * newSize.width) / rect.width\n  const scaleY = (multiplier.y * newSize.height) / rect.height\n\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY\n\n  const scale = lockAspectRatio\n    ? { x: largestMagnitude, y: largestMagnitude }\n    : {\n        x: extent.x === oppositeExtent.x ? 1 : scaleX,\n        y: extent.y === oppositeExtent.y ? 1 : scaleY,\n      }\n\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y)\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1\n  }\n\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x)\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1\n  }\n\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false)\n    case \"center\":\n      return transformRect(\n        rect,\n        AffineTransform.scale(scale.x, scale.y, {\n          x: rect.midX,\n          y: rect.midY,\n        }),\n        false,\n      )\n  }\n}\n\nfunction createRectFromPoints(initialPoint: Point, finalPoint: Point, normalized: boolean = true): RectInit {\n  if (normalized) {\n    return {\n      x: min(finalPoint.x, initialPoint.x),\n      y: min(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y),\n    }\n  }\n\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y,\n  }\n}\n\nfunction transformRect(rect: Rect, transform: AffineTransform, normalized = true): RectInit {\n  const p1 = transform.applyTo({ x: rect.minX, y: rect.minY })\n  const p2 = transform.applyTo({ x: rect.maxX, y: rect.maxY })\n  return createRectFromPoints(p1, p2, normalized)\n}\n"],"mappings":";;;;;;;;;;AAEO,IAAMA,eAAA,GAAN,MAAMC,gBAAA,CAAgB;EAQ3BC,YAAY,CAACC,GAAA,EAAKC,GAAA,EAAKC,GAAA,EAAKC,GAAA,EAAKC,GAAA,EAAKC,GAAG,IAAsB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG;IAPnFC,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IA8FAA,aAAA,iBAA6C,IAAIC,IAAA,KAAS;MACxD,OAAO,KAAKC,OAAA,CAAQV,gBAAA,CAAgBW,MAAA,CAAO,GAAGF,IAAI,CAAC;IACrD;IAgBAD,aAAA,gBAA2C,IAAIC,IAAA,KAAS;MACtD,OAAO,KAAKC,OAAA,CAAQV,gBAAA,CAAgBY,KAAA,CAAM,GAAGH,IAAI,CAAC;IACpD;IAMAD,aAAA,oBAAmD,IAAIC,IAAA,KAAS;MAC9D,OAAO,KAAKC,OAAA,CAAQV,gBAAA,CAAgBa,SAAA,CAAU,GAAGJ,IAAI,CAAC;IACxD;IAvHE,KAAKP,GAAA,GAAMA,GAAA;IACX,KAAKC,GAAA,GAAMA,GAAA;IACX,KAAKC,GAAA,GAAMA,GAAA;IACX,KAAKC,GAAA,GAAMA,GAAA;IACX,KAAKC,GAAA,GAAMA,GAAA;IACX,KAAKC,GAAA,GAAMA,GAAA;EACb;EAEAO,QAAQC,KAAA,EAAqB;IAC3B,MAAM;MAAEC,CAAA;MAAGC;IAAE,IAAIF,KAAA;IACjB,MAAM;MAAEb,GAAA;MAAKC,GAAA;MAAKC,GAAA;MAAKC,GAAA;MAAKC,GAAA;MAAKC;IAAI,IAAI;IAEzC,OAAO;MACLS,CAAA,EAAGd,GAAA,GAAMc,CAAA,GAAIb,GAAA,GAAMc,CAAA,GAAIb,GAAA;MACvBa,CAAA,EAAGZ,GAAA,GAAMW,CAAA,GAAIV,GAAA,GAAMW,CAAA,GAAIV;IACzB;EACF;EAEAG,QAAQQ,KAAA,EAAyC;IAC/C,OAAO,IAAIlB,gBAAA,CAAgB,CACzB,KAAKE,GAAA,GAAMgB,KAAA,CAAMhB,GAAA,GAAM,KAAKC,GAAA,GAAMe,KAAA,CAAMb,GAAA;IAAA;IACxC,KAAKH,GAAA,GAAMgB,KAAA,CAAMf,GAAA,GAAM,KAAKA,GAAA,GAAMe,KAAA,CAAMZ,GAAA;IAAA;IACxC,KAAKJ,GAAA,GAAMgB,KAAA,CAAMd,GAAA,GAAM,KAAKD,GAAA,GAAMe,KAAA,CAAMX,GAAA,GAAM,KAAKH,GAAA;IAAA;IACnD,KAAKC,GAAA,GAAMa,KAAA,CAAMhB,GAAA,GAAM,KAAKI,GAAA,GAAMY,KAAA,CAAMb,GAAA;IAAA;IACxC,KAAKA,GAAA,GAAMa,KAAA,CAAMf,GAAA,GAAM,KAAKG,GAAA,GAAMY,KAAA,CAAMZ,GAAA;IAAA;IACxC,KAAKD,GAAA,GAAMa,KAAA,CAAMd,GAAA,GAAM,KAAKE,GAAA,GAAMY,KAAA,CAAMX,GAAA,GAAM,KAAKA;IAAA;IAAA,CACpD;EACH;EAEAY,OAAOD,KAAA,EAAyC;IAC9C,OAAO,IAAIlB,gBAAA,CAAgB,CACzBkB,KAAA,CAAMhB,GAAA,GAAM,KAAKA,GAAA,GAAMgB,KAAA,CAAMf,GAAA,GAAM,KAAKE,GAAA;IAAA;IACxCa,KAAA,CAAMhB,GAAA,GAAM,KAAKC,GAAA,GAAMe,KAAA,CAAMf,GAAA,GAAM,KAAKG,GAAA;IAAA;IACxCY,KAAA,CAAMhB,GAAA,GAAM,KAAKE,GAAA,GAAMc,KAAA,CAAMf,GAAA,GAAM,KAAKI,GAAA,GAAMW,KAAA,CAAMd,GAAA;IAAA;IACpDc,KAAA,CAAMb,GAAA,GAAM,KAAKH,GAAA,GAAMgB,KAAA,CAAMZ,GAAA,GAAM,KAAKD,GAAA;IAAA;IACxCa,KAAA,CAAMb,GAAA,GAAM,KAAKF,GAAA,GAAMe,KAAA,CAAMZ,GAAA,GAAM,KAAKA,GAAA;IAAA;IACxCY,KAAA,CAAMb,GAAA,GAAM,KAAKD,GAAA,GAAMc,KAAA,CAAMZ,GAAA,GAAM,KAAKC,GAAA,GAAMW,KAAA,CAAMX;IAAA;IAAA,CACrD;EACH;EAEA,IAAIa,YAAA,EAAc;IAChB,OAAO,KAAKlB,GAAA,GAAM,KAAKI,GAAA,GAAM,KAAKH,GAAA,GAAM,KAAKE,GAAA;EAC/C;EAEA,IAAIgB,aAAA,EAAe;IACjB,MAAMC,GAAA,GAAM,KAAKF,WAAA;IAEjB,OAAOG,QAAA,CAASD,GAAG,KAAKC,QAAA,CAAS,KAAKnB,GAAG,KAAKmB,QAAA,CAAS,KAAKhB,GAAG,KAAKe,GAAA,KAAQ;EAC9E;EAEAE,OAAA,EAAS;IACP,MAAMF,GAAA,GAAM,KAAKF,WAAA;IAEjB,OAAO,IAAIpB,gBAAA,CAAgB,CACzB,KAAKM,GAAA,GAAMgB,GAAA;IAAA;IACX,CAAC,KAAKnB,GAAA,GAAMmB,GAAA;IAAA;IAAA,CACX,KAAKnB,GAAA,GAAM,KAAKI,GAAA,GAAM,KAAKD,GAAA,GAAM,KAAKF,GAAA,IAAOkB,GAAA;IAAA;IAC9C,CAAC,KAAKjB,GAAA,GAAMiB,GAAA;IAAA;IACZ,KAAKpB,GAAA,GAAMoB,GAAA;IAAA;IAAA,CACV,KAAKjB,GAAA,GAAM,KAAKD,GAAA,GAAM,KAAKF,GAAA,GAAM,KAAKK,GAAA,IAAOe;IAAA;IAAA,CAC/C;EACH;EAEA,IAAIG,MAAA,EAAkB;IACpB,OAAO,CAAC,KAAKvB,GAAA,EAAK,KAAKC,GAAA,EAAK,KAAKC,GAAA,EAAK,KAAKC,GAAA,EAAK,KAAKC,GAAA,EAAK,KAAKC,GAAA,EAAK,GAAG,GAAG,CAAC;EAC7E;EAEA,IAAImB,aAAA,EAA6B;IAC/B,OAAO,IAAIC,YAAA,CAAa,KAAKF,KAAK;EACpC;EAAA;EAIA,WAAWG,SAAA,EAA4B;IACrC,OAAO,IAAI5B,gBAAA,CAAgB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;EAC/C;EAEA,OAAOW,OAAOkB,KAAA,EAAeC,MAAA,EAAiC;IAC5D,MAAMC,QAAA,GAAW,IAAI/B,gBAAA,CAAgB,CAACgC,IAAA,CAAKC,GAAA,CAAIJ,KAAK,GAAG,CAACG,IAAA,CAAKE,GAAA,CAAIL,KAAK,GAAG,GAAGG,IAAA,CAAKE,GAAA,CAAIL,KAAK,GAAGG,IAAA,CAAKC,GAAA,CAAIJ,KAAK,GAAG,CAAC,CAAC;IAEhH,IAAIC,MAAA,KAAWA,MAAA,CAAOd,CAAA,KAAM,KAAKc,MAAA,CAAOb,CAAA,KAAM,IAAI;MAChD,OAAOjB,gBAAA,CAAgBmC,QAAA,CACrBnC,gBAAA,CAAgBa,SAAA,CAAUiB,MAAA,CAAOd,CAAA,EAAGc,MAAA,CAAOb,CAAC,GAC5Cc,QAAA,EACA/B,gBAAA,CAAgBa,SAAA,CAAU,CAACiB,MAAA,CAAOd,CAAA,EAAG,CAACc,MAAA,CAAOb,CAAC,CAChD;IACF;IAEA,OAAOc,QAAA;EACT;EAMA,OAAOnB,MAAMwB,EAAA,EAAYC,EAAA,GAAaD,EAAA,EAAIN,MAAA,GAAgB;IAAEd,CAAA,EAAG;IAAGC,CAAA,EAAG;EAAE,GAAoB;IACzF,MAAML,KAAA,GAAQ,IAAIZ,gBAAA,CAAgB,CAACoC,EAAA,EAAI,GAAG,GAAG,GAAGC,EAAA,EAAI,CAAC,CAAC;IAEtD,IAAIP,MAAA,CAAOd,CAAA,KAAM,KAAKc,MAAA,CAAOb,CAAA,KAAM,GAAG;MACpC,OAAOjB,gBAAA,CAAgBmC,QAAA,CACrBnC,gBAAA,CAAgBa,SAAA,CAAUiB,MAAA,CAAOd,CAAA,EAAGc,MAAA,CAAOb,CAAC,GAC5CL,KAAA,EACAZ,gBAAA,CAAgBa,SAAA,CAAU,CAACiB,MAAA,CAAOd,CAAA,EAAG,CAACc,MAAA,CAAOb,CAAC,CAChD;IACF;IAEA,OAAOL,KAAA;EACT;EAMA,OAAOC,UAAUyB,EAAA,EAAYC,EAAA,EAA6B;IACxD,OAAO,IAAIvC,gBAAA,CAAgB,CAAC,GAAG,GAAGsC,EAAA,EAAI,GAAG,GAAGC,EAAE,CAAC;EACjD;EAMA,OAAOJ,SAAA,GAAY,CAACK,KAAA,EAAO,GAAGC,IAAI,GAAuC;IACvE,IAAI,CAACD,KAAA,EAAO,OAAOxC,gBAAA,CAAgB4B,QAAA;IACnC,OAAOa,IAAA,CAAKC,MAAA,CAAO,CAACC,MAAA,EAAQC,IAAA,KAASD,MAAA,CAAOjC,OAAA,CAAQkC,IAAI,GAAGJ,KAAK;EAClE;EAEA,IAAIK,EAAA,EAAI;IACN,OAAO,KAAK3C,GAAA;EACd;EAEA,IAAI4C,EAAA,EAAI;IACN,OAAO,KAAKzC,GAAA;EACd;EAEA,IAAI0C,EAAA,EAAI;IACN,OAAO,KAAK5C,GAAA;EACd;EAEA,IAAI6C,EAAA,EAAI;IACN,OAAO,KAAK1C,GAAA;EACd;EAEA,IAAIgC,GAAA,EAAK;IACP,OAAO,KAAKlC,GAAA;EACd;EAEA,IAAImC,GAAA,EAAK;IACP,OAAO,KAAKhC,GAAA;EACd;EAEA,IAAI0C,gBAAA,EAAyB;IAC3B,OAAO;MAAEjC,CAAA,EAAG,KAAK6B,CAAA;MAAG5B,CAAA,EAAG,KAAK+B;IAAE;EAChC;EAEA,IAAIE,sBAAA,EAA+B;IACjC,OAAO;MAAElC,CAAA,EAAG,KAAKsB,EAAA;MAAIrB,CAAA,EAAG,KAAKsB;IAAG;EAClC;EAEA,IAAIY,eAAA,EAAwB;IAC1B,OAAO;MAAEnC,CAAA,EAAG,KAAK+B,CAAA;MAAG9B,CAAA,EAAG,KAAK6B;IAAE;EAChC;EAEAM,SAAA,EAAW;IACT,OAAO,UAAU,KAAKP,CAAC,KAAK,KAAKC,CAAC,KAAK,KAAKC,CAAC,KAAK,KAAKC,CAAC,KAAK,KAAKV,EAAE,KAAK,KAAKC,EAAE;EAClF;AACF;;;AC9KA,SAASc,OAAOR,CAAA,EAASS,GAAA,EAAWC,CAAA,EAAiB;EACnD,IAAIvC,CAAA,GAAIsC,GAAA,CAAIE,IAAA;EACZ,IAAID,CAAA,KAAM,eAAevC,CAAA,GAAIsC,GAAA,CAAIE,IAAA;EACjC,IAAID,CAAA,KAAM,gBAAgBvC,CAAA,GAAIsC,GAAA,CAAIE,IAAA,GAAOF,GAAA,CAAIG,KAAA;EAC7C,IAAIF,CAAA,KAAM,gBAAgBvC,CAAA,GAAIsC,GAAA,CAAII,IAAA,GAAOJ,GAAA,CAAIG,KAAA;EAC7C,IAAIF,CAAA,KAAM,iBAAiBvC,CAAA,GAAIsC,GAAA,CAAII,IAAA;EACnC,IAAIH,CAAA,KAAM,UAAUvC,CAAA,GAAIsC,GAAA,CAAIK,IAAA,GAAOL,GAAA,CAAIG,KAAA,GAAQ;EAC/C,OAAO;IAAE,GAAGZ,CAAA;IAAG7B;EAAE;AACnB;AAEA,SAAS4C,OAAOf,CAAA,EAASS,GAAA,EAAWO,CAAA,EAAiB;EACnD,IAAI5C,CAAA,GAAIqC,GAAA,CAAIQ,IAAA;EACZ,IAAID,CAAA,KAAM,cAAc5C,CAAA,GAAIqC,GAAA,CAAIQ,IAAA;EAChC,IAAID,CAAA,KAAM,eAAe5C,CAAA,GAAIqC,GAAA,CAAIQ,IAAA,GAAOjB,CAAA,CAAEkB,MAAA;EAC1C,IAAIF,CAAA,KAAM,iBAAiB5C,CAAA,GAAIqC,GAAA,CAAIU,IAAA,GAAOnB,CAAA,CAAEkB,MAAA;EAC5C,IAAIF,CAAA,KAAM,kBAAkB5C,CAAA,GAAIqC,GAAA,CAAIU,IAAA;EACpC,IAAIH,CAAA,KAAM,UAAU5C,CAAA,GAAIqC,GAAA,CAAIW,IAAA,GAAOpB,CAAA,CAAEkB,MAAA,GAAS;EAC9C,OAAO;IAAE,GAAGlB,CAAA;IAAG5B;EAAE;AACnB;AAEO,SAASiD,UAAUrB,CAAA,EAASS,GAAA,EAAWa,OAAA,EAA6B;EACzE,MAAM;IAAEZ,CAAA;IAAGM;EAAE,IAAIM,OAAA;EACjB,OAAOP,MAAA,CAAOP,MAAA,CAAOR,CAAA,EAAGS,GAAA,EAAKC,CAAC,GAAGD,GAAA,EAAKO,CAAC;AACzC;;;ACvBA,IAAMO,KAAA,GAAQA,CAACC,KAAA,EAAeC,IAAA,EAAaC,IAAA,KAAgBvC,IAAA,CAAKwC,GAAA,CAAIxC,IAAA,CAAKyC,GAAA,CAAIJ,KAAA,EAAOC,IAAG,GAAGC,IAAG;AAEtF,IAAMG,UAAA,GAAaA,CAACC,QAAA,EAAiBC,IAAA,EAAYC,YAAA,KAA2B;EACjF,MAAM7D,CAAA,GAAIoD,KAAA,CAAMO,QAAA,CAAS3D,CAAA,EAAG6D,YAAA,CAAa7D,CAAA,EAAG6D,YAAA,CAAa7D,CAAA,GAAI6D,YAAA,CAAapB,KAAA,GAAQmB,IAAA,CAAKnB,KAAK;EAC5F,MAAMxC,CAAA,GAAImD,KAAA,CAAMO,QAAA,CAAS1D,CAAA,EAAG4D,YAAA,CAAa5D,CAAA,EAAG4D,YAAA,CAAa5D,CAAA,GAAI4D,YAAA,CAAad,MAAA,GAASa,IAAA,CAAKb,MAAM;EAC9F,OAAO;IAAE/C,CAAA;IAAGC;EAAE;AAChB;AAEA,IAAM6D,cAAA,GAAuB;EAC3BrB,KAAA,EAAO;EACPM,MAAA,EAAQ;AACV;AAEA,IAAMgB,cAAA,GAAuB;EAC3BtB,KAAA,EAAOuB,QAAA;EACPjB,MAAA,EAAQiB;AACV;AAEO,IAAMC,SAAA,GAAYA,CAACL,IAAA,EAAYM,OAAA,GAAUJ,cAAA,EAAgBK,OAAA,GAAUJ,cAAA,KAAmB;EAC3F,OAAO;IACLtB,KAAA,EAAOzB,IAAA,CAAKwC,GAAA,CAAIxC,IAAA,CAAKyC,GAAA,CAAIG,IAAA,CAAKnB,KAAA,EAAOyB,OAAA,CAASzB,KAAK,GAAG0B,OAAA,CAAS1B,KAAK;IACpEM,MAAA,EAAQ/B,IAAA,CAAKwC,GAAA,CAAIxC,IAAA,CAAKyC,GAAA,CAAIG,IAAA,CAAKb,MAAA,EAAQmB,OAAA,CAASnB,MAAM,GAAGoB,OAAA,CAASpB,MAAM;EAC1E;AACF;;;ACnBO,IAAMqB,WAAA,GAAcA,CAACpE,CAAA,EAAWC,CAAA,MAAe;EAAED,CAAA;EAAGC;AAAE;AAEtD,IAAMoE,cAAA,GAAiBA,CAACxC,CAAA,EAAUC,CAAA,KAAasC,WAAA,CAAYvC,CAAA,CAAE7B,CAAA,GAAI8B,CAAA,CAAE9B,CAAA,EAAG6B,CAAA,CAAE5B,CAAA,GAAI6B,CAAA,CAAE7B,CAAC;AAC/E,IAAMqE,SAAA,GAAYA,CAACzC,CAAA,EAAUC,CAAA,KAAasC,WAAA,CAAYvC,CAAA,CAAE7B,CAAA,GAAI8B,CAAA,CAAE9B,CAAA,EAAG6B,CAAA,CAAE5B,CAAA,GAAI6B,CAAA,CAAE7B,CAAC;AAE1E,SAASsE,QAAQ1B,CAAA,EAAoB;EAC1C,OAAO2B,OAAA,CAAQC,GAAA,CAAI5B,CAAA,EAAG,GAAG,KAAK2B,OAAA,CAAQC,GAAA,CAAI5B,CAAA,EAAG,GAAG;AAClD;AAMO,SAAS6B,WAAWC,CAAA,EAAmB;EAC5C,MAAM;IAAE3E,CAAA;IAAGC,CAAA;IAAGwC,KAAA;IAAOM;EAAO,IAAI4B,CAAA;EAChC,MAAMhC,IAAA,GAAO3C,CAAA,GAAIyC,KAAA,GAAQ;EACzB,MAAMQ,IAAA,GAAOhD,CAAA,GAAI8C,MAAA,GAAS;EAC1B,OAAO;IACL/C,CAAA;IACAC,CAAA;IACAwC,KAAA;IACAM,MAAA;IACAP,IAAA,EAAMxC,CAAA;IACN8C,IAAA,EAAM7C,CAAA;IACNyC,IAAA,EAAM1C,CAAA,GAAIyC,KAAA;IACVO,IAAA,EAAM/C,CAAA,GAAI8C,MAAA;IACVJ,IAAA;IACAM,IAAA;IACA2B,MAAA,EAAQR,WAAA,CAAYzB,IAAA,EAAMM,IAAI;EAChC;AACF;AAEO,SAAS4B,OAAOhC,CAAA,EAAmB;EACxC,OAAO2B,OAAA,CAAQC,GAAA,CAAI5B,CAAA,EAAG,GAAG,KAAK2B,OAAA,CAAQC,GAAA,CAAI5B,CAAA,EAAG,GAAG,KAAK2B,OAAA,CAAQC,GAAA,CAAI5B,CAAA,EAAG,OAAO,KAAK2B,OAAA,CAAQC,GAAA,CAAI5B,CAAA,EAAG,QAAQ;AACzG;AAEO,SAASiC,eAAejC,CAAA,EAAS;EACtC,MAAMkC,GAAA,GAAMX,WAAA,CAAYvB,CAAA,CAAEF,IAAA,EAAME,CAAA,CAAEC,IAAI;EACtC,MAAMkC,KAAA,GAAQZ,WAAA,CAAYvB,CAAA,CAAEH,IAAA,EAAMG,CAAA,CAAEI,IAAI;EACxC,MAAMgC,MAAA,GAASb,WAAA,CAAYvB,CAAA,CAAEF,IAAA,EAAME,CAAA,CAAEG,IAAI;EACzC,MAAMkC,IAAA,GAAOd,WAAA,CAAYvB,CAAA,CAAEL,IAAA,EAAMK,CAAA,CAAEI,IAAI;EACvC,OAAO;IAAE8B,GAAA;IAAKC,KAAA;IAAOC,MAAA;IAAQC;EAAK;AACpC;AAEO,SAASC,eAAetC,CAAA,EAAS;EACtC,MAAMkC,GAAA,GAAMX,WAAA,CAAYvB,CAAA,CAAEL,IAAA,EAAMK,CAAA,CAAEC,IAAI;EACtC,MAAMkC,KAAA,GAAQZ,WAAA,CAAYvB,CAAA,CAAEH,IAAA,EAAMG,CAAA,CAAEC,IAAI;EACxC,MAAMmC,MAAA,GAASb,WAAA,CAAYvB,CAAA,CAAEH,IAAA,EAAMG,CAAA,CAAEG,IAAI;EACzC,MAAMkC,IAAA,GAAOd,WAAA,CAAYvB,CAAA,CAAEL,IAAA,EAAMK,CAAA,CAAEG,IAAI;EACvC,OAAO;IAAE+B,GAAA;IAAKC,KAAA;IAAOC,MAAA;IAAQC;EAAK;AACpC;AAEO,SAASE,aAAavC,CAAA,EAAS;EACpC,MAAMd,CAAA,GAAIoD,cAAA,CAAetC,CAAC;EAC1B,MAAMkC,GAAA,GAAgB,CAAChD,CAAA,CAAEgD,GAAA,EAAKhD,CAAA,CAAEiD,KAAK;EACrC,MAAMA,KAAA,GAAkB,CAACjD,CAAA,CAAEiD,KAAA,EAAOjD,CAAA,CAAEkD,MAAM;EAC1C,MAAMA,MAAA,GAAmB,CAAClD,CAAA,CAAEmD,IAAA,EAAMnD,CAAA,CAAEkD,MAAM;EAC1C,MAAMC,IAAA,GAAiB,CAACnD,CAAA,CAAEgD,GAAA,EAAKhD,CAAA,CAAEmD,IAAI;EACrC,OAAO;IAAEH,GAAA;IAAKC,KAAA;IAAOC,MAAA;IAAQC;EAAK;AACpC;;;AC3DO,SAASG,WAAWxD,CAAA,EAASC,CAAA,EAAkB;EACpD,OAAOD,CAAA,CAAE7B,CAAA,GAAI8B,CAAA,CAAEY,IAAA,IAAQb,CAAA,CAAE5B,CAAA,GAAI6B,CAAA,CAAEkB,IAAA,IAAQnB,CAAA,CAAEa,IAAA,GAAOZ,CAAA,CAAE9B,CAAA,IAAK6B,CAAA,CAAEmB,IAAA,GAAOlB,CAAA,CAAE7B,CAAA;AACpE;AAKO,SAASqF,aAAazD,CAAA,EAASC,CAAA,EAAe;EACnD,MAAM9B,CAAA,GAAIgB,IAAA,CAAKyC,GAAA,CAAI5B,CAAA,CAAE7B,CAAA,EAAG8B,CAAA,CAAE9B,CAAC;EAC3B,MAAMC,CAAA,GAAIe,IAAA,CAAKyC,GAAA,CAAI5B,CAAA,CAAE5B,CAAA,EAAG6B,CAAA,CAAE7B,CAAC;EAC3B,MAAMsF,EAAA,GAAKvE,IAAA,CAAKwC,GAAA,CAAI3B,CAAA,CAAE7B,CAAA,GAAI6B,CAAA,CAAEY,KAAA,EAAOX,CAAA,CAAE9B,CAAA,GAAI8B,CAAA,CAAEW,KAAK;EAChD,MAAM+C,EAAA,GAAKxE,IAAA,CAAKwC,GAAA,CAAI3B,CAAA,CAAE5B,CAAA,GAAI4B,CAAA,CAAEkB,MAAA,EAAQjB,CAAA,CAAE7B,CAAA,GAAI6B,CAAA,CAAEiB,MAAM;EAClD,OAAO2B,UAAA,CAAW;IAAE1E,CAAA;IAAGC,CAAA;IAAGwC,KAAA,EAAO8C,EAAA,GAAKvF,CAAA;IAAG+C,MAAA,EAAQyC,EAAA,GAAKvF;EAAE,CAAC;AAC3D;AAKO,SAASwF,WAAW5D,CAAA,EAASC,CAAA,EAAoC;EACtE,OAAO;IACLiD,GAAA,EAAKlD,CAAA,CAAEiB,IAAA,IAAQhB,CAAA,CAAEgB,IAAA;IACjBkC,KAAA,EAAOnD,CAAA,CAAEa,IAAA,IAAQZ,CAAA,CAAEY,IAAA;IACnBuC,MAAA,EAAQpD,CAAA,CAAEmB,IAAA,IAAQlB,CAAA,CAAEkB,IAAA;IACpBkC,IAAA,EAAMrD,CAAA,CAAEW,IAAA,IAAQV,CAAA,CAAEU;EACpB;AACF;;;ACxBO,SAASkD,SAAS7D,CAAA,EAAUC,CAAA,GAAW;EAAE9B,CAAA,EAAG;EAAGC,CAAA,EAAG;AAAE,GAAW;EACpE,OAAOe,IAAA,CAAK2E,IAAA,CAAK3E,IAAA,CAAK4E,GAAA,CAAI/D,CAAA,CAAE7B,CAAA,GAAI8B,CAAA,CAAE9B,CAAA,EAAG,CAAC,IAAIgB,IAAA,CAAK4E,GAAA,CAAI/D,CAAA,CAAE5B,CAAA,GAAI6B,CAAA,CAAE7B,CAAA,EAAG,CAAC,CAAC;AAClE;AAEO,SAAS4F,kBAAkBlB,CAAA,EAASmB,CAAA,EAAyB;EAClE,IAAI9F,CAAA,GAAI;EACR,IAAIC,CAAA,GAAI;EAER,IAAI6F,CAAA,CAAE9F,CAAA,GAAI2E,CAAA,CAAE3E,CAAA,EAAGA,CAAA,GAAI2E,CAAA,CAAE3E,CAAA,GAAI8F,CAAA,CAAE9F,CAAA,UAClB8F,CAAA,CAAE9F,CAAA,GAAI2E,CAAA,CAAEjC,IAAA,EAAM1C,CAAA,GAAI8F,CAAA,CAAE9F,CAAA,GAAI2E,CAAA,CAAEjC,IAAA;EAEnC,IAAIoD,CAAA,CAAE7F,CAAA,GAAI0E,CAAA,CAAE1E,CAAA,EAAGA,CAAA,GAAI0E,CAAA,CAAE1E,CAAA,GAAI6F,CAAA,CAAE7F,CAAA,UAClB6F,CAAA,CAAE7F,CAAA,GAAI0E,CAAA,CAAE3B,IAAA,EAAM/C,CAAA,GAAI6F,CAAA,CAAE7F,CAAA,GAAI0E,CAAA,CAAE3B,IAAA;EACnC,OAAO;IAAEhD,CAAA;IAAGC,CAAA;IAAGoD,KAAA,EAAOqC,QAAA,CAAS;MAAE1F,CAAA;MAAGC;IAAE,CAAC;EAAE;AAC3C;AAEO,SAAS8F,iBAAiBlE,CAAA,EAASC,CAAA,EAAwB;EAChE,IAAIuD,UAAA,CAAWxD,CAAA,EAAGC,CAAC,GAAG,OAAO;IAAE9B,CAAA,EAAG;IAAGC,CAAA,EAAG;IAAGoD,KAAA,EAAO;EAAE;EACpD,MAAM6B,IAAA,GAAOrD,CAAA,CAAE7B,CAAA,GAAI8B,CAAA,CAAE9B,CAAA,GAAI6B,CAAA,GAAIC,CAAA;EAC7B,MAAMkD,KAAA,GAAQlD,CAAA,CAAE9B,CAAA,GAAI6B,CAAA,CAAE7B,CAAA,GAAI6B,CAAA,GAAIC,CAAA;EAC9B,MAAMkE,KAAA,GAAQnE,CAAA,CAAE5B,CAAA,GAAI6B,CAAA,CAAE7B,CAAA,GAAI4B,CAAA,GAAIC,CAAA;EAC9B,MAAMmE,KAAA,GAAQnE,CAAA,CAAE7B,CAAA,GAAI4B,CAAA,CAAE5B,CAAA,GAAI4B,CAAA,GAAIC,CAAA;EAC9B,IAAI9B,CAAA,GAAIkF,IAAA,CAAKlF,CAAA,KAAMgF,KAAA,CAAMhF,CAAA,GAAI,IAAIgF,KAAA,CAAMhF,CAAA,GAAIkF,IAAA,CAAKxC,IAAA;EAChD1C,CAAA,GAAIgB,IAAA,CAAKyC,GAAA,CAAI,GAAGzD,CAAC;EACjB,IAAIC,CAAA,GAAI+F,KAAA,CAAM/F,CAAA,KAAMgG,KAAA,CAAMhG,CAAA,GAAI,IAAIgG,KAAA,CAAMhG,CAAA,GAAI+F,KAAA,CAAMhD,IAAA;EAClD/C,CAAA,GAAIe,IAAA,CAAKyC,GAAA,CAAI,GAAGxD,CAAC;EACjB,OAAO;IAAED,CAAA;IAAGC,CAAA;IAAGoD,KAAA,EAAOqC,QAAA,CAAS;MAAE1F,CAAA;MAAGC;IAAE,CAAC;EAAE;AAC3C;AAEO,SAASiG,iBAAiBrE,CAAA,EAASC,CAAA,EAAmC;EAC3E,OAAO;IACLoD,IAAA,EAAMpD,CAAA,CAAE9B,CAAA,GAAI6B,CAAA,CAAE7B,CAAA;IACd+E,GAAA,EAAKjD,CAAA,CAAE7B,CAAA,GAAI4B,CAAA,CAAE5B,CAAA;IACb+E,KAAA,EAAOnD,CAAA,CAAEa,IAAA,GAAOZ,CAAA,CAAEY,IAAA;IAClBuC,MAAA,EAAQpD,CAAA,CAAEmB,IAAA,GAAOlB,CAAA,CAAEkB;EACrB;AACF;;;ACxCO,SAASmD,QAAA,GAAWC,GAAA,EAAc;EACvC,OAAQvE,CAAA,IAAoB;IAC1B,MAAMwE,EAAA,GAAKD,GAAA,CAAIE,GAAA,CAAKxE,CAAA,IAAM4D,QAAA,CAAS5D,CAAA,EAAGD,CAAC,CAAC;IACxC,MAAME,CAAA,GAAIf,IAAA,CAAKwC,GAAA,CAAI+C,KAAA,CAAMvF,IAAA,EAAMqF,EAAE;IACjC,OAAOD,GAAA,CAAIC,EAAA,CAAGG,OAAA,CAAQzE,CAAC,CAAC;EAC1B;AACF;AAEO,SAAS0E,kBAAkBnE,GAAA,EAAWqC,CAAA,EAAmB;EAC9D,IAAIA,CAAA,CAAEjC,IAAA,IAAQJ,GAAA,CAAIE,IAAA,EAAM,OAAO;EAC/B,IAAImC,CAAA,CAAEnC,IAAA,IAAQF,GAAA,CAAII,IAAA,EAAM,OAAO;EAC/B,IAAIiC,CAAA,CAAE3B,IAAA,IAAQV,GAAA,CAAIQ,IAAA,EAAM,OAAO;EAC/B,IAAI6B,CAAA,CAAE7B,IAAA,IAAQR,GAAA,CAAIU,IAAA,EAAM,OAAO;EAC/B,OAAO;AACT;AAEO,SAAS0D,mBAAmBpE,GAAA,EAAWwD,CAAA,EAAoB;EAChE,MAAM;IAAE9F,CAAA;IAAGC;EAAE,IAAI6F,CAAA;EAEjB,MAAMa,EAAA,GAAK3G,CAAA,GAAIsC,GAAA,CAAIE,IAAA;EACnB,MAAMoE,EAAA,GAAKtE,GAAA,CAAII,IAAA,GAAO1C,CAAA;EACtB,MAAM6G,EAAA,GAAK5G,CAAA,GAAIqC,GAAA,CAAIQ,IAAA;EACnB,MAAMgE,EAAA,GAAKxE,GAAA,CAAIU,IAAA,GAAO/C,CAAA;EAEtB,IAAI8G,QAAA,GAAUJ,EAAA;EACd,IAAIK,IAAA,GAAiB;EAErB,IAAIJ,EAAA,GAAKG,QAAA,EAAS;IAChBA,QAAA,GAAUH,EAAA;IACVI,IAAA,GAAO;EACT;EACA,IAAIH,EAAA,GAAKE,QAAA,EAAS;IAChBA,QAAA,GAAUF,EAAA;IACVG,IAAA,GAAO;EACT;EACA,IAAIF,EAAA,GAAKC,QAAA,EAAS;IAChBC,IAAA,GAAO;EACT;EAEA,OAAOA,IAAA;AACT;;;ACvCO,IAAMC,aAAA,GAAgBA,CAACC,IAAA,EAAgBC,QAAA,KAAiC;EAC7E,MAAMjC,IAAA,GAAOlE,IAAA,CAAKyC,GAAA,CAAI0D,QAAA,CAASnH,CAAA,EAAGgB,IAAA,CAAKwC,GAAA,CAAI0D,IAAA,CAAKlH,CAAA,EAAGmH,QAAA,CAASnH,CAAA,GAAImH,QAAA,CAAS1E,KAAA,GAAQyE,IAAA,CAAKzE,KAAK,CAAC;EAC5F,MAAMsC,GAAA,GAAM/D,IAAA,CAAKyC,GAAA,CAAI0D,QAAA,CAASlH,CAAA,EAAGe,IAAA,CAAKwC,GAAA,CAAI0D,IAAA,CAAKjH,CAAA,EAAGkH,QAAA,CAASlH,CAAA,GAAIkH,QAAA,CAASpE,MAAA,GAASmE,IAAA,CAAKnE,MAAM,CAAC;EAE7F,OAAO;IACL/C,CAAA,EAAGkF,IAAA;IACHjF,CAAA,EAAG8E,GAAA;IACHtC,KAAA,EAAOzB,IAAA,CAAKwC,GAAA,CAAI0D,IAAA,CAAKzE,KAAA,EAAO0E,QAAA,CAAS1E,KAAK;IAC1CM,MAAA,EAAQ/B,IAAA,CAAKwC,GAAA,CAAI0D,IAAA,CAAKnE,MAAA,EAAQoE,QAAA,CAASpE,MAAM;EAC/C;AACF;;;ACXO,SAASqE,cAAczC,CAAA,EAASmB,CAAA,EAAmB;EACxD,OAAOnB,CAAA,CAAEnC,IAAA,IAAQsD,CAAA,CAAE9F,CAAA,IAAK8F,CAAA,CAAE9F,CAAA,IAAK2E,CAAA,CAAEjC,IAAA,IAAQiC,CAAA,CAAE7B,IAAA,IAAQgD,CAAA,CAAE7F,CAAA,IAAK6F,CAAA,CAAE7F,CAAA,IAAK0E,CAAA,CAAE3B,IAAA;AACrE;AAEO,SAASqE,aAAaxF,CAAA,EAASC,CAAA,EAAkB;EACtD,OAAOwF,MAAA,CAAOC,MAAA,CAAOpC,cAAA,CAAerD,CAAC,CAAC,EAAE0F,KAAA,CAAOzF,CAAA,IAAMqF,aAAA,CAAcvF,CAAA,EAAGE,CAAC,CAAC;AAC1E;AAEO,SAAS0F,SAAS9C,CAAA,EAAS9B,CAAA,EAA0B;EAC1D,OAAOgC,MAAA,CAAOhC,CAAC,IAAIwE,YAAA,CAAa1C,CAAA,EAAG9B,CAAC,IAAIuE,aAAA,CAAczC,CAAA,EAAG9B,CAAC;AAC5D;;;ACXO,IAAM6E,WAAA,GAAcA,CAAC7F,CAAA,EAASC,CAAA,KAAY;EAC/C,OAAOD,CAAA,CAAEY,KAAA,KAAUX,CAAA,CAAEW,KAAA,IAASZ,CAAA,CAAEkB,MAAA,KAAWjB,CAAA,CAAEiB,MAAA;AAC/C;AAEO,IAAM4E,YAAA,GAAeA,CAAC9F,CAAA,EAAUC,CAAA,KAAa;EAClD,OAAOD,CAAA,CAAE7B,CAAA,KAAM8B,CAAA,CAAE9B,CAAA,IAAK6B,CAAA,CAAE5B,CAAA,KAAM6B,CAAA,CAAE7B,CAAA;AAClC;AAEO,IAAM2H,WAAA,GAAcA,CAAC/F,CAAA,EAAaC,CAAA,KAAgB;EACvD,OAAO6F,YAAA,CAAa9F,CAAA,EAAGC,CAAC,KAAK4F,WAAA,CAAY7F,CAAA,EAAGC,CAAC;AAC/C;;;ACTA,IAAM+F,UAAA,GAAa,mBAAIC,OAAA,CAA0B;AAEjD,SAASC,sBAAsBC,EAAA,EAAiB;EAC9C,IAAI,CAACH,UAAA,CAAWpD,GAAA,CAAIuD,EAAE,GAAG;IACvB,MAAMC,GAAA,GAAMD,EAAA,CAAGE,aAAA,CAAcC,WAAA,IAAeC,MAAA;IAC5CP,UAAA,CAAWQ,GAAA,CAAIL,EAAA,EAAIC,GAAA,CAAIK,gBAAA,CAAiBN,EAAE,CAAC;EAC7C;EACA,OAAOH,UAAA,CAAWU,GAAA,CAAIP,EAAE;AAC1B;AAEO,SAASQ,eAAeR,EAAA,EAAiBS,IAAA,GAA2B,CAAC,GAAS;EACnF,OAAO/D,UAAA,CAAWgE,aAAA,CAAcV,EAAA,EAAIS,IAAI,CAAC;AAC3C;AAaA,SAASC,cAAcV,EAAA,EAAiBS,IAAA,GAA2B,CAAC,GAAG;EACrE,MAAM;IAAEE,gBAAA,GAAmB;IAAOC,cAAA,GAAiB;EAAM,IAAIH,IAAA;EAE7D,MAAM;IAAEzI,CAAA;IAAGC,CAAA;IAAGwC,KAAA;IAAOM;EAAO,IAAIiF,EAAA,CAAGa,qBAAA,CAAsB;EACzD,MAAMlE,CAAA,GAAI;IAAE3E,CAAA;IAAGC,CAAA;IAAGwC,KAAA;IAAOM;EAAO;EAEhC,MAAM+F,KAAA,GAAQf,qBAAA,CAAsBC,EAAE;EAEtC,MAAM;IAAEe,eAAA;IAAiBC,cAAA;IAAgBC,gBAAA;IAAkBC;EAAkB,IAAIJ,KAAA;EAEjF,MAAMK,YAAA,GAAeC,GAAA,CAAIL,eAAA,EAAiBE,gBAAgB;EAC1D,MAAMI,YAAA,GAAeD,GAAA,CAAIJ,cAAA,EAAgBE,iBAAiB;EAE1D,IAAIN,cAAA,EAAgB;IAClBjE,CAAA,CAAElC,KAAA,IAAS0G,YAAA;IACXxE,CAAA,CAAE5B,MAAA,IAAUsG,YAAA;IACZ1E,CAAA,CAAE3E,CAAA,IAAKsJ,EAAA,CAAGP,eAAe;IACzBpE,CAAA,CAAE1E,CAAA,IAAKqJ,EAAA,CAAGN,cAAc;EAC1B;EAEA,IAAIL,gBAAA,EAAkB;IACpB,MAAMY,cAAA,GAAiBvB,EAAA,CAAGwB,WAAA,GAAcxB,EAAA,CAAGyB,WAAA,GAAcN,YAAA;IACzD,MAAMO,eAAA,GAAkB1B,EAAA,CAAG2B,YAAA,GAAe3B,EAAA,CAAG4B,YAAA,GAAeP,YAAA;IAC5D1E,CAAA,CAAElC,KAAA,IAAS8G,cAAA;IACX5E,CAAA,CAAE5B,MAAA,IAAU2G,eAAA;EACd;EAEA,OAAO/E,CAAA;AACT;AAEA,IAAM2E,EAAA,GAAMzG,CAAA,IAAcgH,UAAA,CAAWhH,CAAA,CAAEiH,OAAA,CAAQ,MAAM,EAAE,CAAC;AAExD,IAAMV,GAAA,GAAMA,CAAA,GAAIW,IAAA,KAAmBA,IAAA,CAAKrI,MAAA,CAAO,CAACsI,IAAA,EAAKnH,CAAA,KAAMmH,IAAA,IAAOnH,CAAA,GAAIyG,EAAA,CAAGzG,CAAC,IAAI,IAAI,CAAC;;;ACzD5E,SAASoH,kBAAA,GAAqB7D,GAAA,EAAoB;EACvD,MAAM8D,EAAA,GAAK9D,GAAA,CAAIE,GAAA,CAAKR,CAAA,IAAMA,CAAA,CAAE9F,CAAC;EAC7B,MAAMmK,EAAA,GAAK/D,GAAA,CAAIE,GAAA,CAAKR,CAAA,IAAMA,CAAA,CAAE7F,CAAC;EAE7B,MAAMD,CAAA,GAAIgB,IAAA,CAAKwC,GAAA,CAAI,GAAG0G,EAAE;EACxB,MAAMjK,CAAA,GAAIe,IAAA,CAAKwC,GAAA,CAAI,GAAG2G,EAAE;EAExB,MAAM1H,KAAA,GAAQzB,IAAA,CAAKyC,GAAA,CAAI,GAAGyG,EAAE,IAAIlK,CAAA;EAChC,MAAM+C,MAAA,GAAS/B,IAAA,CAAKyC,GAAA,CAAI,GAAG0G,EAAE,IAAIlK,CAAA;EAEjC,OAAOyE,UAAA,CAAW;IAAE1E,CAAA;IAAGC,CAAA;IAAGwC,KAAA;IAAOM;EAAO,CAAC;AAC3C;;;ACXA,IAAM;EAAES,GAAA;EAAKC;AAAI,IAAIzC,IAAA;AAEd,SAASoJ,MAAA,GAASC,EAAA,EAAkB;EACzC,MAAMC,IAAA,GAAO;IACXtK,CAAA,EAAGwD,GAAA,CAAI,GAAG6G,EAAA,CAAG/D,GAAA,CAAK3B,CAAA,IAAMA,CAAA,CAAEnC,IAAI,CAAC;IAC/BvC,CAAA,EAAGuD,GAAA,CAAI,GAAG6G,EAAA,CAAG/D,GAAA,CAAK3B,CAAA,IAAMA,CAAA,CAAE7B,IAAI,CAAC;EACjC;EACA,MAAMyH,IAAA,GAAO;IACXvK,CAAA,EAAGyD,GAAA,CAAI,GAAG4G,EAAA,CAAG/D,GAAA,CAAK3B,CAAA,IAAMA,CAAA,CAAEjC,IAAI,CAAC;IAC/BzC,CAAA,EAAGwD,GAAA,CAAI,GAAG4G,EAAA,CAAG/D,GAAA,CAAK3B,CAAA,IAAMA,CAAA,CAAE3B,IAAI,CAAC;EACjC;EACA,OAAOiH,iBAAA,CAAkBK,IAAA,EAAMC,IAAI;AACrC;;;ACVO,SAASC,UAAUC,KAAA,EAAoB;EAC5C,IAAIJ,EAAA,GAAa,EAAC;EAClB,MAAMK,KAAA,GAAQC,KAAA,CAAMC,IAAA,CAAKH,KAAA,CAAMI,cAAA,CAAe,CAAC;EAE/C,IAAIH,KAAA,CAAMI,MAAA,EAAQ;IAChBT,EAAA,GAAKA,EAAA,CAAGU,MAAA,CAAOL,KAAA,CAAMpE,GAAA,CAAI5B,UAAU,CAAC;IACpC,OAAO0F,KAAA,CAAM7D,KAAA,CAAM,QAAW8D,EAAE;EAClC;EAEA,IAAIW,KAAA,GAAkCP,KAAA,CAAMQ,cAAA;EAE5C,IAAID,KAAA,CAAME,QAAA,KAAaC,IAAA,CAAKC,SAAA,EAAW;IACrCJ,KAAA,GAAQA,KAAA,CAAMK,UAAA;EAChB;EAEA,IAAIL,KAAA,YAAiBM,WAAA,EAAa;IAChC,MAAM3G,CAAA,GAAI6D,cAAA,CAAewC,KAAK;IAC9BX,EAAA,CAAGkB,IAAA,CAAK;MAAE,GAAG5G,CAAA;MAAG3E,CAAA,EAAG2E,CAAA,CAAEjC,IAAA;MAAMD,KAAA,EAAO;IAAE,CAAC;EACvC;EAEA,OAAO2H,KAAA,CAAM7D,KAAA,CAAM,QAAW8D,EAAE;AAClC;;;ACvBO,SAASmB,MAAMxJ,CAAA,EAAW;EAC/B,OAASA,CAAA,GAAI,MAAOhB,IAAA,CAAKyK,EAAA,GAAM;AACjC;AAEO,SAAS9L,OAAOkC,CAAA,EAAUG,CAAA,EAAWD,CAAA,EAAiB;EAC3D,MAAM4C,CAAA,GAAI6G,KAAA,CAAMxJ,CAAC;EAEjB,MAAMd,GAAA,GAAMF,IAAA,CAAKE,GAAA,CAAIyD,CAAC;EACtB,MAAM1D,GAAA,GAAMD,IAAA,CAAKC,GAAA,CAAI0D,CAAC;EAEtB,MAAM3E,CAAA,GAAI6B,CAAA,CAAE7B,CAAA,GAAI+B,CAAA,CAAE/B,CAAA;EAClB,MAAMC,CAAA,GAAI4B,CAAA,CAAE5B,CAAA,GAAI8B,CAAA,CAAE9B,CAAA;EAElB,OAAO;IACLD,CAAA,EAAG+B,CAAA,CAAE/B,CAAA,GAAIA,CAAA,GAAIiB,GAAA,GAAMhB,CAAA,GAAIiB,GAAA;IACvBjB,CAAA,EAAG8B,CAAA,CAAE9B,CAAA,GAAID,CAAA,GAAIkB,GAAA,GAAMjB,CAAA,GAAIgB;EACzB;AACF;AAEO,SAASyK,gBAAgB/G,CAAA,EAASgH,GAAA,EAAmB;EAC1D,MAAMC,EAAA,GAAKtE,MAAA,CAAOC,MAAA,CAAOpC,cAAA,CAAeR,CAAC,CAAC,EAAE2B,GAAA,CAAKR,CAAA,IAAMnG,MAAA,CAAOmG,CAAA,EAAG6F,GAAA,EAAKhH,CAAA,CAAEC,MAAM,CAAC;EAE/E,MAAMsF,EAAA,GAAK0B,EAAA,CAAGtF,GAAA,CAAKR,CAAA,IAAMA,CAAA,CAAE9F,CAAC;EAC5B,MAAMmK,EAAA,GAAKyB,EAAA,CAAGtF,GAAA,CAAKR,CAAA,IAAMA,CAAA,CAAE7F,CAAC;EAE5B,MAAMuC,IAAA,GAAOxB,IAAA,CAAKwC,GAAA,CAAI,GAAG0G,EAAE;EAC3B,MAAMpH,IAAA,GAAO9B,IAAA,CAAKwC,GAAA,CAAI,GAAG2G,EAAE;EAE3B,MAAMzH,IAAA,GAAO1B,IAAA,CAAKyC,GAAA,CAAI,GAAGyG,EAAE;EAC3B,MAAMlH,IAAA,GAAOhC,IAAA,CAAKyC,GAAA,CAAI,GAAG0G,EAAE;EAE3B,OAAOzF,UAAA,CAAW;IAChB1E,CAAA,EAAGwC,IAAA;IACHvC,CAAA,EAAG6C,IAAA;IACHL,KAAA,EAAOC,IAAA,GAAOF,IAAA;IACdO,MAAA,EAAQC,IAAA,GAAOF;EACjB,CAAC;AACH;;;AC3BO,SAAS+I,cAAc5D,GAAA,EAAaQ,IAAA,GAA0B,CAAC,GAAS;EAC7E,OAAO/D,UAAA,CAAWoH,eAAA,CAAgB7D,GAAA,EAAKQ,IAAI,CAAC;AAC9C;AAKO,SAASqD,gBAAgB7D,GAAA,EAAaQ,IAAA,EAAyB;EACpE,MAAM;IAAEE,gBAAA,GAAmB;EAAM,IAAIF,IAAA;EACrC,MAAM;IAAEsD,UAAA;IAAYC,WAAA;IAAaC,QAAA,EAAUC,GAAA;IAAKC;EAAe,IAAIlE,GAAA;EACnE,MAAMxF,KAAA,GAAQ0J,cAAA,EAAgB1J,KAAA,IAASsJ,UAAA;EACvC,MAAMhJ,MAAA,GAASoJ,cAAA,EAAgBpJ,MAAA,IAAUiJ,WAAA;EACzC,MAAM9E,IAAA,GAAO;IAAElH,CAAA,EAAG;IAAGC,CAAA,EAAG;IAAGwC,KAAA;IAAOM;EAAO;EACzC,IAAI4F,gBAAA,EAAkB;IACpB,MAAMY,cAAA,GAAiBwC,UAAA,GAAaG,GAAA,CAAIE,eAAA,CAAgB3C,WAAA;IACxD,MAAMC,eAAA,GAAkBsC,WAAA,GAAcE,GAAA,CAAIE,eAAA,CAAgBxC,YAAA;IAC1D1C,IAAA,CAAKzE,KAAA,IAAS8G,cAAA;IACdrC,IAAA,CAAKnE,MAAA,IAAU2G,eAAA;EACjB;EACA,OAAOxC,IAAA;AACT;;;AC9BO,IAAMmF,WAAA,GAAexJ,CAAA,IAAoC,QAAQA,CAAA,IAAK,QAAQA,CAAA;AAE9E,SAASyJ,MAAM3H,CAAA,EAAS4H,CAAA,EAAyC;EACtE,MAAM1J,CAAA,GAAIwJ,WAAA,CAAYE,CAAC,IAAI;IAAErH,IAAA,EAAMqH,CAAA,CAAEC,EAAA;IAAIxH,KAAA,EAAOuH,CAAA,CAAEC,EAAA;IAAIzH,GAAA,EAAKwH,CAAA,CAAEE,EAAA;IAAIxH,MAAA,EAAQsH,CAAA,CAAEE;EAAG,IAAIF,CAAA;EAClF,MAAM;IAAExH,GAAA,GAAM;IAAGC,KAAA,GAAQ;IAAGC,MAAA,GAAS;IAAGC,IAAA,GAAO;EAAE,IAAIrC,CAAA;EACrD,OAAO6B,UAAA,CAAW;IAChB1E,CAAA,EAAG2E,CAAA,CAAE3E,CAAA,GAAIkF,IAAA;IACTjF,CAAA,EAAG0E,CAAA,CAAE1E,CAAA,GAAI8E,GAAA;IACTtC,KAAA,EAAOkC,CAAA,CAAElC,KAAA,GAAQyC,IAAA,GAAOF,KAAA;IACxBjC,MAAA,EAAQ4B,CAAA,CAAE5B,MAAA,GAASgC,GAAA,GAAME;EAC3B,CAAC;AACH;AAEO,SAASyH,OAAO/H,CAAA,EAAS9B,CAAA,EAAsC;EACpE,MAAMQ,KAAA,GAAQ,OAAOR,CAAA,KAAM,WAAW;IAAE2J,EAAA,EAAI,CAAC3J,CAAA;IAAG4J,EAAA,EAAI,CAAC5J;EAAE,IAAIA,CAAA;EAC3D,OAAOyJ,KAAA,CAAM3H,CAAA,EAAGtB,KAAK;AACvB;AAEO,SAASsJ,OAAOhI,CAAA,EAAS9B,CAAA,EAAsC;EACpE,MAAMQ,KAAA,GAAQ,OAAOR,CAAA,KAAM,WAAW;IAAE2J,EAAA,EAAI,CAAC3J,CAAA;IAAG4J,EAAA,EAAI,CAAC5J;EAAE,IAAIA,CAAA;EAC3D,OAAOyJ,KAAA,CAAM3H,CAAA,EAAGtB,KAAK;AACvB;AAEO,SAASuJ,MAAMjI,CAAA,EAASkI,CAAA,EAAyB;EACtD,MAAM;IAAE7M,CAAA,GAAI;IAAGC,CAAA,GAAI;EAAE,IAAI4M,CAAA;EACzB,OAAOnI,UAAA,CAAW;IAChB1E,CAAA,EAAG2E,CAAA,CAAE3E,CAAA,GAAIA,CAAA;IACTC,CAAA,EAAG0E,CAAA,CAAE1E,CAAA,GAAIA,CAAA;IACTwC,KAAA,EAAOkC,CAAA,CAAElC,KAAA;IACTM,MAAA,EAAQ4B,CAAA,CAAE5B;EACZ,CAAC;AACH;;;AC/BO,SAAS+J,kBAAkBC,SAAA,EAAqBC,SAAA,EAAmB;EACxE,MAAM9F,IAAA,GAAOxC,UAAA,CAAWqI,SAAS;EACjC,MAAM;IAAEhI,GAAA;IAAKC,KAAA;IAAOE,IAAA;IAAMD;EAAO,IAAIE,cAAA,CAAe+B,IAAI;EACxD,MAAM,CAAC+F,IAAI,IAAID,SAAA,CAAUE,KAAA,CAAM,GAAG;EAElC,OAAO;IACLnI,GAAA,EAAK,CAACG,IAAA,EAAMH,GAAA,EAAKC,KAAA,EAAOC,MAAM;IAC9BD,KAAA,EAAO,CAACD,GAAA,EAAKC,KAAA,EAAOC,MAAA,EAAQC,IAAI;IAChCD,MAAA,EAAQ,CAACF,GAAA,EAAKG,IAAA,EAAMD,MAAA,EAAQD,KAAK;IACjCE,IAAA,EAAM,CAACF,KAAA,EAAOD,GAAA,EAAKG,IAAA,EAAMD,MAAM;EACjC,EAAEgI,IAAI;AACR;AAEO,SAASE,iBAAiBC,OAAA,EAAkBrN,KAAA,EAAc;EAC/D,MAAM;IAAEC,CAAA;IAAGC;EAAE,IAAIF,KAAA;EACjB,IAAIgC,CAAA,GAAI;EAER,SAASwK,CAAA,GAAI,GAAGc,CAAA,GAAID,OAAA,CAAQtC,MAAA,GAAS,GAAGyB,CAAA,GAAIa,OAAA,CAAQtC,MAAA,EAAQuC,CAAA,GAAId,CAAA,IAAK;IACnE,MAAMe,EAAA,GAAKF,OAAA,CAAQb,CAAC,EAAEvM,CAAA;IACtB,MAAMuN,EAAA,GAAKH,OAAA,CAAQb,CAAC,EAAEtM,CAAA;IACtB,MAAMuN,EAAA,GAAKJ,OAAA,CAAQC,CAAC,EAAErN,CAAA;IACtB,MAAMyN,EAAA,GAAKL,OAAA,CAAQC,CAAC,EAAEpN,CAAA;IAEtB,IAAIsN,EAAA,GAAKtN,CAAA,KAAMwN,EAAA,GAAKxN,CAAA,IAAKD,CAAA,IAAMwN,EAAA,GAAKF,EAAA,KAAOrN,CAAA,GAAIsN,EAAA,KAAQE,EAAA,GAAKF,EAAA,IAAMD,EAAA,EAAI;MACpEvL,CAAA,GAAI,CAACA,CAAA;IACP;EACF;EACA,OAAOA,CAAA;AACT;AAEA,SAAS2L,qBAAA,EAAuB;EAC9B,MAAMC,EAAA,GAAK;EACX,MAAMC,eAAA,GAAkB3B,QAAA,CAAS4B,cAAA,CAAeF,EAAE;EAClD,IAAIC,eAAA,EAAiB;IACnB,OAAOA,eAAA;EACT;EACA,MAAME,GAAA,GAAM7B,QAAA,CAAS8B,eAAA,CAAgB,8BAA8B,KAAK;EACxEzG,MAAA,CAAO0G,MAAA,CAAOF,GAAA,CAAIhF,KAAA,EAAO;IACvB/D,GAAA,EAAK;IACLG,IAAA,EAAM;IACNzC,KAAA,EAAO;IACPM,MAAA,EAAQ;IACRkL,OAAA,EAAS;IACTtK,QAAA,EAAU;IACVuK,aAAA,EAAe;IACfC,IAAA,EAAM;EACR,CAAC;EAED,MAAMf,OAAA,GAAUnB,QAAA,CAAS8B,eAAA,CAAgB,8BAA8B,SAAS;EAChFX,OAAA,CAAQgB,YAAA,CAAa,MAAMT,EAAE;EAC7BP,OAAA,CAAQgB,YAAA,CAAa,UAAU,SAAS;EACxCN,GAAA,CAAIO,WAAA,CAAYjB,OAAO;EACvBnB,QAAA,CAASqC,IAAA,CAAKD,WAAA,CAAYP,GAAG;EAC7B,OAAOV,OAAA;AACT;AAEO,SAASmB,aAAanB,OAAA,EAAkB;EAC7C,MAAMpF,EAAA,GAAK0F,oBAAA,CAAqB;EAChC,MAAMc,MAAA,GAASpB,OAAA,CAAQ9G,GAAA,CAAKvG,KAAA,IAAU,GAAGA,KAAA,CAAMC,CAAC,IAAID,KAAA,CAAME,CAAC,EAAE,EAAEwO,IAAA,CAAK,GAAG;EACvEzG,EAAA,CAAGoG,YAAA,CAAa,UAAUI,MAAM;EAChC,OAAO,MAAM;IACXxG,EAAA,CAAG0G,MAAA,CAAO;EACZ;AACF;;;AC9DO,IAAMC,mBAAA,GAAuD;EAClEC,CAAA,EAAG;IAAE5O,CAAA,EAAG;IAAKC,CAAA,EAAG;EAAE;EAClB4O,EAAA,EAAI;IAAE7O,CAAA,EAAG;IAAGC,CAAA,EAAG;EAAE;EACjB6O,CAAA,EAAG;IAAE9O,CAAA,EAAG;IAAGC,CAAA,EAAG;EAAI;EAClB8O,EAAA,EAAI;IAAE/O,CAAA,EAAG;IAAGC,CAAA,EAAG;EAAE;EACjB+O,CAAA,EAAG;IAAEhP,CAAA,EAAG;IAAKC,CAAA,EAAG;EAAE;EAClBgP,EAAA,EAAI;IAAEjP,CAAA,EAAG;IAAGC,CAAA,EAAG;EAAE;EACjBiP,CAAA,EAAG;IAAElP,CAAA,EAAG;IAAGC,CAAA,EAAG;EAAI;EAClBkP,EAAA,EAAI;IAAEnP,CAAA,EAAG;IAAGC,CAAA,EAAG;EAAE;AACnB;AAEO,IAAMmP,oBAAA,GAAmE;EAC9ER,CAAA,EAAG;EACHC,EAAA,EAAI;EACJC,CAAA,EAAG;EACHC,EAAA,EAAI;EACJC,CAAA,EAAG;EACHC,EAAA,EAAI;EACJC,CAAA,EAAG;EACHC,EAAA,EAAI;AACN;;;ACpBA,IAAM;EAAEE,IAAA;EAAMC,GAAA;EAAK9L,GAAA,EAAA+L;AAAI,IAAIvO,IAAA;AAE3B,SAASwO,mBAAmBtI,IAAA,EAAYuI,SAAA,EAA6B;EACnE,MAAM;IAAEjN,IAAA;IAAMM,IAAA;IAAMJ,IAAA;IAAMM,IAAA;IAAML,IAAA;IAAMM;EAAK,IAAIiE,IAAA;EAC/C,MAAMlH,CAAA,GAAIyP,SAAA,CAAUC,QAAA,CAAS,GAAG,IAAIlN,IAAA,GAAOiN,SAAA,CAAUC,QAAA,CAAS,GAAG,IAAIhN,IAAA,GAAOC,IAAA;EAC5E,MAAM1C,CAAA,GAAIwP,SAAA,CAAUC,QAAA,CAAS,GAAG,IAAI5M,IAAA,GAAO2M,SAAA,CAAUC,QAAA,CAAS,GAAG,IAAI1M,IAAA,GAAOC,IAAA;EAC5E,OAAO;IAAEjD,CAAA;IAAGC;EAAE;AAChB;AAEA,SAAS0P,qBAAqBF,SAAA,EAA6B;EACzD,OAAOL,oBAAA,CAAqBK,SAAS;AACvC;AAEO,SAASG,WAAW1I,IAAA,EAAY2I,MAAA,EAAeJ,SAAA,EAA6BhH,IAAA,EAAsB;EACvG,MAAM;IAAEqH,iBAAA;IAAmBC;EAAgB,IAAItH,IAAA;EAE/C,MAAMuH,MAAA,GAASR,kBAAA,CAAmBtI,IAAA,EAAMuI,SAAS;EAEjD,MAAMQ,iBAAA,GAAoBN,oBAAA,CAAqBF,SAAS;EACxD,MAAMS,cAAA,GAAiBV,kBAAA,CAAmBtI,IAAA,EAAM+I,iBAAiB;EAEjE,IAAIH,iBAAA,KAAsB,UAAU;IAClCD,MAAA,GAAS;MAAE7P,CAAA,EAAG6P,MAAA,CAAO7P,CAAA,GAAI;MAAGC,CAAA,EAAG4P,MAAA,CAAO5P,CAAA,GAAI;IAAE;EAC9C;EAEA,MAAMkQ,SAAA,GAAY;IAChBnQ,CAAA,EAAGgQ,MAAA,CAAOhQ,CAAA,GAAI6P,MAAA,CAAO7P,CAAA;IACrBC,CAAA,EAAG+P,MAAA,CAAO/P,CAAA,GAAI4P,MAAA,CAAO5P;EACvB;EAEA,MAAMmQ,UAAA,GAAa;IACjBpQ,CAAA,EAAG2O,mBAAA,CAAoBc,SAAS,EAAEzP,CAAA,GAAI,IAAI;IAC1CC,CAAA,EAAG0O,mBAAA,CAAoBc,SAAS,EAAExP,CAAA,GAAI,IAAI;EAC5C;EAEA,MAAMoQ,OAAA,GAAU;IACd5N,KAAA,EAAO0N,SAAA,CAAUnQ,CAAA,GAAIkQ,cAAA,CAAelQ,CAAA;IACpC+C,MAAA,EAAQoN,SAAA,CAAUlQ,CAAA,GAAIiQ,cAAA,CAAejQ;EACvC;EAEA,MAAMqQ,MAAA,GAAUF,UAAA,CAAWpQ,CAAA,GAAIqQ,OAAA,CAAQ5N,KAAA,GAASyE,IAAA,CAAKzE,KAAA;EACrD,MAAM8N,MAAA,GAAUH,UAAA,CAAWnQ,CAAA,GAAIoQ,OAAA,CAAQtN,MAAA,GAAUmE,IAAA,CAAKnE,MAAA;EAEtD,MAAMyN,gBAAA,GAAmBlB,GAAA,CAAIgB,MAAM,IAAIhB,GAAA,CAAIiB,MAAM,IAAID,MAAA,GAASC,MAAA;EAE9D,MAAM3Q,KAAA,GAAQmQ,eAAA,GACV;IAAE/P,CAAA,EAAGwQ,gBAAA;IAAkBvQ,CAAA,EAAGuQ;EAAiB,IAC3C;IACExQ,CAAA,EAAGgQ,MAAA,CAAOhQ,CAAA,KAAMkQ,cAAA,CAAelQ,CAAA,GAAI,IAAIsQ,MAAA;IACvCrQ,CAAA,EAAG+P,MAAA,CAAO/P,CAAA,KAAMiQ,cAAA,CAAejQ,CAAA,GAAI,IAAIsQ;EACzC;EAEJ,IAAIP,MAAA,CAAO/P,CAAA,KAAMiQ,cAAA,CAAejQ,CAAA,EAAG;IACjCL,KAAA,CAAMK,CAAA,GAAIqP,GAAA,CAAI1P,KAAA,CAAMK,CAAC;EACvB,WAAWoP,IAAA,CAAKzP,KAAA,CAAMK,CAAC,MAAMoP,IAAA,CAAKkB,MAAM,GAAG;IACzC3Q,KAAA,CAAMK,CAAA,IAAK;EACb;EAEA,IAAI+P,MAAA,CAAOhQ,CAAA,KAAMkQ,cAAA,CAAelQ,CAAA,EAAG;IACjCJ,KAAA,CAAMI,CAAA,GAAIsP,GAAA,CAAI1P,KAAA,CAAMI,CAAC;EACvB,WAAWqP,IAAA,CAAKzP,KAAA,CAAMI,CAAC,MAAMqP,IAAA,CAAKiB,MAAM,GAAG;IACzC1Q,KAAA,CAAMI,CAAA,IAAK;EACb;EAEA,QAAQ8P,iBAAA;IACN,KAAK;MACH,OAAOW,aAAA,CAAcvJ,IAAA,EAAMnI,eAAA,CAAgBa,KAAA,CAAMA,KAAA,CAAMI,CAAA,EAAGJ,KAAA,CAAMK,CAAA,EAAGiQ,cAAc,GAAG,KAAK;IAC3F,KAAK;MACH,OAAOO,aAAA,CACLvJ,IAAA,EACAnI,eAAA,CAAgBa,KAAA,CAAMA,KAAA,CAAMI,CAAA,EAAGJ,KAAA,CAAMK,CAAA,EAAG;QACtCD,CAAA,EAAGkH,IAAA,CAAKvE,IAAA;QACR1C,CAAA,EAAGiH,IAAA,CAAKjE;MACV,CAAC,GACD,KACF;EACJ;AACF;AAEA,SAASyN,qBAAqBC,YAAA,EAAqBC,UAAA,EAAmBC,UAAA,GAAsB,MAAgB;EAC1G,IAAIA,UAAA,EAAY;IACd,OAAO;MACL7Q,CAAA,EAAGuP,IAAA,CAAIqB,UAAA,CAAW5Q,CAAA,EAAG2Q,YAAA,CAAa3Q,CAAC;MACnCC,CAAA,EAAGsP,IAAA,CAAIqB,UAAA,CAAW3Q,CAAA,EAAG0Q,YAAA,CAAa1Q,CAAC;MACnCwC,KAAA,EAAO6M,GAAA,CAAIsB,UAAA,CAAW5Q,CAAA,GAAI2Q,YAAA,CAAa3Q,CAAC;MACxC+C,MAAA,EAAQuM,GAAA,CAAIsB,UAAA,CAAW3Q,CAAA,GAAI0Q,YAAA,CAAa1Q,CAAC;IAC3C;EACF;EAEA,OAAO;IACLD,CAAA,EAAG2Q,YAAA,CAAa3Q,CAAA;IAChBC,CAAA,EAAG0Q,YAAA,CAAa1Q,CAAA;IAChBwC,KAAA,EAAOmO,UAAA,CAAW5Q,CAAA,GAAI2Q,YAAA,CAAa3Q,CAAA;IACnC+C,MAAA,EAAQ6N,UAAA,CAAW3Q,CAAA,GAAI0Q,YAAA,CAAa1Q;EACtC;AACF;AAEA,SAASwQ,cAAcvJ,IAAA,EAAY4J,SAAA,EAA4BD,UAAA,GAAa,MAAgB;EAC1F,MAAME,EAAA,GAAKD,SAAA,CAAUhR,OAAA,CAAQ;IAAEE,CAAA,EAAGkH,IAAA,CAAK1E,IAAA;IAAMvC,CAAA,EAAGiH,IAAA,CAAKpE;EAAK,CAAC;EAC3D,MAAMkO,EAAA,GAAKF,SAAA,CAAUhR,OAAA,CAAQ;IAAEE,CAAA,EAAGkH,IAAA,CAAKxE,IAAA;IAAMzC,CAAA,EAAGiH,IAAA,CAAKlE;EAAK,CAAC;EAC3D,OAAO0N,oBAAA,CAAqBK,EAAA,EAAIC,EAAA,EAAIH,UAAU;AAChD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}