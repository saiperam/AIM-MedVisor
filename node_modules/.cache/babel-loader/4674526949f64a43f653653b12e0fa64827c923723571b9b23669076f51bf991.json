{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/index.ts\nimport { proxy as proxy2, ref as ref2, snapshot as snapshot2, subscribe as subscribe2 } from \"@zag-js/store\";\n\n// ../utilities/core/src/array.ts\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\n\n// ../utilities/core/src/functions.ts\nvar runIfFn = (v, ...a) => {\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = v => v;\nvar noop = () => {};\nvar callAll = (...fns) => (...a) => {\n  fns.forEach(function (fn) {\n    fn?.(...a);\n  });\n};\nvar uuid = /* @__PURE__ */(() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\n\n// ../utilities/core/src/guard.ts\nvar isDev = () => process.env.NODE_ENV !== \"production\";\nvar isArray = v => Array.isArray(v);\nvar isObject = v => !(v == null || typeof v !== \"object\" || isArray(v));\nvar isNumber = v => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = v => typeof v === \"string\";\nvar isFunction = v => typeof v === \"function\";\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\n// ../utilities/core/src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject(obj) || obj === void 0) {\n    return obj;\n  }\n  const keys = Reflect.ownKeys(obj).filter(key => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nvar isPlainObject = value => {\n  return value && typeof value === \"object\" && value.constructor === Object;\n};\n\n// ../utilities/core/src/warning.ts\nfunction warn(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m);\n  }\n}\n\n// src/deep-merge.ts\nfunction deepMerge(source, ...objects) {\n  for (const obj of objects) {\n    const target = compact(obj);\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {};\n        }\n        deepMerge(source[key], obj[key]);\n      } else {\n        source[key] = obj[key];\n      }\n    }\n  }\n  return source;\n}\n\n// src/utils.ts\nimport { klona } from \"klona/full\";\nfunction structuredClone(v) {\n  return klona(v);\n}\nfunction toEvent(event) {\n  const obj = isString(event) ? {\n    type: event\n  } : event;\n  return obj;\n}\nfunction toArray(value) {\n  if (!value) return [];\n  return isArray(value) ? value.slice() : [value];\n}\nfunction isGuardHelper(value) {\n  return isObject(value) && value.predicate != null;\n}\n\n// src/guard-utils.ts\nvar Truthy = () => true;\nfunction exec(guardMap, ctx, event, meta) {\n  return guard => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta);\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta);\n    }\n    return guard.predicate(guardMap)(ctx, event, meta);\n  };\n}\nfunction or(...conditions) {\n  return {\n    predicate: guardMap => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)\n  };\n}\nfunction and(...conditions) {\n  return {\n    predicate: guardMap => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)\n  };\n}\nfunction not(condition) {\n  return {\n    predicate: guardMap => (ctx, event, meta) => {\n      return !exec(guardMap, ctx, event, meta)(condition);\n    }\n  };\n}\nfunction stateIn(...values) {\n  return (_ctx, _evt, meta) => meta.state.matches(...values);\n}\nvar guards = {\n  or,\n  and,\n  not,\n  stateIn\n};\nfunction choose(actions) {\n  return {\n    predicate: guardMap => (ctx, event, meta) => actions.find(def => {\n      const guard = def.guard ?? Truthy;\n      return exec(guardMap, ctx, event, meta)(guard);\n    })?.actions\n  };\n}\nfunction determineGuardFn(guard, guardMap) {\n  guard = guard ?? Truthy;\n  return (context, event, meta) => {\n    if (isString(guard)) {\n      const value = guardMap[guard];\n      return isFunction(value) ? value(context, event, meta) : value;\n    }\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta);\n    }\n    return guard?.(context, event, meta);\n  };\n}\nfunction determineActionsFn(values, guardMap) {\n  return (context, event, meta) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta);\n    }\n    return values;\n  };\n}\n\n// src/machine.ts\nimport { ref, snapshot, subscribe } from \"@zag-js/store\";\n\n// src/create-proxy.ts\nimport { proxy, proxyWithComputed } from \"@zag-js/store\";\nfunction createProxy(config) {\n  const computedContext = config.computed ?? cast({});\n  const initialContext = config.context ?? cast({});\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : [];\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast({}),\n    previousEvent: cast({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: initialTags ?? [],\n    hasTag(tag) {\n      return this.tags.includes(tag);\n    },\n    matches(...value) {\n      return value.includes(this.value);\n    },\n    can(event) {\n      return cast(this).nextEvents.includes(event);\n    },\n    get nextEvents() {\n      const stateEvents = config.states?.[this.value]?.[\"on\"] ?? {};\n      const globalEvents = config?.on ?? {};\n      return Object.keys({\n        ...stateEvents,\n        ...globalEvents\n      });\n    },\n    get changed() {\n      if (this.event.value === \"machine.init\" /* Init */ || !this.previousValue) return false;\n      return this.value !== this.previousValue;\n    }\n  });\n  return cast(state);\n}\n\n// src/delay-utils.ts\nfunction determineDelayFn(delay, delaysMap) {\n  return (context, event) => {\n    if (isNumber(delay)) return delay;\n    if (isFunction(delay)) {\n      return delay(context, event);\n    }\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay);\n      if (!Number.isNaN(value)) {\n        return value;\n      }\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay];\n        invariant(valueOrFn == null, `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``);\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn;\n      }\n    }\n  };\n}\n\n// src/transition-utils.ts\nfunction toTarget(target) {\n  return isString(target) ? {\n    target\n  } : target;\n}\nfunction determineTransitionFn(transitions, guardMap) {\n  return (context, event, meta) => {\n    return toArray(transitions).map(toTarget).find(transition => {\n      const determineGuard = determineGuardFn(transition.guard, guardMap);\n      const guard = determineGuard(context, event, meta);\n      return guard ?? transition.target ?? transition.actions;\n    });\n  };\n}\n\n// src/machine.ts\nvar Machine = class {\n  // Let's get started!\n  constructor(config, options) {\n    __publicField(this, \"status\", \"Not Started\" /* NotStarted */);\n    __publicField(this, \"state\");\n    __publicField(this, \"initialState\");\n    __publicField(this, \"initialContext\");\n    __publicField(this, \"id\");\n    __publicField(this, \"type\", \"machine\" /* Machine */);\n    // Cleanup function map (per state)\n    __publicField(this, \"activityEvents\", /* @__PURE__ */new Map());\n    __publicField(this, \"delayedEvents\", /* @__PURE__ */new Map());\n    // state update listeners the user can opt-in for\n    __publicField(this, \"stateListeners\", /* @__PURE__ */new Set());\n    __publicField(this, \"doneListeners\", /* @__PURE__ */new Set());\n    __publicField(this, \"contextWatchers\", /* @__PURE__ */new Set());\n    // Cleanup functions (for `subscribe`)\n    __publicField(this, \"removeStateListener\", noop);\n    // For Parent <==> Spawned Actor relationship\n    __publicField(this, \"parent\");\n    __publicField(this, \"children\", /* @__PURE__ */new Map());\n    // A map of guard, action, delay implementations\n    __publicField(this, \"guardMap\");\n    __publicField(this, \"actionMap\");\n    __publicField(this, \"delayMap\");\n    __publicField(this, \"activityMap\");\n    __publicField(this, \"sync\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"_created\", () => {\n      const event = toEvent(\"machine.created\" /* Created */);\n      this.executeActions(this.config?.created, event);\n    });\n    // Starts the interpreted machine.\n    __publicField(this, \"start\", init => {\n      this.state.value = \"\";\n      this.state.tags = [];\n      if (this.status === \"Running\" /* Running */) {\n        return this;\n      }\n      this.status = \"Running\" /* Running */;\n      this.removeStateListener = subscribe(this.state, () => {\n        this.stateListeners.forEach(listener => {\n          listener(this.stateSnapshot);\n        });\n      }, this.sync);\n      this.setupContextWatchers();\n      this.executeActivities(toEvent(\"machine.start\" /* Start */), toArray(this.config.activities), \"machine.start\" /* Start */);\n      this.executeActions(this.config.entry, toEvent(\"machine.start\" /* Start */));\n      const event = toEvent(\"machine.init\" /* Init */);\n      const target = isObject(init) ? init.value : init;\n      const context = isObject(init) ? init.context : void 0;\n      if (context) {\n        this.setContext(context);\n      }\n      const transition = {\n        target: target ?? this.config.initial\n      };\n      const next = this.getNextStateInfo(transition, event);\n      this.initialState = next;\n      this.performStateChangeEffects(this.state.value, next, event);\n      return this;\n    });\n    __publicField(this, \"setupContextWatchers\", () => {\n      const {\n        watch\n      } = this.config;\n      if (!watch) return;\n      let prev = snapshot(this.state.context);\n      const cleanup = subscribe(this.state.context, () => {\n        const next = snapshot(this.state.context);\n        for (const [key, fn] of Object.entries(watch)) {\n          const isEqual = this.options.compareFns?.[key] ?? Object.is;\n          if (isEqual(prev[key], next[key])) continue;\n          this.executeActions(fn, this.state.event);\n        }\n        prev = next;\n      });\n      this.contextWatchers.add(cleanup);\n    });\n    // Stops the interpreted machine\n    __publicField(this, \"stop\", () => {\n      if (this.status === \"Stopped\" /* Stopped */) return;\n      this.performExitEffects(this.state.value, toEvent(\"machine.stop\" /* Stop */));\n      this.executeActions(this.config.exit, toEvent(\"machine.stop\" /* Stop */));\n      this.setState(\"\");\n      this.setEvent(\"machine.stop\" /* Stop */);\n      this.stopStateListeners();\n      this.stopChildren();\n      this.stopActivities();\n      this.stopDelayedEvents();\n      this.stopContextWatchers();\n      this.status = \"Stopped\" /* Stopped */;\n      return this;\n    });\n    __publicField(this, \"stopStateListeners\", () => {\n      this.removeStateListener();\n      this.stateListeners.clear();\n    });\n    __publicField(this, \"stopContextWatchers\", () => {\n      this.contextWatchers.forEach(fn => fn());\n      this.contextWatchers.clear();\n    });\n    __publicField(this, \"stopDelayedEvents\", () => {\n      this.delayedEvents.forEach(state => {\n        state.forEach(stop => stop());\n      });\n      this.delayedEvents.clear();\n    });\n    // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n    __publicField(this, \"stopActivities\", state => {\n      if (state) {\n        this.activityEvents.get(state)?.forEach(stop => stop());\n        this.activityEvents.get(state)?.clear();\n        this.activityEvents.delete(state);\n      } else {\n        this.activityEvents.forEach(state2 => {\n          state2.forEach(stop => stop());\n          state2.clear();\n        });\n        this.activityEvents.clear();\n      }\n    });\n    /**\n     * Function to send event to spawned child machine or actor\n     */\n    __publicField(this, \"sendChild\", (evt, to) => {\n      const event = toEvent(evt);\n      const id = runIfFn(to, this.contextSnapshot);\n      const child = this.children.get(id);\n      if (!child) {\n        invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);\n      }\n      child.send(event);\n    });\n    /**\n     * Function to stop a running child machine or actor\n     */\n    __publicField(this, \"stopChild\", id => {\n      if (!this.children.has(id)) {\n        invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);\n      }\n      this.children.get(id).stop();\n      this.children.delete(id);\n    });\n    __publicField(this, \"removeChild\", id => {\n      this.children.delete(id);\n    });\n    // Stop and delete spawned actors\n    __publicField(this, \"stopChildren\", () => {\n      this.children.forEach(child => child.stop());\n      this.children.clear();\n    });\n    __publicField(this, \"setParent\", parent => {\n      this.parent = parent;\n    });\n    __publicField(this, \"spawn\", (src, id) => {\n      const actor = runIfFn(src);\n      if (id) actor.id = id;\n      actor.type = \"machine.actor\" /* Actor */;\n      actor.setParent(this);\n      this.children.set(actor.id, cast(actor));\n      actor.onDone(() => {\n        this.removeChild(actor.id);\n      }).start();\n      return cast(ref(actor));\n    });\n    __publicField(this, \"stopActivity\", key => {\n      if (!this.state.value) return;\n      const cleanups = this.activityEvents.get(this.state.value);\n      cleanups?.get(key)?.();\n      cleanups?.delete(key);\n    });\n    __publicField(this, \"addActivityCleanup\", (state, key, cleanup) => {\n      if (!state) return;\n      if (!this.activityEvents.has(state)) {\n        this.activityEvents.set(state, /* @__PURE__ */new Map([[key, cleanup]]));\n      } else {\n        this.activityEvents.get(state)?.set(key, cleanup);\n      }\n    });\n    __publicField(this, \"setState\", target => {\n      this.state.previousValue = this.state.value;\n      this.state.value = target;\n      const stateNode = this.getStateNode(target);\n      if (target == null) {\n        clear(this.state.tags);\n      } else {\n        this.state.tags = toArray(stateNode?.tags);\n      }\n    });\n    /**\n     * To used within side effects for React or Vue to update context\n     */\n    __publicField(this, \"setContext\", context => {\n      if (!context) return;\n      deepMerge(this.state.context, compact(context));\n    });\n    __publicField(this, \"setOptions\", options => {\n      const opts = compact(options);\n      this.actionMap = {\n        ...this.actionMap,\n        ...opts.actions\n      };\n      this.delayMap = {\n        ...this.delayMap,\n        ...opts.delays\n      };\n      this.activityMap = {\n        ...this.activityMap,\n        ...opts.activities\n      };\n      this.guardMap = {\n        ...this.guardMap,\n        ...opts.guards\n      };\n    });\n    __publicField(this, \"getStateNode\", state => {\n      if (!state) return;\n      return this.config.states?.[state];\n    });\n    __publicField(this, \"getNextStateInfo\", (transitions, event) => {\n      const transition = this.determineTransition(transitions, event);\n      const isTargetless = !transition?.target;\n      const target = transition?.target ?? this.state.value;\n      const changed = this.state.value !== target;\n      const stateNode = this.getStateNode(target);\n      const reenter = !isTargetless && !changed && !transition?.internal;\n      const info = {\n        reenter,\n        transition,\n        stateNode,\n        target,\n        changed\n      };\n      this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target);\n      return info;\n    });\n    __publicField(this, \"getAfterActions\", (transition, delay) => {\n      let id;\n      return {\n        entry: () => {\n          id = globalThis.setTimeout(() => {\n            const next = this.getNextStateInfo(transition, this.state.event);\n            this.performStateChangeEffects(this.state.value, next, this.state.event);\n          }, delay);\n        },\n        exit: () => {\n          globalThis.clearTimeout(id);\n        }\n      };\n    });\n    /**\n     * All `after` events leverage `setTimeout` and `clearTimeout`,\n     * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n     *\n     * To achieve this, we split the `after` defintion into `entry` and `exit`\n     *  functions and append them to the state's `entry` and `exit` actions\n     */\n    __publicField(this, \"getDelayedEventActions\", state => {\n      const stateNode = this.getStateNode(state);\n      const event = this.state.event;\n      if (!stateNode || !stateNode.after) return;\n      const entries = [];\n      const exits = [];\n      if (isArray(stateNode.after)) {\n        const transition = this.determineTransition(stateNode.after, event);\n        if (!transition) return;\n        if (!hasProp(transition, \"delay\")) {\n          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);\n        }\n        const determineDelay = determineDelayFn(transition.delay, this.delayMap);\n        const __delay = determineDelay(this.contextSnapshot, event);\n        const actions = this.getAfterActions(transition, __delay);\n        entries.push(actions.entry);\n        exits.push(actions.exit);\n        return {\n          entries,\n          exits\n        };\n      }\n      if (isObject(stateNode.after)) {\n        for (const delay in stateNode.after) {\n          const transition = stateNode.after[delay];\n          const determineDelay = determineDelayFn(delay, this.delayMap);\n          const __delay = determineDelay(this.contextSnapshot, event);\n          const actions = this.getAfterActions(transition, __delay);\n          entries.push(actions.entry);\n          exits.push(actions.exit);\n        }\n      }\n      return {\n        entries,\n        exits\n      };\n    });\n    /**\n     * Function to executes defined actions. It can accept actions as string\n     * (referencing `options.actions`) or actual functions.\n     */\n    __publicField(this, \"executeActions\", (actions, event) => {\n      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      for (const action of toArray(pickedActions)) {\n        const fn = isString(action) ? this.actionMap?.[action] : action;\n        warn(isString(action) && !fn, `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``);\n        fn?.(this.state.context, event, this.meta);\n      }\n    });\n    /**\n     * Function to execute running activities and registers\n     * their cleanup function internally (to be called later on when we exit the state)\n     */\n    __publicField(this, \"executeActivities\", (event, activities, state) => {\n      for (const activity of activities) {\n        const fn = isString(activity) ? this.activityMap?.[activity] : activity;\n        if (!fn) {\n          warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``);\n          continue;\n        }\n        const cleanup = fn(this.state.context, event, this.meta);\n        if (cleanup) {\n          const key = isString(activity) ? activity : activity.name || uuid();\n          this.addActivityCleanup(state ?? this.state.value, key, cleanup);\n        }\n      }\n    });\n    /**\n     * Normalizes the `every` definition to transition. `every` can be:\n     * - An array of possible actions to run (we need to pick the first match based on guard)\n     * - An object of intervals and actions\n     */\n    __publicField(this, \"createEveryActivities\", (every, callbackfn) => {\n      if (!every) return;\n      if (isArray(every)) {\n        const picked = toArray(every).find(transition => {\n          const delayOrFn = transition.delay;\n          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);\n          const delay2 = determineDelay2(this.contextSnapshot, this.state.event);\n          const determineGuard = determineGuardFn(transition.guard, this.guardMap);\n          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);\n          return guard ?? delay2 != null;\n        });\n        if (!picked) return;\n        const determineDelay = determineDelayFn(picked.delay, this.delayMap);\n        const delay = determineDelay(this.contextSnapshot, this.state.event);\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(picked.actions, this.state.event);\n          }, delay);\n          return () => {\n            globalThis.clearInterval(id);\n          };\n        };\n        callbackfn(activity);\n      } else {\n        for (const interval in every) {\n          const actions = every?.[interval];\n          const determineDelay = determineDelayFn(interval, this.delayMap);\n          const delay = determineDelay(this.contextSnapshot, this.state.event);\n          const activity = () => {\n            const id = globalThis.setInterval(() => {\n              this.executeActions(actions, this.state.event);\n            }, delay);\n            return () => {\n              globalThis.clearInterval(id);\n            };\n          };\n          callbackfn(activity);\n        }\n      }\n    });\n    __publicField(this, \"setEvent\", event => {\n      this.state.previousEvent = this.state.event;\n      this.state.event = ref(toEvent(event));\n    });\n    __publicField(this, \"performExitEffects\", (current, event) => {\n      const currentState = this.state.value;\n      if (currentState === \"\") return;\n      const stateNode = current ? this.getStateNode(current) : void 0;\n      this.stopActivities(currentState);\n      const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      const exitActions = toArray(_exit);\n      const afterExitActions = this.delayedEvents.get(currentState);\n      if (afterExitActions) {\n        exitActions.push(...afterExitActions);\n      }\n      this.executeActions(exitActions, event);\n    });\n    __publicField(this, \"performEntryEffects\", (next, event) => {\n      const stateNode = this.getStateNode(next);\n      const activities = toArray(stateNode?.activities);\n      this.createEveryActivities(stateNode?.every, activity => {\n        activities.unshift(activity);\n      });\n      if (activities.length > 0) {\n        this.executeActivities(event, activities);\n      }\n      const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(this.contextSnapshot, event, this.guardMeta);\n      const entryActions = toArray(pickedActions);\n      const afterActions = this.getDelayedEventActions(next);\n      if (stateNode?.after && afterActions) {\n        this.delayedEvents.set(next, afterActions?.exits);\n        entryActions.push(...afterActions.entries);\n      }\n      this.executeActions(entryActions, event);\n      if (stateNode?.type === \"final\") {\n        this.state.done = true;\n        this.doneListeners.forEach(listener => {\n          listener(this.stateSnapshot);\n        });\n        this.stop();\n      }\n    });\n    __publicField(this, \"performTransitionEffects\", (transitions, event) => {\n      const transition = this.determineTransition(transitions, event);\n      this.executeActions(transition?.actions, event);\n    });\n    /**\n     * Performs all the requires side-effects or reactions when\n     * we move from state A => state B.\n     *\n     * The Effect order:\n     * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n     */\n    __publicField(this, \"performStateChangeEffects\", (current, next, event) => {\n      this.setEvent(event);\n      const changed = next.changed || next.reenter;\n      if (changed) {\n        this.performExitEffects(current, event);\n      }\n      this.performTransitionEffects(next.transition, event);\n      this.setState(next.target);\n      if (changed) {\n        this.performEntryEffects(next.target, event);\n      }\n    });\n    __publicField(this, \"determineTransition\", (transition, event) => {\n      const fn = determineTransitionFn(transition, this.guardMap);\n      return fn?.(this.contextSnapshot, event, this.guardMeta);\n    });\n    /**\n     * Function to send event to parent machine from spawned child\n     */\n    __publicField(this, \"sendParent\", evt => {\n      if (!this.parent) {\n        invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\");\n      }\n      const event = toEvent(evt);\n      this.parent?.send(event);\n    });\n    __publicField(this, \"log\", (...args) => {\n      if (isDev() && this.options.debug) {\n        console.log(...args);\n      }\n    });\n    /**\n     * Function to send an event to current machine\n     */\n    __publicField(this, \"send\", evt => {\n      const event = toEvent(evt);\n      this.transition(this.state.value, event);\n    });\n    __publicField(this, \"transition\", (state, evt) => {\n      const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode;\n      const event = toEvent(evt);\n      if (!stateNode && !this.config.on) {\n        const msg = this.status === \"Stopped\" /* Stopped */ ? \"[@zag-js/core > transition] Cannot transition a stopped machine\" : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`;\n        warn(msg);\n        return;\n      }\n      const transitions =\n      // @ts-expect-error - Fix this\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type];\n      const next = this.getNextStateInfo(transitions, event);\n      this.performStateChangeEffects(this.state.value, next, event);\n      return next.stateNode;\n    });\n    __publicField(this, \"subscribe\", listener => {\n      this.stateListeners.add(listener);\n      if (this.status === \"Running\" /* Running */) {\n        listener(this.stateSnapshot);\n      }\n      return () => {\n        this.stateListeners.delete(listener);\n      };\n    });\n    __publicField(this, \"onDone\", listener => {\n      this.doneListeners.add(listener);\n      return this;\n    });\n    __publicField(this, \"onTransition\", listener => {\n      this.stateListeners.add(listener);\n      if (this.status === \"Running\" /* Running */) {\n        listener(this.stateSnapshot);\n      }\n      return this;\n    });\n    this.config = structuredClone(config);\n    this.options = structuredClone(options ?? {});\n    this.id = this.config.id ?? `machine-${uuid()}`;\n    this.guardMap = this.options?.guards ?? {};\n    this.actionMap = this.options?.actions ?? {};\n    this.delayMap = this.options?.delays ?? {};\n    this.activityMap = this.options?.activities ?? {};\n    this.sync = this.options?.sync ?? false;\n    this.state = createProxy(this.config);\n    this.initialContext = snapshot(this.state.context);\n  }\n  // immutable state value\n  get stateSnapshot() {\n    return cast(snapshot(this.state));\n  }\n  getState() {\n    return this.stateSnapshot;\n  }\n  // immutable context value\n  get contextSnapshot() {\n    return this.stateSnapshot.context;\n  }\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  get self() {\n    const self = this;\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this),\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot;\n      },\n      get initialContext() {\n        return self.initialContext;\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\";\n      }\n    };\n  }\n  get meta() {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: key => this.actionMap[key],\n      getGuard: key => this.guardMap[key]\n    };\n  }\n  get guardMeta() {\n    return {\n      state: this.stateSnapshot\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return \"Machine\";\n  }\n  getHydrationState() {\n    const state = this.getState();\n    return {\n      value: state.value,\n      tags: state.tags\n    };\n  }\n};\nvar createMachine = (config, options) => new Machine(config, options);\nvar isMachine = value => {\n  return value instanceof Machine || value?.type === \"machine\" /* Machine */;\n};\n\n// src/merge-props.ts\nvar clsx = (...args) => args.map(str => str?.trim?.()).filter(Boolean).join(\" \");\nvar CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g;\nvar serialize = style => {\n  const res = {};\n  let match;\n  while (match = CSS_REGEX.exec(style)) {\n    res[match[1]] = match[2];\n  }\n  return res;\n};\nvar css = (a, b) => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`;\n    a = serialize(a);\n  } else if (isString(b)) {\n    b = serialize(b);\n  }\n  return Object.assign({}, a ?? {}, b ?? {});\n};\nfunction mergeProps(...args) {\n  let result = {};\n  for (let props of args) {\n    for (let key in result) {\n      if (key.startsWith(\"on\") && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key]);\n        continue;\n      }\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key]);\n        continue;\n      }\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key]);\n        continue;\n      }\n      result[key] = props[key] !== void 0 ? props[key] : result[key];\n    }\n    for (let key in props) {\n      if (result[key] === void 0) {\n        result[key] = props[key];\n      }\n    }\n  }\n  return result;\n}\nexport { Machine, choose, createMachine, deepMerge, guards, isMachine, mergeProps, proxy2 as proxy, ref2 as ref, snapshot2 as snapshot, subscribe2 as subscribe };","map":{"version":3,"names":["proxy","proxy2","ref","ref2","snapshot","snapshot2","subscribe","subscribe2","clear","v","length","pop","runIfFn","a","res","cast","noop","callAll","fns","forEach","fn","uuid","id","toString","isDev","process","env","NODE_ENV","isArray","Array","isObject","isNumber","Number","isNaN","isString","isFunction","hasProp","obj","prop","Object","prototype","hasOwnProperty","call","compact","isPlainObject","keys","Reflect","ownKeys","filter","key","filtered","value","constructor","warn","m","c","console","invariant","Error","deepMerge","source","objects","target","klona","structuredClone","toEvent","event","type","toArray","slice","isGuardHelper","predicate","Truthy","exec","guardMap","ctx","meta","guard","or","conditions","map","some","Boolean","and","every","not","condition","stateIn","values","_ctx","_evt","state","matches","guards","choose","actions","find","def","determineGuardFn","context","determineActionsFn","proxyWithComputed","createProxy","config","computedContext","computed","initialContext","initialTags","initial","states","tags","previousValue","previousEvent","done","hasTag","tag","includes","can","nextEvents","stateEvents","globalEvents","on","changed","determineDelayFn","delay","delaysMap","parseFloat","valueOrFn","toTarget","determineTransitionFn","transitions","transition","determineGuard","Machine","options","__publicField","Map","Set","executeActions","created","init","status","removeStateListener","stateListeners","listener","stateSnapshot","sync","setupContextWatchers","executeActivities","activities","entry","setContext","next","getNextStateInfo","initialState","performStateChangeEffects","watch","prev","cleanup","entries","isEqual","compareFns","is","contextWatchers","add","performExitEffects","exit","setState","setEvent","stopStateListeners","stopChildren","stopActivities","stopDelayedEvents","stopContextWatchers","delayedEvents","stop","activityEvents","get","delete","state2","evt","to","contextSnapshot","child","children","send","has","parent","src","actor","setParent","set","onDone","removeChild","start","cleanups","stateNode","getStateNode","opts","actionMap","delayMap","delays","activityMap","determineTransition","isTargetless","reenter","internal","info","log","globalThis","setTimeout","clearTimeout","after","exits","JSON","stringify","determineDelay","__delay","getAfterActions","push","pickedActions","guardMeta","action","activity","name","addActivityCleanup","callbackfn","picked","delayOrFn","determineDelay2","delay2","setInterval","clearInterval","interval","current","currentState","_exit","exitActions","afterExitActions","createEveryActivities","unshift","entryActions","afterActions","getDelayedEventActions","doneListeners","performTransitionEffects","performEntryEffects","args","debug","msg","getState","self","bind","sendParent","sendChild","stopChild","spawn","stopActivity","getAction","getGuard","Symbol","toStringTag","getHydrationState","createMachine","isMachine","clsx","str","trim","join","CSS_REGEX","serialize","style","match","css","b","assign","mergeProps","result","props","startsWith"],"sources":["/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/index.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/utilities/core/src/array.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/utilities/core/src/functions.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/utilities/core/src/guard.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/utilities/core/src/object.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/utilities/core/src/warning.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/deep-merge.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/guard-utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/machine.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/create-proxy.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/delay-utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/transition-utils.ts","/Users/rishil/AIM-MedVisor/node_modules/@zag-js/date-picker/node_modules/@zag-js/core/src/merge-props.ts"],"sourcesContent":["export { proxy, ref, snapshot, subscribe, type Ref } from \"@zag-js/store\"\nexport { deepMerge } from \"./deep-merge\"\nexport { choose, guards } from \"./guard-utils\"\nexport * from \"./machine\"\nexport { mergeProps } from \"./merge-props\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"./type-utils\"\nexport type { StateMachine } from \"./types\"\n","export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const uniq = <T>(v: T[]): T[] => Array.from(new Set(v))\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n","export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n","export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n","import { createSplitProps } from \"./split-props\"\n\nexport function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const filtered: Partial<T> = {}\n\n  for (const key of keys) {\n    const value = obj[key]\n    if (value !== undefined) {\n      filtered[key] = value\n    }\n  }\n\n  return filtered as any\n}\n\nexport function omit<T extends Record<string, any>>(obj: T, keys: string[]) {\n  return createSplitProps(keys)(obj)[1]\n}\n","export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n","import { compact, isObject } from \"@zag-js/utils\"\n\nexport function deepMerge<T extends Record<string, any>>(source: T, ...objects: T[]): T {\n  for (const obj of objects) {\n    const target = compact(obj)\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {} as any\n        }\n        deepMerge(source[key], obj[key])\n      } else {\n        source[key] = obj[key]\n      }\n    }\n  }\n  return source\n}\n","import { isArray, isObject, isString } from \"@zag-js/utils\"\nimport { klona } from \"klona/full\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\nexport function structuredClone<T>(v: T): T {\n  return klona(v)\n}\n\nexport function toEvent<T extends S.EventObject>(event: S.Event<T>): T {\n  const obj = isString(event) ? { type: event } : event\n  return obj as T\n}\n\nexport function toArray<T>(value: T | T[] | undefined): T[] {\n  if (!value) return []\n  return isArray(value) ? value.slice() : [value]\n}\n\nexport function isGuardHelper(value: any): value is { predicate: (guards: Dict) => any } {\n  return isObject(value) && value.predicate != null\n}\n","import { isFunction, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { isGuardHelper } from \"./utils\"\n\nconst Truthy = () => true\n\n/* -----------------------------------------------------------------------------\n * The following functions are used to determine a guard's truthiness\n * -----------------------------------------------------------------------------*/\n\nfunction exec<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guardMap: Dict,\n  ctx: TContext,\n  event: TEvent,\n  meta: S.GuardMeta<TContext, TState, TEvent>,\n) {\n  return (guard: S.Guard<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta)\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta)\n    }\n    return guard.predicate(guardMap)(ctx, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Guard helpers (for combining guards)\n * -----------------------------------------------------------------------------*/\n\nfunction or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean),\n  }\n}\n\nfunction and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean),\n  }\n}\n\nfunction not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  condition: S.Guard<TContext, TState, TEvent>,\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n      return !exec(guardMap, ctx, event, meta)(condition)\n    },\n  }\n}\n\nfunction stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...values: TState[\"value\"][]\n): S.GuardExpression<TContext, TState, TEvent> {\n  return (_ctx, _evt, meta) => meta.state.matches(...values)\n}\n\nexport const guards = { or, and, not, stateIn }\n\n/* -----------------------------------------------------------------------------\n * Action guard helper. Used to determie the action to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function choose<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  actions: Array<{ guard?: S.Guard<TContext, TState, TEvent>; actions: S.PureActions<TContext, TState, TEvent> }>,\n): S.ChooseHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      actions.find((def) => {\n        const guard = def.guard ?? Truthy\n        return exec(guardMap, ctx, event, meta)(guard)\n      })?.actions,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the guard to be used\n * -----------------------------------------------------------------------------*/\n\nexport function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guard: S.Guard<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  guard = guard ?? Truthy\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      const value = guardMap[guard]\n      return isFunction(value) ? value(context, event, meta) : value\n    }\n\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta)\n    }\n\n    return guard?.(context, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the actions to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  values: S.Actions<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta)\n    }\n    return values\n  }\n}\n","import { ref, snapshot, subscribe } from \"@zag-js/store\"\nimport {\n  cast,\n  clear,\n  compact,\n  hasProp,\n  invariant,\n  isArray,\n  isDev,\n  isObject,\n  isString,\n  noop,\n  runIfFn,\n  uuid,\n  warn,\n} from \"@zag-js/utils\"\nimport { createProxy } from \"./create-proxy\"\nimport { deepMerge } from \"./deep-merge\"\nimport { determineDelayFn } from \"./delay-utils\"\nimport { determineActionsFn, determineGuardFn } from \"./guard-utils\"\nimport { determineTransitionFn } from \"./transition-utils\"\nimport {\n  ActionTypes,\n  MachineStatus,\n  MachineType,\n  type Dict,\n  type StateMachine as S,\n  type VoidFunction,\n  type Writable,\n} from \"./types\"\nimport { structuredClone, toArray, toEvent } from \"./utils\"\n\nexport class Machine<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> {\n  public status: MachineStatus = MachineStatus.NotStarted\n  public readonly state: S.State<TContext, TState, TEvent>\n\n  public initialState: S.StateInfo<TContext, TState, TEvent> | undefined\n  public initialContext: TContext\n\n  public id: string\n\n  public type: MachineType = MachineType.Machine\n\n  // Cleanup function map (per state)\n  private activityEvents = new Map<string, Map<string, VoidFunction>>()\n  private delayedEvents = new Map<string, VoidFunction[]>()\n\n  // state update listeners the user can opt-in for\n  private stateListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private doneListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextWatchers = new Set<VoidFunction>()\n\n  // Cleanup functions (for `subscribe`)\n  private removeStateListener: VoidFunction = noop\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: AnyMachine\n  private children = new Map<string, AnyMachine>()\n\n  // A map of guard, action, delay implementations\n  private guardMap: S.GuardMap<TContext, TState, TEvent>\n  private actionMap: S.ActionMap<TContext, TState, TEvent>\n  private delayMap: S.DelayMap<TContext, TEvent>\n  private activityMap: S.ActivityMap<TContext, TState, TEvent>\n  private sync: boolean\n  public options: S.MachineOptions<TContext, TState, TEvent>\n  public config: S.MachineConfig<TContext, TState, TEvent>\n\n  // Let's get started!\n  constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>) {\n    // clone the config and options\n    this.config = structuredClone(config)\n    this.options = structuredClone(options ?? {})\n\n    this.id = this.config.id ?? `machine-${uuid()}`\n\n    // maps\n    this.guardMap = this.options?.guards ?? {}\n    this.actionMap = this.options?.actions ?? {}\n    this.delayMap = this.options?.delays ?? {}\n    this.activityMap = this.options?.activities ?? {}\n    this.sync = this.options?.sync ?? false\n\n    // create mutatable state\n    this.state = createProxy(this.config)\n\n    this.initialContext = snapshot(this.state.context)\n  }\n\n  // immutable state value\n  private get stateSnapshot(): S.State<TContext, TState, TEvent> {\n    return cast(snapshot(this.state))\n  }\n\n  public getState(): S.State<TContext, TState, TEvent> {\n    return this.stateSnapshot\n  }\n\n  // immutable context value\n  public get contextSnapshot(): TContext {\n    return this.stateSnapshot.context\n  }\n\n  public _created = () => {\n    // created actions\n    const event = toEvent<TEvent>(ActionTypes.Created)\n    this.executeActions(this.config?.created, event)\n  }\n\n  // Starts the interpreted machine.\n  public start = (init?: S.StateInit<TContext, TState>) => {\n    // reset state back to empty (for SSR, we had to set state.value to initial value)\n    this.state.value = \"\"\n    this.state.tags = []\n\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) {\n      return this\n    }\n\n    this.status = MachineStatus.Running\n\n    // subscribe to state changes\n    this.removeStateListener = subscribe(\n      this.state,\n      () => {\n        this.stateListeners.forEach((listener) => {\n          listener(this.stateSnapshot)\n        })\n      },\n      this.sync,\n    )\n\n    this.setupContextWatchers()\n\n    // execute initial actions and activities\n    this.executeActivities(toEvent<TEvent>(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start)\n    this.executeActions(this.config.entry, toEvent<TEvent>(ActionTypes.Start))\n\n    // start transition\n    const event = toEvent<TEvent>(ActionTypes.Init)\n\n    const target = isObject(init) ? init.value : init\n    const context = isObject(init) ? init.context : undefined\n\n    if (context) {\n      this.setContext(context as Partial<TContext>)\n    }\n\n    // start transition definition\n    const transition = {\n      target: target ?? this.config.initial,\n    }\n\n    const next = this.getNextStateInfo(transition, event)\n    this.initialState = next\n\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return this\n  }\n\n  private setupContextWatchers = () => {\n    const { watch } = this.config\n    if (!watch) return\n\n    let prev = snapshot(this.state.context)\n\n    const cleanup = subscribe(this.state.context, () => {\n      const next = snapshot(this.state.context)\n\n      for (const [key, fn] of Object.entries(watch)) {\n        const isEqual = this.options.compareFns?.[key] ?? Object.is\n        if (isEqual(prev[key], next[key])) continue\n        this.executeActions(fn, this.state.event as TEvent)\n      }\n\n      prev = next\n    })\n\n    this.contextWatchers.add(cleanup)\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    // exit current state\n    this.performExitEffects(this.state.value!, toEvent<TEvent>(ActionTypes.Stop))\n\n    // execute root stop or exit actions\n    this.executeActions(this.config.exit, toEvent<TEvent>(ActionTypes.Stop))\n\n    this.setState(\"\")\n    this.setEvent(ActionTypes.Stop)\n\n    // cleanups\n    this.stopStateListeners()\n    this.stopChildren()\n    this.stopActivities()\n    this.stopDelayedEvents()\n    this.stopContextWatchers()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopStateListeners = () => {\n    this.removeStateListener()\n    this.stateListeners.clear()\n  }\n\n  private stopContextWatchers = () => {\n    this.contextWatchers.forEach((fn) => fn())\n    this.contextWatchers.clear()\n  }\n\n  private stopDelayedEvents = () => {\n    this.delayedEvents.forEach((state) => {\n      state.forEach((stop) => stop())\n    })\n    this.delayedEvents.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (state?: TState[\"value\"]) => {\n    // stop activities for a state\n    if (state) {\n      this.activityEvents.get(state)?.forEach((stop) => stop())\n      this.activityEvents.get(state)?.clear()\n      this.activityEvents.delete(state)\n    } else {\n      // stop every running activity\n      this.activityEvents.forEach((state) => {\n        state.forEach((stop) => stop())\n        state.clear()\n      })\n      this.activityEvents.clear()\n    }\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  public sendChild = (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = runIfFn(to, this.contextSnapshot)\n    const child = this.children.get(id)\n    if (!child) {\n      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`)\n    }\n    child!.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  public stopChild = (id: string) => {\n    if (!this.children.has(id)) {\n      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`)\n    }\n    this.children.get(id)!.stop()\n    this.children.delete(id)\n  }\n\n  public removeChild = (id: string) => {\n    this.children.delete(id)\n  }\n\n  // Stop and delete spawned actors\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  public spawn = <TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(\n    src: MachineSrc<TContext, TState, TEvent>,\n    id?: string,\n  ) => {\n    const actor = runIfFn(src)\n    if (id) actor.id = id\n    actor.type = MachineType.Actor\n    actor.setParent(this)\n    this.children.set(actor.id, cast(actor))\n\n    actor\n      .onDone(() => {\n        this.removeChild(actor.id)\n      })\n      .start()\n\n    return cast<typeof actor>(ref(actor))\n  }\n\n  private stopActivity = (key: string) => {\n    if (!this.state.value) return\n    const cleanups = this.activityEvents.get(this.state.value)\n    cleanups?.get(key)?.() // cleanup\n    cleanups?.delete(key) // remove from map\n  }\n\n  private addActivityCleanup = (state: TState[\"value\"] | null, key: string, cleanup: VoidFunction) => {\n    if (!state) return\n    if (!this.activityEvents.has(state)) {\n      this.activityEvents.set(state, new Map([[key, cleanup]]))\n    } else {\n      this.activityEvents.get(state)?.set(key, cleanup)\n    }\n  }\n\n  private setState = (target: TState[\"value\"] | null) => {\n    this.state.previousValue = this.state.value\n    this.state.value = target\n\n    const stateNode = this.getStateNode(target)\n\n    if (target == null) {\n      // remove all tags\n      clear(this.state.tags)\n    } else {\n      this.state.tags = toArray(stateNode?.tags)\n    }\n  }\n\n  /**\n   * To used within side effects for React or Vue to update context\n   */\n  public setContext = (context: Partial<Writable<TContext>> | undefined) => {\n    if (!context) return\n    deepMerge(this.state.context, compact(context))\n  }\n\n  public setOptions = (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => {\n    const opts = compact(options)\n    this.actionMap = { ...this.actionMap, ...opts.actions }\n    this.delayMap = { ...this.delayMap, ...opts.delays }\n    this.activityMap = { ...this.activityMap, ...opts.activities }\n    this.guardMap = { ...this.guardMap, ...opts.guards }\n  }\n\n  private getStateNode = (state: TState[\"value\"] | null) => {\n    if (!state) return\n    return this.config.states?.[state]\n  }\n\n  private getNextStateInfo = (\n    transitions: S.Transitions<TContext, TState, TEvent>,\n    event: TEvent,\n  ): S.StateInfo<TContext, TState, TEvent> => {\n    // pick transition\n    const transition = this.determineTransition(transitions, event)\n\n    const isTargetless = !transition?.target\n    const target = transition?.target ?? this.state.value\n    const changed = this.state.value !== target\n\n    const stateNode = this.getStateNode(target)\n    const reenter = !isTargetless && !changed && !transition?.internal\n\n    const info = {\n      reenter,\n      transition,\n      stateNode,\n      target: target!,\n      changed,\n    }\n\n    this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target)\n\n    return info\n  }\n\n  private getAfterActions = (transition: S.Transitions<TContext, TState, TEvent>, delay?: number) => {\n    let id: ReturnType<typeof globalThis.setTimeout>\n\n    return {\n      entry: () => {\n        id = globalThis.setTimeout(() => {\n          const next = this.getNextStateInfo(transition, this.state.event)\n          this.performStateChangeEffects(this.state.value!, next, this.state.event)\n        }, delay)\n      },\n      exit: () => {\n        globalThis.clearTimeout(id)\n      },\n    }\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the `after` defintion into `entry` and `exit`\n   *  functions and append them to the state's `entry` and `exit` actions\n   */\n  private getDelayedEventActions = (state: TState[\"value\"]) => {\n    const stateNode = this.getStateNode(state)\n    const event = this.state.event\n\n    if (!stateNode || !stateNode.after) return\n\n    const entries: VoidFunction[] = []\n    const exits: VoidFunction[] = []\n\n    if (isArray(stateNode.after)) {\n      //\n      const transition = this.determineTransition(stateNode.after, event)\n\n      if (!transition) return\n\n      if (!hasProp(transition, \"delay\")) {\n        throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`)\n      }\n\n      const determineDelay = determineDelayFn((transition as any).delay, this.delayMap)\n      const __delay = determineDelay(this.contextSnapshot, event)\n\n      const actions = this.getAfterActions(transition, __delay)\n\n      entries.push(actions.entry)\n      exits.push(actions.exit)\n\n      return { entries, exits }\n    }\n\n    if (isObject(stateNode.after)) {\n      //\n      for (const delay in stateNode.after) {\n        const transition = stateNode.after[delay]\n\n        const determineDelay = determineDelayFn(delay, this.delayMap)\n        const __delay = determineDelay(this.contextSnapshot, event)\n\n        const actions = this.getAfterActions(transition, __delay)\n\n        entries.push(actions.entry)\n        exits.push(actions.exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  private get self(): S.Self<TContext, TState, TEvent> {\n    const self = this\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this) as any,\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot\n      },\n      get initialContext() {\n        return self.initialContext\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\"\n      },\n    }\n  }\n\n  private get meta(): S.Meta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key],\n    }\n  }\n\n  private get guardMeta(): S.GuardMeta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n    }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actions`) or actual functions.\n   */\n  private executeActions = (actions: S.Actions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    for (const action of toArray(pickedActions)) {\n      const fn = isString(action) ? this.actionMap?.[action] : action\n      warn(\n        isString(action) && !fn,\n        `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``,\n      )\n      fn?.(this.state.context, event, this.meta)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: Array<S.Activity<TContext, TState, TEvent>>,\n    state?: TState[\"value\"],\n  ) => {\n    for (const activity of activities) {\n      const fn = isString(activity) ? this.activityMap?.[activity] : activity\n\n      if (!fn) {\n        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``)\n        continue\n      }\n\n      const cleanup = fn(this.state.context, event, this.meta)\n\n      if (cleanup) {\n        const key = isString(activity) ? activity : activity.name || uuid()\n        this.addActivityCleanup(state ?? this.state.value, key, cleanup)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to transition. `every` can be:\n   * - An array of possible actions to run (we need to pick the first match based on guard)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"] | undefined,\n    callbackfn: (activity: S.Activity<TContext, TState, TEvent>) => void,\n  ) => {\n    if (!every) return\n\n    // every: [{ interval: 2000, actions: [...], guard: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], guard: ... }\n      const picked = toArray(every).find((transition) => {\n        //\n        const delayOrFn = transition.delay\n        const determineDelay = determineDelayFn(delayOrFn, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        const determineGuard = determineGuardFn(transition.guard, this.guardMap)\n        const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta)\n\n        return guard ?? delay != null\n      })\n\n      if (!picked) return\n\n      const determineDelay = determineDelayFn(picked.delay, this.delayMap)\n      const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n      const activity = () => {\n        const id = globalThis.setInterval(() => {\n          this.executeActions(picked.actions, this.state.event)\n        }, delay)\n        return () => {\n          globalThis.clearInterval(id)\n        }\n      }\n      callbackfn(activity)\n      //\n    } else {\n      // every = { 1000: [fn, fn] }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const determineDelay = determineDelayFn(interval, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        // create the activity to run for each `every` reaction\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(actions, this.state.event)\n          }, delay)\n          return () => {\n            globalThis.clearInterval(id)\n          }\n        }\n        callbackfn(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent | TEvent[\"type\"]) => {\n    this.state.previousEvent = this.state.event\n    this.state.event = ref(toEvent(event))\n  }\n\n  private performExitEffects = (current: TState[\"value\"] | undefined, event: TEvent) => {\n    const currentState = this.state.value!\n\n    // don't clean up root state, it'll get cleaned up on stop()\n    if (currentState === \"\") return\n\n    const stateNode = current ? this.getStateNode(current) : undefined\n\n    // cleanup activities for current state\n    this.stopActivities(currentState)\n\n    // get explicit exit and implicit \"after.exit\" actions for current state\n    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    const exitActions = toArray(_exit)\n\n    const afterExitActions = this.delayedEvents.get(currentState)\n\n    if (afterExitActions) {\n      exitActions.push(...afterExitActions)\n    }\n\n    // call all exit actions for current state\n    this.executeActions(exitActions, event)\n  }\n\n  private performEntryEffects = (next: TState[\"value\"], event: TEvent) => {\n    const stateNode = this.getStateNode(next)\n\n    // execute activities for next state\n    const activities = toArray(stateNode?.activities)\n\n    // if `every` is defined, create an activity and append to activities\n    this.createEveryActivities(stateNode?.every, (activity) => {\n      activities.unshift(activity)\n    })\n\n    if (activities.length > 0) {\n      this.executeActivities(event, activities)\n    }\n\n    // get all entry actions\n    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n      this.contextSnapshot,\n      event,\n      this.guardMeta,\n    )\n    const entryActions = toArray(pickedActions)\n    const afterActions = this.getDelayedEventActions(next)\n\n    if (stateNode?.after && afterActions) {\n      this.delayedEvents.set(next, afterActions?.exits)\n      entryActions.push(...afterActions.entries)\n    }\n\n    // execute entry actions for next state\n    this.executeActions(entryActions, event)\n\n    if (stateNode?.type === \"final\") {\n      this.state.done = true\n      this.doneListeners.forEach((listener) => {\n        listener(this.stateSnapshot)\n      })\n      this.stop()\n    }\n  }\n\n  private performTransitionEffects = (\n    transitions: S.Transitions<TContext, TState, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    // execute transition actions\n    const transition = this.determineTransition(transitions, event)\n    this.executeActions(transition?.actions, event)\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performStateChangeEffects = (\n    current: TState[\"value\"] | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    // update event\n    this.setEvent(event)\n\n    const changed = next.changed || next.reenter\n\n    if (changed) {\n      this.performExitEffects(current, event)\n    }\n\n    // execute transition actions\n    this.performTransitionEffects(next.transition, event)\n\n    // go to next state\n    this.setState(next.target)\n\n    if (changed) {\n      this.performEntryEffects(next.target, event)\n    }\n  }\n\n  private determineTransition = (transition: S.Transitions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const fn = determineTransitionFn(transition, this.guardMap)\n    return fn?.(this.contextSnapshot, event, this.guardMeta)\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  public sendParent = (evt: S.Event<S.AnyEventObject>) => {\n    if (!this.parent) {\n      invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\")\n    }\n    const event = toEvent<S.AnyEventObject>(evt)\n    this.parent?.send(event)\n  }\n\n  private log = (...args: any[]) => {\n    if (isDev() && this.options.debug) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  public send = (evt: S.Event<TEvent>) => {\n    const event = toEvent<TEvent>(evt)\n    this.transition(this.state.value, event)\n  }\n\n  public transition = (state: TState[\"value\"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => {\n    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode\n\n    const event = toEvent(evt)\n\n    if (!stateNode && !this.config.on) {\n      const msg =\n        this.status === MachineStatus.Stopped\n          ? \"[@zag-js/core > transition] Cannot transition a stopped machine\"\n          : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`\n      warn(msg)\n      return\n    }\n\n    const transitions: S.Transitions<TContext, TState, TEvent> =\n      // @ts-expect-error - Fix this\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const next = this.getNextStateInfo(transitions, event)\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return next.stateNode\n  }\n\n  subscribe = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n\n    return () => {\n      this.stateListeners.delete(listener)\n    }\n  }\n\n  public onDone = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.doneListeners.add(listener)\n    return this\n  }\n\n  public onTransition = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n    return this\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Machine\"\n  }\n\n  public getHydrationState(): S.StateInit<TContext, TState> {\n    const state = this.getState()\n    return {\n      value: state.value,\n      tags: state.tags,\n    }\n  }\n}\n\nexport type MachineSrc<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>)\n\nexport type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>\n\nexport const createMachine = <\n  TContext extends Dict,\n  TState extends S.StateSchema = S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n  options?: S.MachineOptions<TContext, TState, TEvent>,\n) => new Machine(config, options)\n\nexport const isMachine = (value: any): value is AnyMachine => {\n  return value instanceof Machine || value?.type === MachineType.Machine\n}\n","import { proxy, proxyWithComputed } from \"@zag-js/store\"\nimport { cast } from \"@zag-js/utils\"\nimport { ActionTypes, type Dict, type StateMachine as S } from \"./types\"\n\nexport function createProxy<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n) {\n  const computedContext: Dict = config.computed ?? cast<S.TComputedContext<TContext>>({})\n  const initialContext = config.context ?? cast<TContext>({})\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : []\n\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast<Dict>({}),\n    previousEvent: cast<Dict>({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: (initialTags ?? []) as Array<TState[\"tags\"]>,\n    hasTag(tag: TState[\"tags\"]): boolean {\n      return this.tags.includes(tag)\n    },\n    matches(...value: string[]): boolean {\n      return value.includes(this.value)\n    },\n    can(event: string): boolean {\n      return cast<any>(this).nextEvents.includes(event)\n    },\n    get nextEvents() {\n      const stateEvents = (config.states as Dict)?.[this.value]?.[\"on\"] ?? {}\n      const globalEvents = config?.on ?? {}\n      return Object.keys({ ...stateEvents, ...globalEvents })\n    },\n    get changed() {\n      if (this.event.value === ActionTypes.Init || !this.previousValue) return false\n      return this.value !== this.previousValue\n    },\n  })\n\n  return cast<S.State<TContext, TState, TEvent>>(state)\n}\n","import { invariant, isFunction, isNumber, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\n/**\n * Delay can be specified as:\n * - a string (reference to `options.delays`)\n * - a number (in ms)\n * - a function that returns a number (in ms)\n *\n * Let's resolve this to a number\n */\nexport function determineDelayFn<TContext extends Dict, TEvent extends S.EventObject>(\n  delay: S.Delay<TContext, TEvent> | undefined,\n  delaysMap: S.DelayMap<TContext, TEvent> | undefined,\n) {\n  return (context: TContext, event: TEvent) => {\n    if (isNumber(delay)) return delay\n\n    if (isFunction(delay)) {\n      return delay(context, event)\n    }\n\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay)\n\n      if (!Number.isNaN(value)) {\n        return value\n      }\n\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay]\n\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``,\n        )\n\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn\n      }\n    }\n  }\n}\n","import { isString } from \"@zag-js/utils\"\nimport { determineGuardFn } from \"./guard-utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { toArray } from \"./utils\"\n\n/**\n * A transition is an object that describes the next state, or/and actions\n * that should run when an event is sent.\n *\n * Transitions can be specified as:\n * - A single string: \"spinning\"\n * - An object with `target`, `actions`, or `guard`: { target: \"spinning\", actions: [...], guard: isValid }\n * - An array of possible transitions. In this case, we'll pick the first matching transition\n * depending on the `guard` specified\n */\n\nexport function toTarget<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  target: S.Transition<TContext, TState, TEvent>,\n): S.TransitionDefinition<TContext, TState, TEvent> {\n  return isString(target) ? { target } : target\n}\n\nexport function determineTransitionFn<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject,\n>(transitions: S.Transitions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    return toArray(transitions)\n      .map(toTarget)\n      .find((transition) => {\n        // get condition function\n        const determineGuard = determineGuardFn(transition.guard, guardMap)\n        const guard = determineGuard(context, event, meta)\n        return guard ?? transition.target ?? transition.actions\n      })\n  }\n}\n","import { callAll, isString } from \"@zag-js/utils\"\n\ninterface Props {\n  [key: string]: any\n}\n\nconst clsx = (...args: (string | undefined)[]) =>\n  args\n    .map((str) => str?.trim?.())\n    .filter(Boolean)\n    .join(\" \")\n\nconst CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g\n\nconst serialize = (style: string): Record<string, string> => {\n  const res: Record<string, string> = {}\n  let match: RegExpExecArray | null\n  while ((match = CSS_REGEX.exec(style))) {\n    res[match[1]!] = match[2]!\n  }\n  return res\n}\n\nconst css = (\n  a: Record<string, string> | string | undefined,\n  b: Record<string, string> | string | undefined,\n): Record<string, string> | string => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`\n    a = serialize(a)\n  } else if (isString(b)) {\n    b = serialize(b)\n  }\n  return Object.assign({}, a ?? {}, b ?? {})\n}\n\ntype TupleTypes<T extends any[]> = T[number]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nexport function mergeProps<T extends Props>(...args: T[]): UnionToIntersection<TupleTypes<T[]>> {\n  let result: Props = {}\n\n  for (let props of args) {\n    for (let key in result) {\n      if (key.startsWith(\"on\") && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key])\n        continue\n      }\n\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key])\n        continue\n      }\n\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key])\n        continue\n      }\n\n      result[key] = props[key] !== undefined ? props[key] : result[key]\n    }\n\n    // Add props from b that are not in a\n    for (let key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as any\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}